\chapter{Soluciones a los Ejercicios}

Este (largo) capítulo provee soluciones a los ejercicios
sugeridos en los capítulos principales del libro. No obstante,
también contiene muchísimo más.
\index{solutions to the exercises}

Primero, en muchos casos, provee varias soluciones diferentes,
ilustrando así estrategias distintas para solucionar un problema,
discutiendo sus méritos respectivos o desventajas y usualmente
mostrando soluciones que pueden ser más eficientes que otras.


Segundo, usualmente provee muchísima información adicional o ejemplos
complementarios.

Solo el alto volumen de ejemplos de código de este capítulo podría 
enseñarte muchísimo sobre la programación en general y acerca del lenguaje
Perl~6 en particular.

Finalmente, este capítulo algunas veces introduce (con ejemplos) conceptos
nuevos serán discutidos en capítulos posteriores de este libro. Haber visto
tales ejemplos puede ayudarte a tener una mayor comprensión de estas
nuevas ideas al leer estos capítulos posteriormente. En algunos casos, este
capítulo discute o introduce nociones que no será discutidas en otra
parte del libro.

Cuando resuelvas un ejercicio, aún si crees que lo hiciste maravillosamente,
por favor asegúrate de consultar las soluciones en este capítulo e intentarlas:
es altamente probable que aprenderás algo de ellas.

%\section{Ejercicios del Capítulo~3: Funciones y Subrutinas}
\section{Ejercicios del Capítulo~\ref{funcchap}: Funciones y Subrutinas}

\subsection{Ejercicio~\ref{right_justify}: Subrutina alinear-a-derecha (p.~\pageref{right_justify})}
\label{sol_right_justify}
\index{right-justify}

El objetivo es escribir una subrutina que imprima una cadena
de texto con suficiente espacio en blanco inicial para que 
la última letra de la cadena de texto esté en la columna 70
de la pantalla (o terminal).

Este el primer ejercicio real de este libro, así que hagámoslo paso
a paso:

\begin{verbatim}
use v6;
sub alinear-a-derecha( $cadena-entrada ) {
    my $long_cadena = chars $cadena-entrada;
    my $long_restante = 70 - $long_cadena;
    my $espacios_delanteros = " " x $long_restante;
    say $espacios_delanteros, $cadena-entrada;
}
alinear-a-derecha("Larry Wall");
alinear-a-derecha("The quick brown fox jumps over the lazy dog");
\end{verbatim}

Esta subrutina:
\begin{itemize}
\item Asigna la cadena de entrada a la variable \verb|$long_cadena|;
\item Computa el número de espacios en blanco que necesitará para
agregarse al inicio de la línea a mostrarse para que finalice 
en la columna 70. Asigna este resultado a la variable \verb|$long_restante|;
\item Crea la cadena de texto \verb|$espacios_delanteros| con el número 
necesario de espacios en blanco;
\item Imprime los \verb|$espacios_delanteros| y la \verb|$cadena-entrada|
uno detrás de otro para obtener el resultado deseado. 
\end{itemize}

Esto muestra lo siguiente:

\begin{verbatim}
                                                            Larry Wall
                           The quick brown fox jumps over the lazy dog
\end{verbatim}
Sin embargo, podemos hacer el código más conciso al componer 
algunas de las sentencias y expresiones:
\index{composition}

\begin{verbatim}
sub alinear-a-derecha( $cadena-entrada ) {
    my $espacios_delanteros = " " x (70 - $cadena-entrada.chars);
    say $espacios_delanteros, $cadena-entrada;
}
\end{verbatim}

Podríamos hasta reducirla a una subrutina más corta con una 
sola línea:

\begin{verbatim}
sub alinear-a-derecha( $cadena-entrada ) {
    say " " x 70 - $cadena-entrada.chars, $cadena-entrada;
}
\end{verbatim}

Esto funciona bien, pero podría argumentarse que esta última
versión es menos clara. De hecho, la variable temporaria
\verb|$espacios_delanteros| usada en la versión previa tenía 
un nombre que documentaba lo que la subrutina estaba haciendo.
Puedes hacer el código muy conciso en el último ejemplo, 
pero algunas veces se puede volver un poco terso, así que 
hay una compensación entre lo conciso y la claridad.

Nota que hay dos funciones integradas, {\tt printf} y 
{\tt sprintf}, que pueden realizar tareas similares. También
está el método \verb|.fmt| para producir salida formateada.

\index{printf function}
\index{sprintf function} 
\index{fmt method}

\subsection{Ejercicio~\ref{do_it_twice}: Subrutina do-twice (p.~\pageref{do_it_twice})}
\label{sol_do_it_twice}
\index{do-twice}

Para agregar un destinatario al saludo, necesitamos:
\begin{itemize}
\item Pasar un segundo argumento en la llamada a  
{\tt do-twice} (la cadena de texto ``World'')
\item Agregar un parámetro nuevo en la signatura de la subrutina
(\verb|$destinatario|)
\index{signature}
\item Agregar este parámetro nuevo como un argumento en las llamadas
a \verb|$código|
\item Agregar una signatura con un parámetro (\verb|$dest|) en la definición de la
subrutina {\tt saludar}
\item Usar este parámetro nuevo en la sentencia de impresión
\end{itemize} 

Esto resulta en el código siguiente:

\begin{verbatim}
sub do-twice( $código, $destinatario ) {
    $código($destinatario); 
   	$código($destinatario);
}
sub saludar( Str $dest ) {
    say "¡Hello $dest!";
}
do-twice &saludar, "World";
\end{verbatim}

Esto muestra:

\begin{verbatim}
¡Hello World!
¡Hello World!
\end{verbatim}

Para la pregunta siguiente, reemplazamos la subrutina {\tt saludar}
con la subrutina {\tt doble-impresión}:

\begin{verbatim}
sub do-twice( $código, $mensaje ) {
    $código( $mensaje ); 
    $código( $mensaje );
}
sub doble-impresión( $valor ) {
    say $valor;
    say $valor;
}
do-twice &doble-impresión, "What's up doc";
\end{verbatim}

Esto imprime ``What's up doc'' cuatro veces.

Finalmente, agregamos la subrutina nueprint-twiceva {\tt do-four} 
y las dejamos llamar la subrutina {\tt do-twice} dos veces,
lo cual imprime el mensaje ocho veces:

\begin{verbatim}
sub do-twice( $código, $mensaje ) {
	$código( $mensaje ); 
	$código( $mensaje );
}
sub doble-impresión( $valor ) {
	say $valor;
	say $valor;
}
sub do-four( $código, $mensaje ) {
    do-twice $código, $mensaje;
    do-twice $código, $mensaje;
}
do-four &doble-impresión, "What's up doc";
\end{verbatim}

\subsection{Ejercicio~\ref{draw_a_grid}: Subrutina imprimir-cuadr (p.~\pageref{draw_a_grid})}
\label{sol_draw_a_grid}
\index{print-grid}

Para imprimir una cuadrícula como la requerida en el ejercicio,
necesitamos imprimir cada línea una por una, y tenemos básicamente
dos tipos de línea: las tres líneas ``con rayas`` y las ocho líneas
sin rayas, las cual llamaremos ``líneas vacías`` porque están 
parcialmente vacías (sin rayas).

Para evitar la repetición de código, una manera de hacerlo es 
creando una cadena de texto para cada uno de los dos tipos de líneas
e imprimir estas cadenas de texto de acuerdo a las necesidades.

Esta es una de las soluciones posibles:

\begin{verbatim}
use v6;

my $cuatro-rayas   = "- " x 4;
my $línea-rayada = ("+ " ~ $cuatro-rayas ) x 2 ~ "+" ;
my $espacios       = " " x 9;
my $línea-vacía  = ("|" ~ $espacios ) x 2 ~ "|" ;

sub decir-cuatro-veces( $valor ) {
    say $valor;
    say $valor;
    say $valor;
    say $valor;
}
sub imprimir-cuadr {
    say $línea-rayada;
    decir-cuatro-veces $línea-vacía;
    say $línea-rayada;
    decir-cuatro-veces $línea-vacía;
    say $línea-rayada;
}
imprimir-cuadr;
\end{verbatim}

Obviamente hay maneras mejores de hacer algo cuatro veces
que solo repetir \verb|say $valor;| cuatro veces con 
en la subrutina {\tt decir-cuatro-veces} más arriba, pero esto será discutido
en el Capítulo\ref{conditionals} (ver Sección~\ref{for_loops}).

Para dibujar una cuadrícula similar con cuatro filas y cuatro columnas,
primero necesitamos modificar las cadenas usadas para imprimir las
líneas:

\begin{verbatim}
my $línea-rayada = ("+ " ~ $cuatro-rayas ) x 4 ~ "+" ;
# ...
my $línea-vacía  = ("|" ~ $espacios ) x 4 ~ "|" ;
\end{verbatim}

Además de eso, podríamos modificar a {\tt imprimir-cuadr} para que 
solo imprima cada línea el número requerido de veces. Pero eso
involucra un poco de repetición de código, y el propósito de
este ejercicio es usar las subrutinas para permitir la reutilización
de código.

Hay dos cosas que necesitamos hacer cuatro veces repetidamente. Hace sentido
escribir una subrutina {\tt hacer-cuatro-veces} que se usará para crear
la subrutina {\tt decir-cuatro-veces} y para llamar filas completas
cuatro veces. A esta subrutina se le pasará la referencia de código para 
las acciones específicas requeridas:

\begin{verbatim}
my $cuatro-rayas   = "- " x 4;
my $línea-rayada   = ("+ " ~ $cuatro-rayas ) x 4 ~ "+" ;
my $espacios       = " " x 9;
my $línea-vacía    = ("|" ~ $espacios ) x 4 ~ "|" ;

sub hacer-cuatro-veces( $código ) {
    $código();
    $código();
    $código();
    $código();
}
sub decir-cuatro-veces( $valor ) {
    hacer-cuatro-veces(sub {say $valor});
}
sub impr-cuadr-sin-fondo {
    say $línea-rayada;
    decir-cuatro-veces $línea-vacía;
}
sub imprimir-cuadr {
    hacer-cuatro-veces(&impr-cuadr-sin-fondo);
    say $línea-rayada;
}
imprimir-cuadr;
\end{verbatim}

Además, en lugar de declarar las variables globales para las
cadenas de texto que representan las líneas, es mejor práctica 
declararlas y definirlas dentro de las subrutinas donde son usadas.
Ya no necesitamos la subrutina {\tt decir-cuatro-veces}; podemos
solo pasar los argumentos relevantes a la subrutina 
{\tt hacer-cuatro-veces} para obtener el mismo efecto. Esto
resulta en el programa siguiente:

\begin{verbatim}
sub hacer-cuatro-veces( $código, $val ) {
    $código($val);
    $código($val);
    $código($val);
    $código($val);
}
sub impr-cuadr-sin-fondo( $línea-punteada ) {
    say $línea-punteada;
    my $espacios = " " x 9;
    my $línea-espacio = ("|" ~ $espacios ) x 4 ~ "|" ;
    hacer-cuatro-veces(&say, $línea-espacio);
}
sub imprimir-cuadr {
    my $cuatro-rayas = "- " x 4;
    my $línea-rayada = ("+ " ~ $cuatro-rayas ) x 4 ~ "+" ;
    hacer-cuatro-veces(&impr-cuadr-sin-fondo, $línea-rayada);
    say $línea-rayada;
}
imprimir-cuadr;
\end{verbatim}
\index{print-grid}

%\section{Ejercicios del Capítulo~4: Condicionales y Recursión}
\section{Ejercicios del Capítulo~\ref{conditionals}: Condicionales y Recursión}

\label{sol_do_n_times}

\subsection{Subrutina hacer-n-veces, Ejercicio Sugerido en la Sección~\ref{do_n_times} (p.~\pageref{do_n_times})}

Necesitamos una subrutina que tome una función y un número, {\tt \$num},
como argumentos, y que llame la función dada  {\tt \$num} veces.

\index{function!recursive}
La subrutina {\tt hacer-n-veces} es recursiva y se llama a sí misma
con un argumento disminuido. La recursión se para cuando este argumento
es 0. \verb|$subref| es una subrutina anónima llamada dentro del cuerpo 
de {\tt hacer-n-veces}:

\begin{verbatim}
sub hacer-n-veces( $refcódigo, Int $num) {
     return if $num <= 0;
     $refcódigo();
     hacer-n-veces $refcódigo, $num - 1;
}

my $subref = sub { say "Carpe diem";}

hacer-n-veces $subref, 4;
\end{verbatim}

This prints:

\begin{verbatim}
Carpe diem
Carpe diem
Carpe diem
Carpe diem
\end{verbatim}

\subsection{Ejercicio~\ref{int_div_modulo}: Días, Horas, Minutos, y Segundos (p.~\pageref{int_div_modulo})}
\label{sol_int_div_modulo}

La siguiente es una manera posible de convertir un número de
segundos a números de días, horas, minutos y segundos:
\index{modulo operator}
\index{operator!mod}
\index{integer division}
\index{operator!div}


\begin{verbatim}
días-HMS(240_000);

sub días-HMS( Int $segundos ) {
    my $minutes = $segundos div 60;
    my $seg_restantes = $segundos mod 60;
    my ($horas, $min_restantes) = $minutos div 60, $minutos mod 60;
    my ($días, $h_restantes)    = $horas div 24, $horas mod 24;
    say "$días $h_restantes $min_restantes $seg_restantes"; 
              #  imprime: 2 18 40 0
}
\end{verbatim}

Las primeras dos líneas realizan la división entera y la
operación de módulo separadamente. Para los dos casos
siguientes, hacemos las dos operaciones en una sola línea, usando
una sintaxis de lista.

Las variables \verb|$minutos|, \verb|$horas|, y \verb|$días|
se computan todas en una manera similar. El código podría hacerse
más modular al usar una subrutina para calcular los \verb|$minutos|,
las \verb|$horas|, y las \verb|$días|. Aunque las subrutinas fructuosas
serán realmente usadas en el capítulo siguiente, hemos ya visto 
varios ejemplos de ellas y pueden proveer un resumen acerca de cómo
podrían ser utilizadas: 

\begin{verbatim}
sub div_mod( Int $entrada, Int $num-base ) {
    return $entrada div $num-base, $entrada mod $num-base;
}
sub días-HMS( Int $segundos ) {
    my ($minutos, $seg_restantes) = div_mod $segundos, 60;
    my ($horas, $min_restantes)   = div_mod $minutos, 60;
    my ($días, $h_restantes)      = div_mod $horas, 24;
    say "$días $h_restantes $min_restantes $seg_restantes"; 
}
\end{verbatim}

Para incitar al usuario a entrar un número de segundos,
podrías hacer esto:
\index{prompt}
\index{function!prompt}

\begin{verbatim}
my $seg = prompt "Por favor entre el número de segundos: ";
días-HMS $seg.Int;
\end{verbatim}

En la vida real, sería bueno verificar que la entrada proveída
por el usuario es un entero positivo y preguntar nuevamente
si no lo es. Como un ejercicio adicional, podrías insertar el
código anterior en una subrutina recursiva que imprime un mensaje
de error y se llama a sí misma otra vez si la entrada del usuario 
no es válida. LA solución al ejercicio siguiente 
(Sección~\ref{sol_fermat_ex}) provee un ejemplo de una subrutina
recursiva diseñada para incitar al usuario a suministrar la 
entrada nuevamente; esto podría ayudarte a cómo hacerlo si 
encuentras alguna dificultada. 
\index{input!validation}

Intenta reemplazar la línea de código siguiente:
\begin{verbatim}
say "$días $h_restantes $min_restantes $seg_restantes"; 
\end{verbatim}
%
con esta:
\index{printf function}

\begin{verbatim}
printf "%d días %d horas %d minutos %d segundos \n", días-HMS 240_000;
\end{verbatim}
para mostrar una salida mejor formateada.

\subsection{Ejercicio~\ref{fermat_ex}: Teorema de Fermat (p.~\pageref{fermat_ex})}
\label{sol_fermat_ex}
\index{Fermat, Pierre}
\index{Fermat's Last Theorem}

La subrutina {\tt chequear-fermat} chequea si:

\[ a^n + b^n = c^n \]
%

es verdadera para los valores \emph{a}, \emph{b}, 
\emph{c}, and \emph{n} suministrados.

\begin{verbatim}
sub chequear-fermat( Int $a, Int $b, Int $c, Int $n ) {
    if $a**$n + $b**$n == $c**$n {
        if $n > 2 {
            say "¡Santo dios, Fermat estaba equivocado!" if $n > 2;
        } elsif $n == 2 or $n ==1 {
            say "Correcto";
        }
        return True; 
    }
    return False
}

say "Correcto for 3, 4, 5, 2" if chequear-fermat 3, 4, 5, 2;
obtener-entrada());

sub obtener-entrada {
    say "Tu misión, Jim, si la aceptas, es ";
    say "proveer los valores A, B, C y n que satisfacen la ecuación de Fermat:";
    say "  A ** n + B ** n = C * *n";
    my $a = prompt "Por favor proveer un valor para A: ";
    my $b = prompt "Por favor proveer un valor para B: ";
    my $c = prompt "Por favor proveer un valor para C: ";
    my $n = prompt "Por favor proveer un valor para el exponente: ";
    if chequear-fermat($a.Int, $b.Int, $c.Int, $n.Int) {
        say "La ecuación se satisface para tus valores";
    } else {
        say "Nope. La ecuación no está correcta."
    }
    my $intentar-nuevamente = prompt "¿Quieres intentar nuevamente (S/N)?";
    obtener-entrada if $intentar-nuevamente eq 'Y';
}
\end{verbatim}
%

El último teorema de Fermat ha sido probado y, evidentemente,
la misión es realmente imposible si $n > 2$; quizás esta vez Jim Phelps 
debería declinar la misión.

\subsection{Ejercicio~\ref{triangle}: ¿Es un triángulo? (p.~\pageref{triangle})}
\label{sol_triangle}
\index{triangle}

Esta es una subrutina posible para verificar si puedes 
hacer un triángulo con tres longitudes de palillos dadas:

\begin{verbatim}
sub es-triángulo( Numeric $x, Numeric $y, Numeric $z ) {
    my $válido = True;
    $válido = False if $x > $y + $z;
    $válido = False if $y > $x + $z;
    $válido = False if $z > $x + $y;
    if $válido {
        say "Sí"; 
    } else {
        say "No";
    }
}
es-triángulo 1, 3, 4;  # -> Sí
es-triángulo 1, 3, 6;  # -> No
\end{verbatim}

Otra manera de hacer esto sería comenzar a encontrar la longitud 
más larga y probar con esa solamente, pero eso no hace el 
algoritmo significativamente más simple.

Incitar el usuario a entrar tres longitudes se ha mostrado en
los ejercicios previos; nada nuevo aquí. No obstante, esta es 
una forma nueva de hacerlo:

\begin{verbatim}
my ($a, $b, $c) = split " ", 
    prompt "Por favor entra tres longitudes (separadas por espacios): ";
es-triángulo $a.Int , $b.Int , $c.Int;
\end{verbatim}


\subsection{Ejercicio~\ref{fibonacci}: Los Números Fibonacci (p.~\pageref{fibonacci})}
\label{sol_fibonacci}
\index{Fibonacci}
\index{Fibonacci!numbers}

Los números Fibonacci son una secuencia de números en la cual
los primeros dos números son igual a 1 y cualquier número subsecuente
es la suma de los dos números anteriores, por ejemplo:

\begin{verbatim}
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
\end{verbatim}

Imprimir los primeros 20 números Fibonacci:

\begin{verbatim}
sub n_fibonacci (Int $n) {
    my $fib1 = 1;
    my $fib2 = 1;
    say $_ for $fib1, $fib2;
    for 3..$n {
        my $nuevo_fib = $fib1 + $fib2;
        say $nuevo_fib;
        ($fib1, $fib2) = $fib2, $nuevo_fib;
    }
}
n_fibonacci 20;
\end{verbatim}

Imprimir el número $n$th Fibonacci:

\begin{verbatim}
my $n = prompt "Entra el número Fibonacci a buscarse: ";
$n = $n.Int;
say fibo($n);

sub fibo( Int $n ) {
    my ($fib1, $fib2) = 1, 1;
    for 3..$n {
        my $nuevo_fib = $fib1 + $fib2;
        ($fib1, $fib2) = $fib2, $nuevo_fib;
    }
    return $fib2;
}    
\end{verbatim}
\index{Fibonacci!numbers}


\subsection{Ejercicio~\ref{sub_recurse}: La Subrutina {\tt recurse} (p.~\pageref{sub_recurse})}
\label{sol_sub_recurse}
\index{recursion}

Examinando el código de la subrutina {\tt recurse}, 
la primera cosa que deberías notar es cada vez que es llamada
recursivamente, el primer argumento (\verb|$n|) es reducido por
uno comparado con la llamada previa. Si el valor inicial de \verb|$n|
es un número entero positivo, la sucesión de llamadas eventualmente
llegará al caso base donde \verb|$n == 0|, y la cascada de llamadas
recursivas cesará.

Si \verb|$n| no es un número entero o si es negativo, obtendremos una
recursión infinita.

Una manera de visualizar cómo el programa se ejecuta es mostrar
los parámetros de la subrutina en cada llamada:

\begin{verbatim}
sub recurse( $n, $s ) {
    say "Args : n = $n, s = $s";
    if ($n == 0) {
        say $s;
    } else {
        recurse $n - 1, $n + $s;
    }
}
recurse 3, 0;
\end{verbatim}
Esto imprimiría:
\begin{verbatim}
Args : n = 3, s = 0
Args : n = 2, s = 3
Args : n = 1, s = 5
Args : n = 0, s = 6
6
\end{verbatim}

\index{guardian pattern}
Para evitar que los argumentos conduzcan a una recursión infinita,
podemos agregar restricciones de tipo entero a la signatura de la
subrutina y algún código para cesar la recursión si el primer 
argumento es negativo, por ejemplo:
\index{signature}

\begin{verbatim}
sub recurse( Int $n, Int $s ) {
    say "Args : n = $n, s = $s";
    if $n == 0 {
        say $s;
    } elsif $n < 0 {
        die '¡PARA! $n es negativo, nos damos por vencidos';
    } else {
        recurse $n - 1, $n + $s;
    }
}
\end{verbatim}
%

Ahora, si llamamos a {\tt recurse} con un valor negativo para \verb|$n|,
obtenemos un error:

\begin{verbatim}
Args : n = -1, s = 0
¡PARA! $n es negativo, nos damos por vencidos
  in sub recurse at recurse2.pl6 line 6
  in block <unit> at recurse2.pl6 line 12
\end{verbatim}
%

Si la llamamos con un valor que no es entero para \verb|$n|:

\begin{verbatim}
===SORRY!=== Error while compiling recurse2.pl6
Calling recurse(Rat, Int) will never work with declared
signature (Int $n, Int $s)
at recurse2.pl6:12
------> <BOL><HERE>recurse 1.5, 0;
\end{verbatim}
%

\index{multi!keyword}
\index{multi!subroutine}
Otra posibilidad sería usar una característica de Perl~6 que no
hemos discutido todavía, subrutinas \emph{multi}, las cuales
son descritas en la Sección~\ref{multisubs} (p.~\pageref{multisubs}).
La idea es declarar dos versiones de la subrutina {\tt recurse},
las cuales tienen el mismo nombre pero signaturas diferentes. 
El compilador averiguará cual versión de {\tt recurse} debe llamar
dependiendo en cual signatura aplica a los argumentos pasados 
a la subrutina:

\begin{verbatim}
multi recurse( Int $n where $n >= 0, $s ) {
    say "Args : n = $n, s = $s";
    if ($n == 0) {
        say $s;
    } else {
        recurse $n - 1, $n + $s;
    }
}

multi recurse( $n , $s ) {
    say "Args : n = $n, s = $s";
    # haz algo diferente para tal caso, por ejemplo:
    # recurse (abs $n.Int), $s; # llamando la primera versión de recurse
    # or simply:
    say '¡PARA! $n es negativo, nos damos por vencidos';
}
\end{verbatim}

Si el primer parámetro es un entero positivo, la primera
versión de {\tt recurse} será llamada. Por lo contrario, 
la segunda versión se ejecutará:

\begin{verbatim}
$ perl6 recurse.pl6
Args : n = 6.1, s = 0
¡PARA! $n es inválido, nos damos por vencidos

$ perl6 recurse.pl6
Args : n = -1, s = 0
¡PARA! $n es negativo, nos damos por vencidos
\end{verbatim}
%

Intentar ejecutar el código siguiente para la segunda
definición de {\tt recurse}:

\begin{verbatim}
multi recurse( $n , $s ) {
    say "Args : n = $n, s = $s";
    recurse (abs $n.Int), $s;
}
\end{verbatim}
%
para observar lo que está ocurriendo en ese caso.

%\section{Ejercicios del Capítulo~5: Funciones Fructuosas}
\section{Ejercicios del Capítulo~\ref{fruitchap}: Funciones Fructuosas}

\subsection{Comparar, ejercicio al final de la Sección~\ref{compare} (p.~\pageref{compare})}
\label{sol_compare}
\index{compare function}

Aquí presentamos una subrutina que toma dos números y los compara,
y devuelve 1 si el primero es mayor que el segundo, 0 si son iguales,
y -1 por lo contrario (i.e., si el segundo es mayor que el primero):

\begin{verbatim}
sub comparar( Numeric $x, Numeric $y ) {
    return 1 if $x > $y;
    return 0 if $x == $y;
    return -1;
}

say comparar 4, 7;   # -1
say comparar 7, 4;   #  1
say comparar 5, 5;   #  0
\end{verbatim}

Nota: esto ejemplifica una función {\tt comparar } de tres
sentidos comúnmente usado para ordenar un número en los
lenguajes de programación, incluyendo versiones más antiguas 
de Perl (tal como Perl~5). En Perl~6, los operadores que 
implementan esta funcionalidad (los comparadores de tres
sentidos \verb|cmp|, \verb|leg| y \verb'<=>') devuelven tipos 
especiales de valores: {\tt Order::More}, {\tt Order::Less}, y 
{\tt Order::Same}. (ver Sección~\ref{sorting} 
\ifplastex \else
acerca de ordenamiento en el capítulo sobre arrays y listas 
\fi
para más detalles.)
\index{compare function}
\index{sorting}

\subsection{Hipotenusa, ejercicio al final de la Sección~\ref{hypotenuse} (p.~\pageref{hypotenuse})}
\label{sol_hypotenuse}
\index{hypotenuse}

El objetivo de este ejercicio es usar el plan de desarrollo incremental
para calcular la hipotenusa de un triángulo rectángulo (usando el teorema
de Pitágora).

Podríamos comenzar con un esbozo de la subrutina:

\begin{verbatim}
sub hipotenusa( Numeric $x, Numeric $y ) {
    return 0;
}
say hipotenusa 3, 4;
\end{verbatim}
%

Esto imprimirá 0 obviamente.

Luego, calculamos la hipotenusa e lo imprime dentro de la subrutina:

\begin{verbatim}
sub hipotenusa( Numeric $x, Numeric $y ) {
    my $hipotenusa = sqrt ($x ** 2 + $y ** 2);
    say "hipotenusa = $hipotenusa";
    return 0.0;
}
say hipotenusa 3, 4;
\end{verbatim}
%

Esto imprime:

\begin{verbatim}
hypotenuse = 5
0
\end{verbatim}
%

\index{hypotenuse}
La subrutina está calculando la hipotenusa (5) correctamente,
pero está devolviendo el valor ficticio 0. Ahora podemos devolver
seguramente el resultado (y remover el andamiaje):

\begin{verbatim}
sub hipotenusa( Numeric $x, Numeric $y ) {
    my $hipotenusa = sqrt ($x ** 2 + $y ** 2);
    return $hipotenusa;
}
say hipotenusa 3, 4;
\end{verbatim}
%

Esto imprime correctamente el valor de la hipotenusa.

Finalmente, podemos, si así lo deseamos, remover la variable 
temporaria para simplificar la subrutina aún más:
\begin{verbatim}
sub hipotenusa( Numeric $x, Numeric $y ) {
    return sqrt ($x ** 2 + $y ** 2);
}
say hipotenusa 3, 4;
\end{verbatim}
%
\index{hypotenuse}

\subsection{Operadores de Relación Encadenados (en la Sección~\ref{isbetween})}
\label{sol_isbetween}
\index{is-between}
\index{chained relational operator}
\index{chained conditional}
\index{conditional!chained}

Necesitamos una subrutina para averiguar si la expresión $x \le y \le z$
es verdadera o falsa. Simplemente necesitamos probarlo con un operador
de relación encadenado y devolver el resultado:

\begin{verbatim}
sub está-entre( Numeric $x, Numeric $y, Numeric $z ) {
    return $x <= $y <= $z;
}
say está-entre 3, 5, 6; # True
say está-entre 3, 8, 7; # False
say está-entre 6, 5, 6; # False
say está-entre 6, 6, 7; # True
\end{verbatim}
%

Nota que las pruebas proveídas aquí son solo un número limitado 
de ejemplos, con propósitos de ilustración. Un conjunto de pruebas
más rigurosa podría ser necesario (probar por ejemplo con números
negativos y positivos). Más tarde veremos mejores maneras de 
construir conjuntos de pruebas más robustos (ver por ejemplo la 
Sección~\ref{test_module} y la solución al ejercicio en la  
Sección~\ref{sol_fact_operator}).
\index{test module}


\subsection{La Función Ackermann (Ejercicio~\ref{ackermann})}
\label{sol_ackermann}
\index{Ackermann function}

Escribe una subrutina para computar la función Ackermann.
La función Ackermann, $A(m, n)$, se define como sigue:

\begin{eqnarray*}
A(m, n) = \begin{cases} 
              n+1 & \mbox{if } m = 0 \\ 
        A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\ 
A(m-1, A(m, n-1)) & \mbox{if } m > 0 \mbox{ and } n > 0.
\end{cases} 
\end{eqnarray*}
%
Aquí presentamos una manera de computar la función
Ackermann en Perl:

\begin{verbatim}
sub ack (Int $m, Int $n) {
    return $n + 1 if $m == 0;
    return ack($m - 1, 1) if $n == 0;
    return ack($m - 1, ack($m, $n-1));
}
say ack 3, 4;    # -> 125
\end{verbatim}

Hemos usados paréntesis para mostrar mejor la estructura,
pero funciona igualmente sin ellos. Aún en la última línea
de código con dos llamadas a la subrutina, la signatura de la
subrutina con dos números enteros es suficiente para que el
compilador de Perl~6 entienda cual argumento está asociado
con una de la llamada:
\index{signature}

\begin{verbatim}
sub ack (Int $m, Int $n) {
    # say "m n = $m, $n";
    return $n + 1 if $m == 0;
    return ack $m - 1, 1 if $n == 0;
    return ack $m - 1, ack $m, $n-1;
}
\end{verbatim}
%
\index{Ackermann, Wilhelm}

La función Ackermann está definida para números enteros 
que no son negativos. Como un ejercicio adicional, modifica
la subrutina {\tt ack} para prevenir que argumentos negativos 
sean suministrados. Discutimos dos maneras diferentes de hacer
esto en la Sección~\ref{guardian}.
\index{guardian pattern}


\subsection{Palíndromos (Ejercicio~\ref{palindrome})}
\label{sol_palindrome}
\index{palindrome}
\index{recursion}

Escribe una subrutina recursiva que chequea si una palabra 
es un palíndromo:

\begin{verbatim}
sub primera_letra( Str $palabra ){
	return substr $palabra, 0, 1;
}

sub última_letra( Str $palabra ){
	return substr $palabra, *-1, 1;
}

sub centro_letra( Str $palabra ){
	return substr $palabra, 1, *-1;
}

sub es-palindromo( Str $palabra ) {
    return True if $palabra.chars <= 1;
    return False if primera_letra($palabra) ne última_letra($palabra);
    return es-palindromo(centro_letra($palabra))
}
for ("bob", "otto", "laurent", "ana", "reconocer") -> $x {
    say "¿Es $x un palíndromo? Respuesta: ", es-palindromo($x);
}
\end{verbatim}

Result:
\begin{verbatim}
¿Es bob un palíndromo? Respuesta: True
¿Es otto un palíndromo? Respuesta: True
¿Es laurent un palíndromo? Respuesta: False
¿Es ana un palíndromo? Respuesta: True
¿Es reconocer un palíndromo? Respuesta: True
\end{verbatim}

El tercer parámetro (longitud) de la función integrada {\tt substr}
es opcional. En ese caso, {\tt substr} devolverá todos los
caracteres desde una posición dada. Así que la subrutina
\verb|primera_letra| podría simplificarse así:

\begin{verbatim}
sub primera_letra( Str $palabra where $palabra.chars >= 2 ){
	return substr $palabra, 0;
}
\end{verbatim} 

Y la subrutina \verb|última_letra| podría beneficiarse de la
misma simplificación.

Nota: la función integrada {\tt flip} o el método {\tt .flip}
de Perl devuelve una versión inversa de una cadena de texto 
y proveería una solución mucho más fácil:

\begin{verbatim}
sub es-palindromo( Str $palabra ) {
    return $palabra eq $palabra.flip;
}
\end{verbatim}
\index{flip function}
\index{palindrome}

\subsection{Potencias (Ejercicio~\ref{power})}
\index{power}
\label{sol_power}

Escribe una subrutina recursiva que chequea sin un número es una
potencia de otro número:

\begin{verbatim}
sub es-potencia-de (Int $a, Int $b) {
    return False unless $a %% $b;
    return True if $a == $b;
    return es-potencia-de Int($a/$b), $b;
}

say es-potencia-de 16, 4;
say es-potencia-de 25, 5;
say es-potencia-de 125, 5;
say es-potencia-de 600, 20;
say es-potencia-de 8000, 20;
\end{verbatim}
%

Esto resulta en:
\begin{verbatim}
True
True
True
False
True
\end{verbatim}

Al agregar una sentencia {\tt say} para visualizar las llamadas recursivas,
obtenemos:

\begin{verbatim}
sub es-potencia-de (Int $a, Int $b) {     
    return False unless $a %% $b;      
    return True if $a == $b;           
    say "$a\t$b";                      
    return es-potencia-de Int($a/$b), $b; 
}                                      
\end{verbatim}

Si ejecutamos a {\tt es-potencia-de} con los argumentos 1024 y 2,
obtenemos los valores de \verb|$a| y \verb|$b| a lo largo de las
llamadas recursivas:

\begin{verbatim}
1024    2
512     2
256     2
128     2
64      2
32      2
16      2
8       2
4       2
True
\end{verbatim}
%
\index{power}

\subsection{Encontrando el MCD de Dos Números, Ejercicio~\ref{gcd} (p.~\pageref{gcd})}

\index{gcd function}
\index{greatest common divisor (GCD)}
\index{GCD (greatest common divisor)}
\label{sol_gcd}

Escribe una subrutina que devuelva el máximo común divisor de dos números:

\begin{verbatim}
sub mcd( Int $a, Int $b ) {
    return $a if $b == 0;
    return $b if $a == 0;
    return mcd($b, $a mod $b);
}

say mcd 125, 25;
say mcd 2048, 256;
say mcd 256, 4096;
say mcd 2048, 1;
say mcd 0, 256;
say mcd 33, 45;
\end{verbatim}

\index{Euclid's algorithm}
\index{algorithm!Euclid's}
Nota que hay un método más simple para encontrar el MCD de
dos números sin usar la función módulo. Se conoce como 
el algoritmo de Euclides y es considerado el algoritmo más
antiguo (ver \url{https://es.wikipedia.org/wiki/Algoritmo_de_Euclides}).
El algoritmo de Euclides se basa en la observación de que 
el MCD de dos números no cambia si el número mayor es reemplazado
con la diferencia de tal número y el número menor.

Esto podría implementarse en Perl con la siguiente
subrutina recursiva:

\begin{verbatim}
sub mcd( Int $a, Int $b ) { 
    return gcd($b, $a - $b) if $a > $b;
    return gcd($a, $b - $a) if $b > $a;
    return $a;
}
\end{verbatim}
%

Este código funciona perfectamente bien en \emph{casi}
todos los casos, por lo menos para todos los valores
de entrada estrictamente positivos, pero intenta seguir
el flujo de ejecución si uno de los argumentos pasados
a la subrutina, digamos {\tt \$b}, es cero. En este caso,
{\tt mcd} entra en una recursión infinita. Esto usualmente se
conoce como un \emph{edge case} o un \emph{corner case}, i.e.,
un valor de entrada especial para el cual un programa aparentemente
funcional cesa de funcionar apropiadamente.
\index{edge case}
\index{corner case}

Tenemos un problema similar para los valores de entrada
negativos.

Una solución podría ser agregar una restricción de signatura
(o usar un subconjunto de tipo):
\index{subset!type}
\index{type subset}
\index{signature}
\begin{verbatim}
sub mcd( Int $a where $a > 0, Int $b where $b > 0 ) {
    ...
}
\end{verbatim}
%

pero esto no es realmente satisfactorio porque el MCD de cualquier
entero que no es cero y 0 está matemáticamente bien definido y
es igual al primer número.

Dejando al lado por un momento el caso de los números 
negativos, podrías escribir la subrutina nuevamente en 
la siguiente manera:

\begin{verbatim}
sub mcd( Int $a, Int $b ) { 
    return $a if $b == 0;
    return $b if $a == 0;
    return gcd($b, $a - $b) if $a > $b;
    return gcd($a, $b - $a) if $b > $a;
    return $a;
}
\end{verbatim}
%

Concerniente a los números negativos, hay un teorema que dice
que el MCD de $a$ y $b$ es el mismo que el MCD de $a$ y $-b$:

\begin{center}
{\tt mcd(a,b) = mcd(−a,b) = mcd(a,−b) = mcd(−a,−b)}
\end{center}
%

Podemos modificar la subrutina {\tt mcd} aún más:

\begin{verbatim}
sub mcd( Int $a is copy, Int $b is copy ) { 
    $a = -$a if $a < 0;
    $b = -$b if $b < 0;
    return $a if $b == 0;
    return $b if $a == 0;
    return mcd($b, $a - $b) if $a > $b;
    return mcd($a, $b - $a) if $b > $a;
    return $a;
}
\end{verbatim}
%

Esto funciona bien ahora, pero recuerda que una subrutina
recursiva puede ser llamada muchas veces y, por cada llamada, 
las primeras cuatro líneas de código en el programa más arriba
son ejecutadas, aunque son realmente útiles solo en la primera 
llamada: una vez que estas condiciones han sido chequeadas durante
la primera llamada de la subrutina, sabemos que los argumentos
deben ser válidos y permanecer válidos en la cadena de llamadas
recursivas, así que estos chequeos después de la primera llamada
no son necesarios. Esto es un despilfarro y puede conducir a problemas 
innecesarios de rendimiento.

Idealmente, podría ser mejor separar estas cuatro líneas que
chequea las precondiciones de las cascada de llamadas recursivas.
Por ejemplo, podríamos escribir dos subrutinas:

\begin{verbatim}
sub mcd1( Int $c, Int $d ) {
    return mcd1($d, $c - $d) if $c > $d;
    return mcd1($c, $d - $c) if $d > $c;
    return $c;
}

sub mcd( Int $a is copy, Int $b is copy ) { 
    $a = -$a if $a < 0;
    $b = -$b if $b < 0;
    return $a if $b == 0;
    return $b if $a == 0;
    return mcd1 $a, $b;
}
\end{verbatim}
%

Ahora, {\tt mcd} está haciendo todos los chequeos necesarios
de los argumentos iniciales y llama subrutina recursica {\tt mcd1}
con los argumentos que han sido higienizados y que no conducirán
a una recursión infinita. Nota que hemos nombrados los parámetros
dentro de {\tt mcd1} diferentemente para mejor claridad, pero esto
no era necesario; funcionaría igual si hubiésemos mantenido  
a {\tt \$a} y {\tt \$b}.

El código anterior trabaja perfectamente bien.

Aunque podría haber un último problema. Alguien descuidado
(o queriendo ser muy astuto) podría tratar de llamar a {\tt mcd1}
directamente, y así destruyendo los beneficios de los chequeos
realizados por {\tt mcd}. Para prevenir eso, podemos hacer buen uso
del hecho de que las subrutinas tiene ámbito lexical en Perl~6
y pueden ser locales a otras subrutinas: podemos declarar y definir
{\tt mcd1} dentro del cuerpo de la subrutina {\tt mcd}, para que {\tt mcd1}
pueda ser llamada solo desde el interior de la subrutina {\tt mcd}:
\index{lexical subroutine}

\begin{verbatim}
sub mcd( Int $a is copy, Int $b is copy ) { 
    sub mcd($c, $d) {
        return mcd1($d, $c - $d) if $c > $d;
        return mcd1($c, $d - $c) if $d > $c;
        return $c;
    }
    $a = -$a if $a < 0;
    $b = -$b if $b < 0;
    return $a if $b == 0;
    return $b if $a == 0;
    return mcd1 $a, $b;
}

say mcd 125, 25;       # 25
say mcd 2048, 256;     # 256
say mcd 256, 4096;     # 256
say mcd 2048, 1;       # 1
say mcd 0, 256;        # 256
say mcd 33, 45;        # 3
say mcd -4, 6;         # 2
\end{verbatim}

El capítulo~\ref{iteration} tendrá una discusión acerca del ámbito lexical.

\index{gcd function}
\index{Euclid's algorithm}
\index{algorithm!Euclid's}

Podrías estar interesada/o en saber que existe una función integrada
en Perl~6 que encuentra el MCD de dos números. Es la función {\tt gcd}.





%\section{Ejercicios del Capítulo~6: Iteración}
\section{Ejercicios del Capítulo~\ref{iteration}: Iteración}
 
\subsection{Ejercicio~\ref{test_sqrt}: Raíz Cuadrada (p.~\pageref{test_sqrt})}
\label{sol_test_sqrt}
\index{square root}
\index{iteration}

Necesitamos una subrutina que encuentra la raíz cuadrada de un
número al computar sucesivamente las mejore aproximaciones de 
la raíz, usando el método de Newton.
\index{Newton's method}
\index{Newton, Isaac}

Para este ejercicio, he hecho las siguientes decisiones aunque 
algo arbitrarias:

\begin{itemize}
\item He elegido un valor \emph{epsilon} de $10^{-11}$ (o {\tt 1e-11}).
\item He usado \verb|$a/2|  como un estimado inicial de $\sqrt{\$a}$. 
\end{itemize}

Nota que podría tener más sentido declarar este estimado inicial dentro
de la subrutina {\tt mi-raíz-cuad}, en lugar de tener que pasarlo como
un argumento. La justificación para hacer esto es que, en algunos casos, 
la subrutina que hace la llamada tiene información sobre el rango del
valor de entrada y podría por lo tanto ser capaz de proveer un mejor
estimado inicial, lo cual conduce el algoritmo a converger hacia la 
solución mucho más rápido.

Esta es una implementación del método de Newton para computar la
raíz cuadrada de un número:
\index{Newton's method}

\begin{verbatim}
sub mi-raíz-cuad( $a, $estimado is copy ) {
    my $epsilon = 1e-11;
    while True {
        # say "-- Valor intermedio: $estimado";
        my $y = ($estimado + $a/$estimado) / 2;
        last if abs($y - $estimado) < $epsilon;
        $estimate = $y;
    }
    return $estimado;
}

sub imprimir-result( $a, $r, $s, $d ) {
    printf "%d  %.13f  %.13f  %.6e \n", $a, $r, $s, $d;
}

sub probar-raíz-cuadrada {
    say "a  mi-raíz-cuad(a)\t    sqrt(a)\t     difer";
    for 1..9 -> $a {
        my $estimado-ini = $a/2;
        my $result = mi-raíz-cuad $a, $estimado-ini;
        my $sqrt = sqrt $a;
        my $difer = abs($result - $sqrt);
        imprimir-result($a, $result, $sqrt, $diff);
    }
}
    
probar-raíz-cuadrada;
\end{verbatim}

\index{printf function}
La función {\tt printf} ("formatted print") usada en {\tt imprimir-result}
es derivada del lenguaje de programación~C. Su primer argumento
es \emph{formato de cadena de texto}, que describe cómo cada uno de
los siguientes argumentos debería ser formateado. Aquí, el 
formato de cadena de texto requiere al compilador a producir
el primer argumento subsecuente como un entero con signo (la parte \verb|%d|
formato de cadena de texto), los dos argumentos siguiente como
números de coma flotante con 13~números después del punto decimal
(la parte \verb|%.13f|), y el último argumento como
un número de coma flotante en notación científica con 
6~dígitos después del punto decimal (\verb|%.6e|).



\subsection{Ejercicio~\ref{pi_estimate}: Estimado de Pi (p.~\pageref{pi_estimate})}
\label{sol_pi_estimate}
\index{Ramanujan, Srinivasa}
\index{Ramanujan, Srinivasa!pi estimate}
\index{pi!estimate}

El estimado de Pi de acuerdo al algoritmo
de Srinivasa Ramanujan:

\begin{verbatim}
sub factorial( Int $n ) {
    return 1 if $n == 0;
    return $n * factorial $n-1;
}

sub pi-estimado {
    #`{ ======================================
        Algoritmo por Srinivasa Ramanujan 
        (ver http://en.wikipedia.org/wiki/Pi)
        ====================================== }
    my $factor = 2 * 2.sqrt / 9801;
    my $k = 0;
    my $suma = 0;
    while True {
        my $num = factorial(4*$k) * (1103 + 26390*$k);
        my $den = factorial($k)**4 * 396**(4*$k);
        my $term += $factor * $num / $den;
        # say "Término intermedio = $term";
        last if abs($term) < 1e-15;
        $suma += $term;
        $k++;
    }
    return 1 / $suma;
}

say pi-estimado;
# say pi - pi-estimado;
\end{verbatim}

Esto imprime: 3.14159265358979.

Nota como hemos usado el comentario multilínea para proveer
información adicional sobre la subrutina.
\index{multiline comment}
\index{comment}

Eliminar el comentario de la sentencia de impresión muestra 
los pasos hacia la solución:

\begin{verbatim}
Término intermedio = 0.31830987844047
Término intermedio = 7.74332048352151e-009
Término intermedio = 6.47985705171744e-017
-4.44089209850063e-016
\end{verbatim}

%\section{Ejercicios del Capítulo~7: Cadenas de Texto}
\section{Ejercicios del Capítulo~\ref{strings}: Cadenas de Texto}

\subsection{Ejercicio en la Sección~\ref{stringtraversal}: Recorrido de una Cadena de Texto (p.~\pageref{stringtraversal})}
\label{sol_stringtraversal}
\index{string}
\index{string traversal}

El recorrido inverso de una palabra con un bucle {\tt while}
puede escribirse así:
\index{while loop}

\begin{verbatim}
my $fruta = "banana";
my $indice = $fruta.chars;
while $indice > 0 { 
    $indice--;
    my $letra = substr $fruta, $indice, 1; 
    say $letra; 
}
\end{verbatim}
%

El método {\tt chars} devuelve la longitud de la cadena de texto.
La función {\tt substr} encontrará las letras debajo de \verb|$indice|
que se encuentran entre 0 y \verb|longitud - 1|. Es por lo tanto 
práctico disminuir la variable \verb|$indice| antes de usar la función
{\tt substr}. 
\index{chars function}
\index{substr function}

El bucle \verb|while| del código anterior puede escribirse más
forma más concisa:

\begin{verbatim}
my $fruta = "banana";
my $indice = $fruta.chars;
while $indice > 0 { 
    say substr $fruta, --$indice, 1; 
}
\end{verbatim}
%

Aquí, imprimimos el valor devuelto por {\tt substr} directamente,
sin usar una variable temporaria, y disminuimos la variable
\verb|$indice| dentro de la expresión usando una {\tt substr}.
Necesitamos usar la forma prefija del operador de decremento 
porque necesitamos que \verb|$indice| sea reducido antes de 
ser utilizado por {\tt substr}.
\index{prefix decrement operator}
\index{substr function}

El bucle sería aún más conciso si usáramos un {\tt while} 
con un modificador de sentencia (o la sintaxis sufija de {\tt while}):
\index{statement modifier}
\index{postfix!syntax}

\begin{verbatim}
my $fruta = "banana";
my $indice = $fruta.chars;
say substr $fruta, --$indice, 1 while $indice;
\end{verbatim}
%

Esta es la misma idea, usando la función {\tt flip} 
para invertir la cadena de texto:
\index{flip function}

\begin{verbatim}
my $fruta = flip "banana";
my $indice = 0;
say substr $fruta_inv, $indice++, 1 while $indice < $fruta_inv.chars;
\end{verbatim}
%

El objetivo de este ejercicio es entrenarte a usar bucles para
recorrer la cadena de texto. Combinar las funciones o métodos 
{\tt flip} y {\tt comb} haría nuestra solución mucho más simple 
(y probablemente más rápida):
\index{comb function and method}

\begin{verbatim}
.say for "banana".flip.comb;
\end{verbatim}


\subsection{Ejercicio en la Sección~\ref{stringtraversal}: The Ducklings (p.~\pageref{stringtraversal})}
\label{sol_ducklings}

La primera idea que viene a la mente para este ejercicio es 
construir una lista modificada de prefijos de este manera:

\begin{verbatim}
for 'J' .. 'N', 'Ou', 'P', 'Qu' -> $letra { #...}
\end{verbatim}
%

Pero esto no funciona apropiadamente porque crea una lista de
cuatro elementos en la cual el primer elemento es una 
sub-lista desde ``J'' hasta ``N'':

\begin{verbatim}
> say ('J'..'N', 'Ou', 'P', 'Qu').perl;
("J".."N", "Ou", "P", "Qu")
\end{verbatim}
%

Regresaremos a esto más tarde en el libro, pero digamos que
necesitamos {\tt aplanar} esta combinación de listas en una
sola lista iterable, lo cual puede hacerse con el método o la
función {\tt flat} o el operador ``|``:
\index{list flattening}

\begin{verbatim}
for ('J' .. 'N', 'Ou', 'P', 'Qu').flat    -> $letra {#...}
# o: for flat 'J' .. 'N', 'Ou', 'P', 'Qu' -> $letra {...}
# o: for |('J' .. 'N'), 'Ou', 'P', 'Qu'   -> $letra {...}
# Nota: los paréntesis en el último ejemplo son necesarios
# para resolver el problema de precedencia
\end{verbatim}
%

Con esta pequeña dificultada removida, la solución es ahora fácil:

\begin{verbatim}
my $sufijo = 'ack';
for ('J' .. 'N', 'Ou', 'P', 'Qu').flat -> $letra {
    say $letra ~ $sufijo;
}
\end{verbatim}
%

Aquí nuevamente, podríamos hacer el código un poco más conciso 
con la sintaxis sufija de {\tt for} y la variable tópica \verb|$_|:
\index{statement!for}
\index{topical variable}

\begin{verbatim}
my $sufijo = 'ack';
say "$_$sufijo" for flat 'J' .. 'N', 'Ou', 'P', 'Qu';
\end{verbatim}
%

Aquí introducimos otra manera simple y común de concatenar
dos cadenas de texto: simplemente inserta las dos variables
una después de la otra dentro de comillas dobles y permite
que la interpolación de variables haga su trabajo.
\index{variable!interpolation}


\subsection{Ejercicio en la Sección~\ref{stringtraversal}: Contando las Letras de una Cadena de Texto (p.~\pageref{stringtraversal})}
\label{sol_count_letters}
\index{string traversal}

Esta subrutina cuenta el número de ocurrencias de una letra específica
dentro de una palabra (o cualquier otra cadena de texto):

\begin{verbatim}
sub contar( Str $palabra, Str $letra ) {
    my $cuenta = 0;
    for $palabra.comb -> $letra {
        $cuenta++ if $letra eq 'a';
    }
    return $cuenta;   
}
say contar "banana", "a";   # -> 3
\end{verbatim}
%

La solución al Ejercicio~\ref{count_a} 
(p.~\pageref{sol_count_a}) más abajo usa las 
funciones {\tt index} y {\tt substr} para 
realizar la misma cuenta.


\subsection{Sección~\ref{regex_loop}: Simulando un Regex con un Bloque (p.~\pageref{regex_loop})}
\label{sol_regex_loop}

El objetivo es encontrar en una cadena de texto cualquier letra
que es inmediatamente seguida por la letra ``l`` y seguida
por la letra ``w``.

Si intentas hacer la búsqueda especificada con las técnicas
que hemos visto hasta ahora, encontrarás que hay un número 
de casos especiales que hacen la tarea complicada.

Esto es un solución posible:

\begin{verbatim}
sub recorrer( Str $palabra, Str $inicio_letra, Str $final_letra ) {
    my $encontrada_inicio = False;
    my $captura_siguiente = False;
    my $letra_objetivo;
    for 0..$palabra.chars - 1 -> $idx {
        my $letra = substr $palabra, $idx, 1;
        next unless $letra eq $inicio_letra or $encontrada_inicio;
        if ($captura_siguiente) {
            $letra_objetivo = $letra;
            $captura_siguiente = False;
            next;
        }
        if $letra eq $inicio_letra and not $encontrada_inicio {
            $encontrada_inicio = True;
            $captura_siguiente = True;
            next;
        }
        # si llegamos hasta aquí, hemos encontrado una letra objetivo
        # candidata
        if $letra eq $final_letra {
            return $letra_objetivo
        } else {
            # coincidencia errónea, iniciemos nuevamente, 
            # necesitamos retroceder
            if $letra_objetivo eq $inicio_letra {
                 $letra_objetivo = $letra;
                 $captura_siguiente = False;
            } elsif $letra eq $inicio_letra {
                 $captura_siguiente = True;
            } else {
               $captura_siguiente = False;
               $encontrada_inicio = False;
            } 
        } 
    }
    return;  # ¡no encontrada!
}          

for <s b   l w   l o   s m   y l   a z> -> $ini, $fin {
    say "$ini $fin: ", recorrer "yellow submarine", $ini, $fin;  
}
\end{verbatim}

Como puedes ver, esto es algo un poco complicado porque los
casos especiales que necesitamos manejar. Compara esto con un 
regex de una sola línea que hace lo mismo:
\index{regex}

\begin{verbatim}
say ~$0 if "yellow submarine" ~~ /l(.)w/;
\end{verbatim}

Para ser honesto, no he elegido la forma más simple de hacerlo.

Es más mucho más fácil de pasar a través de cada letra de la
cadena de texto excepto la primera y la última, para cada letra
como tal, para chequear cuales son la letra previa y la letra siguiente.
Después simplemente necesitas devolver la letra actual si la
previa y la siguiente coincide con las condiciones:

\begin{verbatim}
sub recorrer( Str $palabra, Str $inicio_letra, Str $final_letra ) {
    my $encontrada_inicio = False;
	my $captura_siguiente = False;
	my $letra_objetivo;
    for 1..$palabra.chars - 2 -> $idx {
        if $inicio_letra eq substr $palabra, $idx - 1, 1
          and $final_letra eq substr $palabra, $idx + 1, 1 {
            return substr $palabra, $idx, 1;
        }
     }
    return;  # no encontrada!
}          

for <s b   l w   l o   s m   y l   a z> -> $ini, $fin {
    say "$ini $fin: ", recorrer "yellow submarine", $ini, $fin;  
}
\end{verbatim}

En las pruebas de casos al final , uso bucle {\tt for} 
con una construcción de bloque puntiagudo en la cual elijo
\emph{dos} de los artículos en la lista cada vez a través del bucle.
Los números de espacios entre los artículos de la lista 
son técnicamente inservibles e irrelevante a la manera en la 
cual la construcción sintáctica funciona; ellos solo sirven para
ayudar al lector a ver mejor cómo las letras serán agrupadas en 
el proceso.
\index{for loop}
\index{pointy block}
\index{pointy block!using several items}

Esto muestra:
\begin{verbatim}
s b: u
l w: o
l o: l
s m: Nil
y l: e
a z: Nil
\end{verbatim}

Esto es mucho más simple que el atento anterior, pero 
sería aún un poco difícil de cambiar algo, por ejemplo
agregar una nueva condición: la estructura del código 
necesitaría ser modificado un poco.

Aún comparada con esta solución más simple, la solución de regex
realmente brillas en orden de magnitud.

\subsection{Ejercicios en la Subsección~\ref{regex_exercises}: Ejercicios de Regexes (p.~\pageref{regex_exercises})}
\label{sol_regex_exercises}
\index{regex}

Como es usualmente el caso en Perl, y aún más con los regexes, 
hay más de una manera de hacer algo (TIMTOWTDI). La mayoría de los
ejercicios sugeridos aquí tienen más de una solución (y algunas
veces muchas).
\index{TIMTOWTDI}
\index{there is more than one way to do it}

Con los regexes, también tienes que pensar cuidadosamente acerca
de los datos de entrada para saber lo debe coincidir y lo
que debe ser rechazado.

\subsubsection{Diez dígitos en una fila}

Aquí presentamos una manera de encontrar 10~dígitos consecutivos
en una cadena de texto:

\begin{verbatim}
my $cadena = "567867 8778689 6765432 0123456789 897898";
say ~$0 if $cadena ~~ /(\d ** 10)/; # -> 0123456789
\end{verbatim}

Simplemente estamos usando la categoría de caracteres \verb|\d|
(dígito) junto con un cuantificador que especifica esta clase 10~veces.
\index{character class}

Nota que hemos usado los paréntesis de captura aquí para popular
el número que coincidió en \verb|$0|. Podríamos también omitir los 
paréntesis y extraer el número desde el objeto de coincidencia:
\index{regex!capture}


\begin{verbatim}
my $cadena = "567867 8778689 6765432 0123456789 897898";
say ~$/ if $cadena ~~ /\d ** 10/; # -> 0123456789
\end{verbatim}
%

La solución anterior solo haría una coincidencia con una
secuencia de 10-dígitos dentro de una secuencia más larga, 
lo cual puede o no puede ser lo que necesitas. Por ejemplo:

\begin{verbatim}
my $cadena = "567867 87786896765432 0123456789 897898";
say ~$0 if $cadena ~~ /(\d ** 10)/; # -> 8778689676
\end{verbatim}

Si quieres coincidir más precisamente con una secuencia de
10-dígitos (no más de 10), necesitas especificar lo quieres
tener alrededor de la coincidencia. Por ejemplo, para coincidir
solo con la secuencia de 10-dígitos más arriba, podrías
usar la categoría de caracteres de no dígitos:

\begin{verbatim}
my $cadena = "567867 87786896765432 0123456789 897898";
say ~$0 if $cadena ~~ /\D (\d ** 10) \D/; # -> 0123456789
\end{verbatim}

Pero esto coincidiría con una secuencia de 10-dígitos al 
inicio o al final de la cadena de texto:

\begin{verbatim}
my $cadena = "5678670001 87786896765432 0123456789 897898";
say ~$0 if $cadena ~~ /\D (\d ** 10) \D/; # -> 0123456789
\end{verbatim}

Un mejor solución podría usar anclas de borde de palabra:
\index{anchor!word boundary}
\index{anchor!left word boundary}
\index{anchor!right word boundary}
\index{anchor!start of word}
\index{anchor!end of word}

\begin{verbatim}
my $cadena = "5678670001 87786896765432 0123456789 897898";
say ~$0 if $cadena ~~ /<< (\d ** 10) >>/; # -> 5678670001
\end{verbatim}

Un poco de reflexión puede algunas veces ser necesario para
asegurar que hacemos una coincidencia con lo que realmente queremos.

\subsubsection{Un número octal}

Esta es una solución posible para encontrar un número octal (i.e., 
un número compuesto solamente de  dígitos del 0 al 7) en una cadena
de testo:

\begin{verbatim}
my $cadena = "567867 8778689 6765432 0123456789 897898";
say ~$0 if $cadena ~~ /\D (<[0..7]>+) \D/; # -> 6765432
\end{verbatim}

\index{character class}
La categoría de caracteres es \verb|<[0..7]>| para los dígitos 
entre 0 y 7. El cuantificador \verb|+| significa: tantas categorías
de caracteres como sea posible. Y los \verb|\D| (no dígito) se encuentran
ahí para prevenir el regex de coincidir parte de un número más
largo que tiene dígitos que no forman parte de un número octal (por 
ejemplo coincidir 567 en el primer número). Dependiendo del
requerimiento exacto, usar las anclas de borde de palabra como 
en la solución del ejercicio previo sería mejor.
\index{quantifier}

\subsubsection{Primera palabra al inicio de la cadena de texto}

Para encontrar la primera palabra en una cadena de texto, podemos
solo buscar la primera secuencia de caracteres de palabra (
caracteres que pertenecen a la categoría de caracteres \verb|\w|)
en la cadena de texto:
\index{character class}

\begin{verbatim}
my $cadena = "The greatest thing you'll ever learn " ~
             "is just to love and be loved in return. " ~
             "(Nature Boy, Nat King Cole)";
say ~$0 if $cadena ~~ /(\w +)/;  # -> The
\end{verbatim}


\subsubsection{Primera palabra que comienza con una ``a''}

Esta es una manera de encontrar la primera palabra que comienza
con la letra ``a`` en una sentencia:

\begin{verbatim}
my $cadena = "Four scores and seven years ago our fathers ...";
say ~$0 if $cadena ~~ /\W (a \w+)/;  # -> and
\end{verbatim}

\subsubsection{Primera palabra que comienza con una vocal minúscula}

Para asegurarnos que la coincidencia no comience con una vocal 
en el medio de una palabra, podríamos comenzar el patrón con un
\verb|\W| (carácter de no palabra) o, mejor, con un borde izquierdo
de palabra \verb|<<|:
\index{anchor!left word boundary}

\begin{verbatim}
my $cadena = "Democracy is the worst form of government, " ~
             "except for all the others. (Churchill)";
say ~$0 if $cadena ~~ /<< (<[aeiouy]> \w*)/;  # -> is
\end{verbatim}

Aquí usamos un cuantificador \verb|*| (en lugar de \verb|+|) 
porque solo una palabra que contiene una vocal es eligible
como una palabra que comienza con una vocal.
\index{quantifier}

\subsubsection{Un número telefónico}

Para un número de 10-dígitos que comienza con ``06'' o ``07'', la
solución más fácil es probablemente usar una categoría de caracteres
\verb|<[67]>|:
\index{character class}

\begin{verbatim}
my $cadena = "567867 8778689 0123456789 0723456789 3644";
say ~$0 if $cadena ~~ /(0<[67]>\d ** 8)/;  # -> 0723456789
\end{verbatim}

\subsubsection{Primera palabra que comienza con una vocal (minúscula o mayúscula)}

Podemos simplemente ignorar la distinción entre 
mayúscula y minúscula para la palabra completa:
\index{adverb!:ignorecase}
\begin{verbatim}
my $cadena = " Ask not what your country can do for you — " ~
             " ask what you can do for your country. (JFK)";
say ~$0 if $cadena ~~ /:i << (<[aeiouy]> \w*)/;  # -> Ask
\end{verbatim}

\subsubsection{Letras repetidas}

Podemos capturar cualquier letra y chequear si la siguiente es
la misma como la capturada:
\index{capture}

\begin{verbatim}
say ~$0 if 'appeal' ~~ /((\w)$0)/;          # -> pp
\end{verbatim}

Para capturar el segundo grupo de letras repetidas:

\begin{verbatim}
say ~$1 if 'coffee' ~~ /(\w)$0.*((\w)$0)/;  # -> ee
\end{verbatim}

Y para el tercer grupo:

\begin{verbatim}
say ~$2 if 'Mississippi' ~~ /(\w)$0.*((\w)$0).*((\w)$0)/;  # -> pp
\end{verbatim}

o posiblemente:
\begin{verbatim}
say ~$2 if 'Mississippi' ~~ /(\w)$0.*(\w)$1.*((\w)$0)/;    # -> pp
\end{verbatim}


\subsection{Ejercicio en la Sección~\ref{isreverse}: Subrutina {\tt es-inversa} (p.~\pageref{isreverse})}
\label{sol_isreverse}
\index{is-reverse}

El segundo error en la subrutina {\tt es-inversa} está localizado
en esta línea:
\index{bug}

\begin{verbatim}
    while $j > 0 {
\end{verbatim}
%

El índice {\tt \$j} debería ser capaz de repetir hasta llegar
a 0 (inclusivo) si queremos comparar la primera letra de
{\tt \$palabra2} con la última letra de {\tt \$palabra1}.

La versión corregida de la subrutina {\tt es-inversa} 
podría ser:

\begin{verbatim}
sub es-inversa( Str $palabra1, Str $palabra2 ) {
    return False if $palabra1.chars != $palabra2.chars;
    
    my $i = 0;
    my $j = $palabra2.chars - 1;

    while $j >= 0 {
        return False if substr($palabra1, $i, 1) ne substr($palabra2, $j, 1);
        $i++; $j--;
    }
    return True;
}
\end{verbatim}
%

\subsection{Ejercicio~\ref{count_a}: Contando Letras (p.~\pageref{count_a})}
\label{sol_count_a}
\index{count letters}

Contar el número de letras ``a'' en una palabra con la función 
{\tt index} implica buscar la primera ``a`` desde el inicio de la
cadena de texto, después buscar por la siguiente desde la posición
inmediatamente después, y continuar así hasta que no se encuentren
más letras ``a''.

\index{infinite loop}
\index{loop!infinite}
\index{last statement}
\index{index function}

Aquí, creamos un bucle infinito desde el cual nos liberamos con
la sentencia {\tt last} cuando {\tt index} ya no encuentra una ``a``.
El contador {\tt \$cuenta} es incrementado cada vez que una ``a``
es encontrada, y la {\tt \$idx} mantiene un registro de la
posición actual dentro de la cadena de texto:

\begin{verbatim}
sub contar_a {
    my $palabra = "banana";
    my $cuenta = 0;
    my $idx = 0;
    while True {
       $idx = index $palabra, 'a', $idx;
       last unless $idx.defined;
       $idx++;
       $cuenta++;
    }
    return $cuenta;
}
say contar_a();  # -> 3
\end{verbatim}

Si la adaptamos para cualquier cadena de texto y cualquier letra
es solo una cuestión de pasar los argumentos correctos a la subrutina
y usar dentro de la subrutina sus parámetros en lugar de valores literales:

\begin{verbatim}
sub contar_indice( Str $palabra, Str $letra ) {
    my $cuenta = 0;
    my $idx = 0;
    while True {
       $idx = index $palabra, $letra, $idx;
       last unless $idx.defined;
       $idx++;
       $cuenta++;
    }
    return $cuenta;
}
say contar_indice "When in the Course of human events...", "n"; # 4
\end{verbatim}

Contar una letra dada en una palabra dada con la función {\tt substr} 
es algo directo: solo necesitamos pasar a través de cada letra de
la palabra e incrementar un contador cuando sea necesario:
\index{substr}

\begin{verbatim}
sub contar_substr( Str $palabra, Str $letra ) {
    my $cuenta = 0;
    for 0..$palabra.chars - 1 {
        $cuenta++ if $letra eq substr $palabra, $_, 1;
    }
    return $cuenta;
}
say contar_substr "I have a dream that one day...", "a"; # -> 5
\end{verbatim}

\subsection{Ejercicio~\ref{islower}: Letras Minúsculas (p.~\pageref{islower})}
\label{sol_islower}
\index{count letters}

Solo las subrutinas \verb|cualquier_minúscula5| y \verb|cualquier_minúscula7|
chequean correctamente si la cadena de entrada contiene por lo menos 
una letra minúscula.

Si no lo determinaste por ti mismo, trata realmente de encontrar
por ti mismo los errores en las otras antes de proseguir; deberías
ser capaz de encontrar los errores en las otras subrutinas (excepto 
quizás \verb|cualquier_minúscula4|, lo cual es sin duda 
un poco engañoso).

La subrutinas \verb|cualquier_minúscula5| y \verb|cualquier_minúscula7| 
realizan la búsqueda como sigue:

\begin{itemize} 
\item \verb|cualquier_minúscula5| asigna {\tt False} a {\tt \$flag}
antes del bucle, lo cambia a {\tt True} si cualquier carácter 
en la cadena de texto está en minúscula, y devuelve {\tt \$flag} 
después de completar el bucle.

\item  \verb|cualquier_minúscula5| es también correcta (y probablemente
un poco mejor que \verb|cualquier_minúscula5|). Devuelve {\tt True} 
si cualquier carácter está en minúscula y devuelve {\tt False} solo
si se puede llegar al final del bucle.
\end{itemize}

Las otras subrutinas tienen los errores siguientes (algunas tienen
varios errores; vamos a mencionar por lo menos uno de ellos):
\begin{itemize} 

\item \verb|cualquier_minúscula1| solo chequea el primer
carácter de su argumento y sale del bucle inmediatamente después.

\item \verb|cualquier_minúscula2| llama la subrutina {\tt es-minúscula} 
sobre la cadena de texto {\tt "char"}, no sobre la variable 
{\tt \$char} (tiene el mismo defecto que \verb|cualquier_minúscula1|).

\item \verb|cualquier_minúscula3| devuelve {\tt True} o {\tt False} 
dependiendo solo en el último carácter de la cadena de texto de
entrada.

\item \verb|cualquier_minúscula4| sufre del problema de la precedencia
de operadores: la asignación \verb|$bandera = $bandera ...| se ejecuta
antes que el operador de relación {\tt or} sea ejecutado, así que la
última parte no tiene efecto.
Cambiando la línea defectuosa:
\index{precedence}
\index{operator!precedence}
\begin{verbatim}
$bandera = $bandera || es-minúscula $char;   # operador de precedencia más alta
# o
$bandera = ($bandera or es-minúscula $char); # los paréntesis anulan la precedencia
\end{verbatim}
solucionaría el problema.

\item \verb|cualquier_minúscula6| es casi correcta en términos de su algoritmo.
pero devuelve las cadenas {\tt "True"} o {\tt "False"} en lugar de los valores
Booleanos {\tt True} o {\tt False}.

\item  \verb|cualquier_minúscula8| devuelve {\tt False} si el carácter no está
en minúscula.

\item  \verb|cualquier_minúscula9| también devuelve {\tt False} 
si cualquier carácter no está en minúscula.

\end{itemize}

El siguiente es un ejemplo del bucle que podrías escribir para probar
cada subrutina, cada una con tres cadenas de texto de entrada:
\begin{verbatim}
for <FOO bar Baz> -> $str {
    say "1. $str: ", cualquier_minúscula1 $str;
    say "2. $str: ", cualquier_minúscula2 $str;
    say "3. $str: ", cualquier_minúscula3 $str;
    say "4. $str: ", cualquier_minúscula4 $str;
    say "5. $str: ", cualquier_minúscula5 $str;
    say "6. $str: ", cualquier_minúscula6 $str;
    say "7. $str: ", cualquier_minúscula7 $str;
    say "8. $str: ", cualquier_minúscula8 $str;
    say "9. $str: ", cualquier_minúscula9 $str;
}
\end{verbatim}

Sería posible reemplazar las nueve sentencias de impresión 
con un bucle simple, pero requiere usar características que
no hemos estudiado todavía.

En otros capítulos verás maneras de organizar pruebas de casos, 
por ejemplo en la Sección~\ref{test_module} (p.~\pageref{test_module}).
\index{test module}

\subsection{Ejercicio~\ref{rotate}: Cifrado César (p.~\pageref{rotate})}

\label{sol_rotate}
\index{letter rotation}
\index{rotation, letter}
\index{Caesar cipher}
\index{rot13}

Podemos implementar un cifrado de rotación de una letra:
\index{case!lower}
\index{case!upper}
\index{lower case}
\index{upper case}

\begin{verbatim}
sub rotar-una-letra( Str $letra, Int $despl ) {
    my $cota-sup = 'Z'.ord;        # útima letra mayúscula
    my $cota-inf  = 'z'.ord;       # útima letra minúscula

    my $ord-rotada = $letra.ord + $despl;
    if $letra ~~ /<[a..z]>/ {                # minúscula
        $ord-rotada -= 26 if $ord-rotada > $cota-inf;
    } elsif $letra ~~ /<[A..Z]>/ {           # mayúscula
        $ord-rotada -= 26 if $ord-rotada > $cota-sup;
    } else {
        return $letra;
    }
    return $ord-rotada.chr;
}

sub rotar-palabra( Str $palabra, Int $despl is copy ) {
    $despl = $despl % 26;
    $despl = 26 + $despl if $despl < 0;
    my $palabra-rotada = "";
    for 0..$palabra.chars - 1 {
        $palabra-rotada ~= rotar-una-letra(
                            substr($palabra, $_, 1),
                            $despl
                           );
    }
    return $palabra-rotada;
}

sub rot13( Str $palabra ) {
    return rotar-palabra $palabra, 13;
} 

say rotar-palabra "ABDCabcd", 25;
say rotar-palabra "cheer", 7;
say rotar-palabra "melon", -10;

say rot13("Fbzr cebsnavgl");
\end{verbatim}

Si estás interesado en decodificar solo ROT13, el operador
de transliteración {\tt tr} puede ofrecer un código mucho
más corto. Por ejemplo,{\tt tr/a..m/n..z/} transcribirá
todas las letras en el rango {\tt a..m} en sus equivalentes
respectivos en el rango {\tt n..z}.
\index{tr operator}
\index{operator!tr}
\index{one-liner mode}

Podemos escribir un ROT13 en un one-liner de Perl (ver Sección~\ref{one-liner mode}):
\index{one-liner mode}
\label{rot13_oneliner}

\begin{verbatim}
$ perl6 -e 'my $w = "foobar"; $w ~~ tr/a..mn..z/n..za..m/; say $w;'
sbbone

$ perl6 -e 'my $w = "sbbone"; $w ~~ tr/a..mn..z/n..za..m/; say $w;"
foobar
\end{verbatim}

Es muy fácil agregar rango para las letras mayúsculas. Podrías hacerlo como
un ejercicio adicional.


%\section{Ejercicios del Capítulo~8: Juego de Palabras}
\section{Ejercicios del Capítulo~\ref{wordplay}: Juego de Palabras}

\subsection{Ejercicio~\ref{cartalk}: Letras Dobles Consecutivas (p.~\pageref{cartalk})}
\label{sol_cartalk}
\index{Car Talk}

Con la técnica de repetición usada en el Capítulo~\ref{wordplay}, 
podríamos escribir esto:

\begin{verbatim}
sub es_doble_triple( Str $palabra ) {
    # Examina si una palabra contiene tres pares de letras
    # consecutivas
    my $i = 0;
    my $cuenta = 0;
    while $i < $palabra.chars - 1 {
        if substr($palabra, $i, 1) eq substr($palabra, $i + 1, 1) {
            $cuenta++;
            return True if $cuenta == 3;
            $i += 2;
        } else {
            $cuenta = 0;
            $i++;
        }
    }
    return False;
}

for 'lemario.txt'.IO.lines -> $palabra {
    say $palabra if es_doble_triple $palabra;
}
\end{verbatim}
%

Sin embargo, este es un caso típico donde los regexes 
pueden resultar más eficiente que un bucle (en términos de 
eficiencia de código, i.e., como un aproximación, cuántas líneas
de código son necesarias para realizar una tarea dada).
\index{regex}

Discutimos en Capítulo~\ref{strings} que las capturas de 
regex poblan las variables especiales \verb|$0|, \verb|$1|, \verb|$2|, etc.
Un patrón de regex que coincide con cualquier letra repetida
podría por lo tanto ser \verb|/(.) $0/|, donde el carácter encontrado
por \verb|$0| es el mismo carácter encontrado por el punto.
\index{capture} 

Similarmente, un patrón de regex que coincide con tres pares de letras
dobles en una fila podría implementarse así:
\begin{verbatim}
say ~$/ if "abbccdde" ~~ /(.)$0 (.)$1 (.)$2/; # -> bbccdd 
\end{verbatim}

Con esto, el programa para encontrar las palabras con tres pares
de letras dobles en el archivo {\emph words.txt} puede escribirse
en tres líneas de código:

\begin{verbatim}
for 'lemario.txt'.IO.lines -> $palabra {
    say $palabra if $palabra ~~ /(.) $0 (.) $1 (.) $2/;
}
\end{verbatim}
%

\begin{description}


\item[{\bf Nota del traductor:}] Aunque el archivo {\em lemario.txt}
tiene alrededor de 88, 000 palabras, fui incapaz de encontrar
una palabra (en español) que contenga tres pares de letras consecutivas.
No obstante, hay palabras que contienen dos pares de letras consecutivas
como \emph{toffee}, \emph{hemorro}, etc. 

Debido a esto, 
el siguiente ejemplo usa el archivo {\em words.txt} el cual es 
utilizado en {\em Think Perl 6}\footnote{
Puedes encontrar el archivo \emph{words.txt} aquí: 

https://raw.githubusercontent.com/LaurentRosenfeld/thinkperl6/master/Supplementary/words.txt
}.
\end{description}

Si usamos el archivo {\em words.txt}, ambos programas encuentran
cuatro palabras, las cuales son variaciones de ``bookkeeper'' y
``bookkeeping''.

La versión de regex es tan simple que puedes escribirla directamente
en la línea de comando del sistema operativo como un one-liner:
(see Section~\ref{one-liner mode}):
\index{one-liner mode}

\begin{verbatim}
$ perl6 -ne '.say if /(.) $0 (.) $1 (.) $2/' words.txt
bookkeeper
bookkeepers
bookkeeping
bookkeepings
\end{verbatim}

\subsection{Ejercicio~\ref{cartalk2}: Palíndromos en los Odómetros (p.~\pageref{cartalk2})}
\label{sol_cartalk2}
\index{Car Talk}

La siguiente es un posible programa para solucionar
el acertijo sobre el odómetro con palíndromos:
\index{palindrome}
\index{odometer}

\begin{verbatim}
sub es-palindromo( $num, $ini, $long ) {
    # chequea si la sub-cadena relevante es un palíndromo
    my $subcad = substr $num, $ini, $long;
    return $subcad eq flip $subcad;
}
    
sub chequear( $num ) {
    # Chequea si el número entero tiene las
    # propiedades indicadas
    return (es-palindromo($num, 2, 4) and
        es-palindromo($num + 1, 1, 5) and
        es-palindromo($num + 2, 1, 4) and
        es-palindromo($num + 3, 0, 6));
}

say 'Las siguientes son las lecturas de odómetro posibles:';
for 1e5..1e6 - 4 -> $número {
    say $número if chequear $número;
}
\end{verbatim}

Otra forma de hacerlo sería con el uso de regexes para 
encontrar si tenemos palíndromos:

\begin{verbatim}
sub chequear( $num ) {
    # Chequea si el número entero tiene las
	# propiedades indicadas
    $num ~~ /^..(.)(.)$1$0/ and 
    $num + 1 ~~ /^.(.)(.).$1$0/ and 
    $num + 2 ~~ /^.(.)(.)$1$0/ and 
    $num + 3 ~~ /^(.)(.)(.)$2$1$0/;
}

say 'Las siguientes son las lecturas de odómetro posibles:';
for 1e5..1e6 - 4 -> $número {
	say $número if chequear $número;
}
\end{verbatim}

Este código es más corto, pero también más lento: toma casi el 
doble para ejecutarse en mi computadora. Así que hay un compromiso:
La primera manera, la cual es más rápida, es probablemente mejor
si necesitas ejecutar tu programa muchas veces o usualmente, pero puedes
preferir la segunda versión si esto es una computación que haces
raramente. La decisión es tuya.


\subsection{Ejercicio~\ref{cartalk3}: Palíndromos en las Edades (p.~\pageref{cartalk3})}
\label{sol_cartalk3}
\index{palindrome}
\index{Car Talk}

El siguiente programa itera sobre las posibles diferencias de
edades entre 15 y 75 y, por cada edad, calcula todas las 
posibilidades de palíndromos.

\begin{verbatim}
say 'diferencias #instancias';
chequear_dif();
say 'hija  madre';
instancia_num(18, True);

sub son_inversas( Int $i, Int $j ) {
    # $j (edad de la madre) tendrá siempre dos dígitos
    return $j eq flip sprintf '%02d', $i; # formatea $i con 2 dígitos
}

sub instancia_num( Int $dif, Bool $bandera ) {
    # computa y cuenta todas las posibilidades 
    # para una diferencia de edad
    my $hija = 0;
    my $cuenta = 0;
    while True {
        my $madre = $hija + $dif;
        if son_inversas($hija, $madre) or 
		    son_inversas($hija, $madre+1) {
            $cuenta++;
            printf "%02d\t%d\n", $hija, $madre if $bandera;
        }
        last if $madre > 99;
        $hija++;
    }
    return $cuenta;
}

sub chequear_dif() {
    # enumera todas las posibles diferencias de edade
    for 15..75 -> $dif {
        my $nb_casos = instancia_num $dif, False;
        say "$dif   $nb_casos" if $nb_casos > 0;
    }
}
\end{verbatim}

La sentencia {\tt while True} crea un bucle infinito. El bucle 
es terminado por la sentencia de flujo de control, {\tt last}, 
cuando la edad de la madre excede 99. Veremos en la Sección~\ref{C-style loop} 
una manera más idiomática de construir un bucle infinito, pero 
esto es suficiente por ahora.
\index{infinite loop}
\index{loop!infinite}
\index{last statement}
\index{idiomatic}

La función {\tt sprintf} usada en este ejercicio transforma cualquier 
número menor que 10 en una cadena de texto de dos dígitos con
un 0 en frente. Su sintaxis es similar a aquella de la función {\tt printf}
que vimos anteriormente. La diferencia es que solo crea una cadena de
texto nueva, pero no la imprime.
\index{sprintf function}

Usar el método \verb'.fmt' en lugar de la función {\tt sprintf}, 
como la sintaxis de método de {\tt flip}, puede hacer que la
subrutina \verb|son_inversas| luzca algo mejor:
\index{fmt method}
\index{flip function}

\begin{verbatim}
sub son_inversas( Int $i, Int $j ) {
    return $j eq $i.fmt('%02d').flip; # formatea $i con 2 dígitos
}
\end{verbatim}


%\section{Exercises of Chapter~\ref{arrays} (Arrays and Lists)}
\section{Ejercicios del Capítulo~\ref{arrays} (Arrays y Listas)}

\subsection{Ejercicio en la Sección~\ref{stacks_queues}: Implementando una Cola (Queue) (p.~\pageref{exercise_queue})}
\label{sol_exercise_queue}

\index{queue}
Esta es una implementación algo simple de una cola (o \emph{queue})
que usa un array y las funciones {\tt unshift} and {\tt pop}:
\index{enqueue}
\index{dequeue}
\index{unshift function}
\index{pop function}

\begin{verbatim}
# Añadir un elemento a la línea 
# (i.e., última persona en unirse a la línea)
sub encolar( @cola, $nuevo_artículo ) {
    unshift @cola, $nuevo_artículo;
}

# Remover un elemento de la línea 
#(i.e, persona en frente de la línea)
sub desencolar( @cola ) {
    my $artículo = pop @cola;
    return $artículo;
}
my @linea = 1, 2, 3, 4, 5;
encolar @linea, 6;
say @linea;
say desencolar @linea for 1..3;
\end{verbatim}

\subsubsection{Mejorando la cola con signaturas de subrutinas}

Intentemos mejorar nuestra cola y hacerla un poco más robusta.

Primero, queremos añadir algunas signaturas a nuestras subrutinas. 
Podríamos ser tentados a escribir algo como esto:
\index{subroutine signature}
\index{signature}

\begin{verbatim}
sub encolar( Array @cola, $nuevo_artículo ) {
	unshift @cola, $nuevo_artículo;
}
\end{verbatim}

Pero eso no funciona porque esencialmente eso le dice a Perl
que el parámetro \verb|@cola| es un array de arrays. Lo que necesitamos
es la siguiente sintaxis de signatura:
\index{signature}

\begin{verbatim}
sub encolar( @cola where Array, $nuevo_artículo ) {
	unshift @cola, $nuevo_artículo;
}

sub desencolar( @cola where Array ) {
	my $artículo = pop @cola;
	return $artículo;
}	
\end{verbatim}

Probablemente no queremos ningún tipo de signatura para el
parámetro \verb|$nuevo_artículo| de {\tt desencolar}, porque 
queremos que nuestra cola sea capaz de operar con cualquier 
tipo de datos para que sea tan genérica como sea
posible. Pero, al igual que lo dijimos sobre pilas (Sección~\ref{stacks_queues}), 
podríamos querer añadir varios artículos a la estructura de
datos de una sola vez.

\subsubsection{Parámetros slurpy (o variádicos)}

\label{slurpy_params}
\index{slurpy parameters}
\index{variadic parameters}
\index{signature}
Hay varias maneras de insertar varios elementos a la cola,
pero la más simple es probablemente usar una signatura
con el parámetro \emph{slurpy} (o parámetro \emph{variádico}):
un parámetro array o hash se marca como variádico con un asterisco
al frente del mismo, lo cual significa que puede atarse a un
número arbitrario de argumentos (cero o más). Estos parámetros
se llaman "slurpy" porque sorbe los parámetros restantes
a una función, al igual que un persona sorbiendo un helado.
Esto también significa que un parámetro variádico de posición
puede ser solamente el último en la signatura:
\index{enqueue}
\index{dequeue}

\begin{verbatim}
sub encolar( @cola where Array, *@nuevos_artículos) {
    unshift @cola, $_ for @nuevos_artículos;
    # or: unshift @queue, |@new_items;
}
sub desencolar( @cola where Array ) {
    my $artículo = pop @cola;
    return $artículo;
}
my @linea = 4, 5, 6, 7, 8;
encolar @linea, 3, 2, 1;
say @linea;
say desencolar @linea for 1..3;
\end{verbatim}

Esto mostrará:

\begin{verbatim}
[1 2 3 4 5 6 7 8]
8
7
6
\end{verbatim}

Ver también la sección~\ref{slurpy_parameters} para más detalles
sobre los parámetros variádicos.

Nota que, para una subrutina \verb|encolar|, no podemos simplemente
escribir:
\begin{verbatim}
sub encolar( @cola where Array, *@nuevos_artículos ) {
    unshift @cola, @nuevos_artículos;
}
\end{verbatim}
%
porque, cuando se provee un array como un segundo argumento,
{\tt unshift} inserta los nuevos artículos como una sub-lista.
Esta pequeña dificultad se puede solucionar con el uso de 
un bucle \verb|for| o con el uso del operador ``|`` el cual aplana
la lista. 
\index{list flattening}

Otra posibilidad es usar la función integrada {\tt prepend} 
en lugar de {\tt unshift}, dado que añade los elementos 
aplanados de una array al principio de la cola:
\index{prepend function}

\begin{verbatim}
sub encolar( @cola where Array, *@nuevos_artículos ) {
	prepend @cola, @nuevos_artículos;
}
\end{verbatim}

\subsubsection{Un cola usando {\tt shift} y {\tt append}}

\index{append function}
\index{shift function}
\index{unshift function}
\index{push function}
\index{list flattening}
El orden en el cual los argumentos son pasados es un
poco contradictorio. De igual manera, podríamos preferir 
no tener que usar un bucle para añadir los elementos nuevos.
Es un poco más fácil usar la combinación {\tt push} y {\tt shift},
y reemplazar {\tt push} con {\tt append}, que hace casi lo
mismo que {\tt push} pero aplana la lista al igual que 
{\tt prepend} que vimos anteriormente:

\begin{verbatim}
sub encolar( @cola where Array, *@nuevos_artículos ) {
	append @cola, @nuevos_artículos;
}

sub desencolar( @cola where Array ) {
	my $artículo = shift @cola;
	return $artículo;
}

my @linea = 1, 2, 3, 4;
encolar @linea, 6, 7, 8;
say @linea;
say desencolar @linea for 1..3;
\end{verbatim}

Esto muestra:

\begin{verbatim}
[1 2 3 4 6 7 8]
1
2
3
\end{verbatim}

\subsubsection{Excepciones}

\index{exception}
Finalmente, una debilidad adicional necesita arreglarse: 
¿Qué pasa si la cola está vacía cuando intentamos {\tt desencolar}
un artículo? Levantar una excepción o abortar el programa
podría ser lo que necesitamos. Podríamos también decidir
devolver un valor indefinido y dejar que la subrutina
que hace la llamada haga lo necesario con el valor devuelto:
\index{queue}
\index{enqueue}
\index{dequeue}

\begin{verbatim}

sub encolar( @cola where Array, *@nuevo_artículos ) {
	append @cola, @nuevo_artículos;
}

sub desencolar( @cola where Array ) {
	return unless @cola;
	my $artículo = shift @cola;
	return $artículo;
}

my @linea;
encolar @line, 1, 2, 3;
say @linea;
for 1..4 -> $cuenta {
    my $artic = desencolar @linea;
    if defined $artic {
        say $artic;
    } else {
        say "ERROR: La cola está vacía!";
    }
}
\end{verbatim}

Esto produce la siguiente salida:

\begin{verbatim}
[1 2 3]
1
2
3
ERROR: La cola está vacía!
\end{verbatim}

La subrutina {\tt desencolar} podría simplificarse
con el uso del operador ternario (ver Sección~\ref{ternary operator}) 
y devolver el valor {\tt Nil} si la lista está vacía:
\index{Nil}

\begin{verbatim}
sub desencolar( @cola where Array ) {
    @cola ?? @cola.shift !! Nil
}
\end{verbatim}


\index{stack}
\index{queue}
Como un ejercicio adicional, podrías aplicar los cambios 
que hemos hecho más arriba para el manejo de colas al 
ejemplo de código para las pilas (visto en la Sección~\ref{stack_code} 
en la p.~\pageref{stack_code}).
\index{stack}

\subsubsection{Encapsulando los datos}
\label{functional_queue}

Otro problema con nuestra implementación de las colas es 
que la cola \verb|@file| es totalmente accesible al desarrollador,
quien podría ser tentado a escudriñar el array directamente o
aún peor, modificarlo, sin usar las subrutinas {\tt encolar}
y {\tt desencolar} diseñadas para mantener la cola consistente.

\index{encapsulation}
\index{data hiding}
Podríamos querer prevenir eso y hacer imposible que el usuario
altere la cola o por lo contrario la acceda por otros medios
que no son las subrutinas adecuadas. Ocultar la información
sobre la implementación o al contrario hacerla inaccesible
por otros medios más que aquellos diseñados para ese propósito
es usualmente conocido como la {\tt encapsulación} de datos. 
Una manera común de lograr la encapsulación de datos es a través
de la programación orientada a objetos, la cual discutimos en
el Capítulo~\ref{objects}. 
\index{object}

\index{first-class object}
\index{object, first-class}
Podemos, sin embargo, obtener un resultado similar al combinar
el ámbito de variables y material que se discute en la Sección~\ref{first_class}
acerca de las subrutinas como objetos de primera clase.

Considera la siguiente implementación de una cola:
\begin{verbatim}
sub crear-fifo {
    my @cola;
    return (
        sub {return shift @cola;}, 
        sub ($artic) {push @cola, $artic;}
        ) ;
}
my ($fifo-obtener, $fifo-poner) = crear-fifo();
$fifo-poner($_) for 1..10;
print " ", $fifo-obtener() for 1..5; # ->  1 2 3 4 5
\end{verbatim}
%
\index{closure}
\index{scope}
\index{FIFO}
\index{anonymous subroutine}
La pieza central aquí es la subrutina {\tt crear-fifo}.
El array \verb|@cola| que almacena los datos tiene ámbito 
lexical en este subrutina y no puede accederse directamente
desde otra parte en el programa. {\tt crear-fifo} devuelve
dos subrutinas anónimas, una para desencolar artículos
y otra para encolarlos. Estas subrutinas son \emph{clausuras}
lexicales, lo cual significa que pueden acceder \verb|@cola|,
porque han sido definidas dentro de su ámbito, aún si son 
llamadas desde otro lugar. Aún cuando {\tt crear-fifo} ha
finalizado, esas subrutinas pueden todavía accederlo porque
ellas le ceden vida extra al array mientras las subrutinas
son accesibles.
\index{enqueue}
\index{dequeue}

\index{function factory}
El resto del código debería ser claro: cuando {\tt crear-fifo}
es llamada, crean las dos subrutinas anónimas que son almacenadas
en las variable \verb|$fifo-obtener| y \verb|$fifo-poner|. Una 
subrutina tal como {\tt crear-fifo} es algunas veces llamada
una \emph{función factoría} porque genera otras subrutinas al 
tiempo de ejecución. Finalmente, \verb|$fifo-poner| es llamada
diez veces para poblar la cola con los enteros del 1 al 10, y 
\verb|$fifo-obtener| es llamada cinco veces para obtener los 
primeros cinco artículos de la la cola. La cola está encapsulada:
aparte de usar las dos subrutinas anónimas, no hay manera de
acceder a sus datos 

Encolar una lista de artículos (en lugar de uno solo) 
y manejar las excepciones (tal como
intentar obtener un artículo de una cola vacía) se deja 
como un ejercicio al lector el .

\index{functional programming}
Las técnicas usadas aquí toman prestado de un paradigma de 
programación llamado \emph{programación funcional}, un
modelo de programación usado por lenguajes tales como Lisp,
Caml, Clojure, y Haskell. Este paradigma es bien diferente
a todo lo que hemos visto hasta ahora, tal como la programación
orientada a objetos es otro paradigma de programación diferente.
A medida que ganas experiencia como un programador, deberías
hacer un atento en entender estos diferentes paradigmas, porque
ofrecen maneras diferentes de hacer las cosas, y tienen ventajas 
específicas para tipos específicos de problemas. Saberlos todos
te da mucho más poder expresivo. Una de las cosas maravillosas de
Perl~6 es que te ofrece una herramienta moderna y poderosa 
para usar cada uno de estos paradigmas de programación.
Capítulo~\ref{functional_programming} es sobre la programación
funcional. Mientras tanto, asegúrate de leer la Subsección~\ref{array_functional_programming}
en el capítulo sobre arrays y listas.

\subsection{Ejercicio de la Sección~\ref{modify_array}: Otras Maneras de Modificar un Array p.~\pageref{splice_exercise})}
\label{sol_splice_exercise}

\subsubsection{Simulando la función {\tt pop}}

La subrutina {\tt my-pop} usa la función {\tt splice} para
simular la función {\tt pop}: 
\index{pop function}

\begin{verbatim}
sub my-pop (@array where @array > 0) {
    my @result = splice @array, @array.end, 1;
    return @result[0];
}
my @letras = 'a'..'j';
my $letra = my-pop @letras;
say $letra;             # -> j
say @letras;            # -> [a b c d e f g h i]
\end{verbatim}

Aquí, la expresión \verb|@array.end| devuelve el índice del
último elemento del array. También es posible contar el número
de artículos en el array usando dicho índice y acceder al último
y los penúltimos artículos de una lista o un array usando la
siguiente sintaxis:

\begin{verbatim}
> say (1..9)[*-1];
9
> say (1..9)[*-2];
8
\end{verbatim}

La subrutina {\tt my-pop} podría escribirse como sigue:

\begin{verbatim}
sub my-pop( @array where @array > 0 ) {
    my @result = splice @array, *-1, 1;
    return @result[0];
}
\end{verbatim}

No tienes que especificar el número de elementos con  
{\tt splice} si quieres el resto. Podemos evitar el uso
del array inmediato \verb'@result'. Así que podríamos
simplificar {\tt my-pop}:
\index{pop function}
\index{splice function}

\begin{verbatim}
sub my-pop (@array where @array > 0) {
    @array.splice(*-1)[0]
}
\end{verbatim}


\subsubsection{Simulando la función {\tt push}}

La única dificultada en este ejercicio es manejar una signatura 
con una lista ``variádica`` de parámetros (o parámetros slurpy).
Esto se explicó en la Subsección~\ref{slurpy_params}:
(p.~\pageref{slurpy_params}).
\index{push function}
\index{slurpy parameters}
\index{variadic parameters}
\index{signature}

\begin{verbatim}
sub my-push( @array, *@lista ) {
    my @result = splice @array, @array.end + 1, 0, @lista;
    return @array; # push devuelve la lista modificada
                   # (raramente usada por arrays)
}
my @letras = 'a'..'j';
my-push  @letras, 'k', 'l', 'm';
say @letras;      # -> [a b c d e f g h i j k l m]
\end{verbatim}

\subsubsection{Simulando la función {\tt unshift}}

Para simular la función \verb|unshift|, usamos los parámetros
slurpy nuevamente:
\index{slurpy parameters}
\index{unshift function}

\begin{verbatim}
sub my-unshift( @array, *@lista ) {
    my @result = splice @array, 0, 0, @lista;
    return @array; # unshift devuelve la lista modificada
                   # (raramente usada por arrays)
}
my @letras = 'd'..'j';
my-unshift @letras, 'a'..'c';
say @letras;      # -> [a b c d e f g h i j]
\end{verbatim}

\subsubsection{Simulando el adverbio de subíndice {\tt delete}}

Recuerda que el adverbio {\tt delete} remueve le valor, pero deja
el espacio indefinido dentro del array. La función {\tt splice}
también removería el espacio, que es algo distinto a lo que queremos
si buscamos simular el comportamiento {\tt delete} (aunque, en 
alguna manera, podría considerarse una mejora remover el espacio
también). Para realmente simular la función {\tt delete}, es
probablemente mejor si solo dejamos el valor ``indefinido``:
\index{delete adverb}

\begin{verbatim}
sub my-delete( @array, $idx ) {
    my $art = @array[$idx];
    @array[$idx] = Nil;
    return $art;
}
my @letras = 'a'..'j';
my $letra = my-delete @letras, 4;
say $letra;       # -> e
say @letras;      # -> [a b c d (Any) f g h i j]
\end{verbatim}

\subsection{Ejercicio de la Sección~\ref{map_filter}: Mapeando y Filtrando los Elementos de una Lista (p.~\pageref{exercise_squares})}
\label{sol_exercise_squares}

Producir un array que contiene los cuadrados de los números de
una lista de entrada es algo directo:
\index{map function}

\begin{verbatim}
my @cuadrados = map { $_ ** 2 }, 3, 5, 7;     # -> [9 25 49]
\end{verbatim}
%

Para mantener los elementos de una lista que son cuadrados perfectos,
una manera de hacerlo es chequear si la raíz cuadrada de cada 
número es un número entero. Por ejemplo:
\index{grep function}

\begin{verbatim}
my @filtro = grep { my $sq = sqrt $_; $sq == $sq.Int}, 3, 9, 8, 16;
say @filtro;                                  # -> [9 16]
\end{verbatim}
%

Esto funciona bien con la muestra de datos del ejemplo, pero
este programa fallará si intentamos con un número negativo.
Queremos evitar esa excepción y solo considerar que un número
negativo nunca puede ser un cuadrado perfecto.

Debido a que el bloque de código aquí se complicaría, podríamos
mejor usar una referencia de una función:

\begin{verbatim}
sub es-cuadrado( Numeric $num ) { 
    return False if $num < 0;
    my $raiz_cuad = sqrt $num;
    return $raiz_cuad == $raiz_cuad.Int;
} 
my @filtro = grep &es-cuadrado, 3, 9, -6, 16;   # -> [9 16]
\end{verbatim}
%
\subsection{Ejercicio de la Sección~\ref{advanced_sort}: Técnicas Avanzadas de Ordenamiento (p.~\pageref{sort_exercise})}
\label{sol_sort_exercise}

La subrutina de transformación que puede extraer grupos de
letras desde las cadenas de texto es algo directo:
\index{sort!transformation subroutine}

\begin{verbatim}
sub my_comp( Str $cad ) {
    return $0 if $cad ~~ /^\d+ (\w+)/; 
    Nil;   # devuelve Nil si el regex no coincidió
}
\end{verbatim}
%
\index{sort}
El ordenamiento es el mismo del capítulo original:
\begin{verbatim}
say sort &my_comp, <22ac 34bd 56aa3 12c; 4abc( 1ca 45bc>;
     # -> (56aa3 4abc( 22ac 45bc 34bd 12c; 1ca)
\end{verbatim}

La subrutina de transformación es lo suficientemente simple
para ser fácilmente reemplazada con un bloque de código:
\index{sort!transformation subroutine}

\begin{verbatim}
my @desordenados = <22ac 34bd 56aa3 12c; 42acd 12cd; 4abc( 1ca 45bc 3dab!>;
my @ordenados = sort {/\d+ (\w+)/; $0 // Nil}, @desordenados;
say @ordenados; 
     # -> [56aa3 4abc( 22ac 42acd 45bc 34bd 12c; 1ca 12cd; 3dab!]
\end{verbatim}
%
Esto puede también escribirse con una sintaxis de 
invocación de método:
\index{invocation!method}
\index{method invocation}
\begin{verbatim}
my @ordenados = @desordenados.sort: {/\d+ (\w+)/; $0 // Nil};
\end{verbatim}
%

\subsection{Ejercicio~\ref{nested_sum}: Suma Anidada (p.~\pageref{nested_sum})}
\label{sol_nested_sum}

La manera más obvia de calcular la suma de todos los valores
contenidos en listas anidadas o arrays anidados es usa bucles
anidados. Por ejemplo:
\index{nested list}
\index{list!nested}

\begin{verbatim}
my @AoA = [[1, 2], [3], [4, 5, 6]];
sub suma-anidada( @array ) { 
    my $suma; 
    for @array -> $elem { 
        for $elem.flat -> $elem_anidado {
            $suma += $elem_anidado;
        }
    } 
    return $suma
}
say suma-anidada @AoA;  # -> 21
\end{verbatim}

La única dificultad sintáctica aquí es que tenemos
que aplanar las sub-listas \verb|$elem| para recorrerla.
Esto podría también hacerse con el operado ``|``:
\index{list flattening}
\begin{verbatim}
        for |$elem -> $elem_anidado { ... }
\end{verbatim}

Esta es otra manera de hacerlo, que usa un bucle {\tt for}
para recorrer el array externo y el operador de reducción 
para agregar los elementos de las listas anidadas:

\begin{verbatim}
my @AoA = [[1, 2], [3], [4, 5, 6]];
sub suma-anidada( @array ) { 
    my $suma; 
    for @array -> $elem { 
        $suma += [+] $elem;
    } 
    return $suma
}
say nested-sum @AoA;  # -> 21
\end{verbatim}

Usar la función {\tt map} para aplanar las listas anidadas
y el operador de reducción puede hacer este código 
considerablemente más corto:

\begin{verbatim}
my @AoA = [[1, 2], [3], [4, 5, 6]];
sub suma-anidada( @array ) { 
    return  [+]  map {|$_}, @array;
}
say suma-anidada @AoA;  # -> 21
\end{verbatim}

Al comparar esta solución que necesita una sola línea
de código con la primera muestra lo expresivo que 
el estilo de programación funcional puede ser para manejar
arrays y listas y posiblemente entiendes la razón
por la cual he recomendado este estilo de programación
en este capítulo.

Estas soluciones funcionan bien porque se sabe
que solo hay listas y listas anidadas (listas de listas).
¿Qué pasa si el nivel de anidamiento no se conoce con 
antelación? Una solución para esto sería el uso de una
subrutina recursiva para explorar el árbol de listas:
\index{recursion}

\begin{verbatim}
my @AoA = [[1,2], [3], [4,5,6], [3, [7,6, [3,2]]]];
sub suma-anidada( $entrada ) { 
    my $suma = 0; 
    for |$entrada -> $elem { 
        if $elem.WHAT ~~  Int {
            $suma += $elem;
        } else {
            $suma += suma-anidada $item;
        }
    } 
    return $suma;
}
say suma-anidada @AoA;  # -> 42
\end{verbatim}

Recuerda que una técnica recursiva es usualmente una
herramienta eficiente para manejar datos encadenados o
anidados.

\subsection{Ejercicio~\ref{cumsum}: Suma Acumulativa (p.~\pageref{cumsum})}
\label{sol_cumsum}

Para calcular la suma acumulativa de una lista de valores numéricos,
solo necesitamos una acumulador y usamos el valor del acumulador
cada vez a través de la iteración sobre el array:
\index{accumulator!list}

\begin{verbatim}
my @números = <2 5 7 6 5 3 6 8>;
say suma-acumula(@números); # -> [2 7 14 20 25 28 34 42]

sub suma-acumula( @array ) {
    my @acumulativa;
    my $suma_partial = 0;
    for @array -> $elemento {
        $suma_partial += $elemento;
        push @acumulativa, $suma_partial;
    }
    return @acumulativa;
}
\end{verbatim}

Pero adivina qué? El código puede ser mucho más corto
con la programación funcional. Recuerda que el metaoperador
de reducción puede darte una lista de resultados parciales:
\index{reduction operator}
\index{metaoperator}
\index{functional programming}

\begin{verbatim}
my @números = <2 5 7 6 5 3 6 8>;
say [\+] @números;    # -> (2 7 14 20 25 28 34 42)
\end{verbatim}

Podrías pensar que he diseñado estos ejercicios para probar
mi punto sobre el poder expresivo de la programación
funcional. ¡No del todo! Ambos ejercicios, este ejercicio
y el anterior, son tomados directamente del libro \emph{Think Python}
de Allen Downey en el cual este libro está basado. 
No he escrito estos dos ejercicios pero solamente las
soluciones presentadas aquí.


\subsection{Ejercicio~\ref{middle}: Medio (p.~\pageref{middle})}
\label{sol_middle}

La forma más fácil de producir una lista nueva que contiene
todos los elementos excepto el primer y último elemento de
una lista dada es simplemente usar una rebanada (\emph{slice}):
\index{slice}

\begin{verbatim}
say medio(5..10);    # -> (6 7 8 9)
sub medio( @array ) { 
    return @array[1..*-2] 
}
\end{verbatim}

Nota que \verb|*-1| se refiere al índice del último elemento
de una array. Para desechar el último elemento, podemos limitar 
el rango \verb|*-2|.

\subsection{Ejercicio~\ref{chop}: Corta (p.~\pageref{chop})}
\label{sol_chop}

La diferencia básica con el ejercicio previo es que 
el array debería ser modificado en lugar, en vez de 
ser devuelto desde la función.

Esta es una posible solución, la cual las funciones
{\tt shift} y {\tt pop} para remover respectivamente el primer y
el último elemento de una array:
\index{shift function}
\index{pop function}

\begin{verbatim}
my @nums = 5..10;
corta(@nums); 
say @nums;   # -> [6 7 8 9]

sub corta( @array ) { 
    shift @array; 
    pop @array; 
    return;
}
\end{verbatim}

Usar una rebanada es más simple; solo asegúrate de asignar
la rebanada el array para modificar el array en lugar:
\index{slice}

\begin{verbatim}
sub corta( @array ) { 
    @array = @array[1..*-2];
    return;
}
\end{verbatim}
%

\subsection{Ejercicio~\ref{is_sorted}: Subrutina {\tt está-ordenada} (p.~\pageref{is_sorted})}
\label{sol_is_sorted}
\index{is-sorted}

Para chequear si una lista está ordenada, solo necesitamos iterar
sobre sus elementos, mantener un registro del valor previo y 
comparar el valor actual con el valor previo. Devolver falso
si cualquier par de valores no satisface la comparación, 
y devolver verdadero si se llegas al final de la iteración:

\begin{verbatim}
sub está-ordenada( @array ) {
    my $previo = @array[0];
    for @array -> $actual {
        return False if $actual < $previo;
        $previo = $actual;
    }
    return True;
}
say está-ordenada < 2 4 5 7 7 8 9>;    # -> True
say está-ordenada < 2 4 5 7 6 8 9>;    # -> False
\end{verbatim}

Otra técnica podría simplemente comparar la lista de
entrada con una versión de la misma:
\index{sort}

\begin{verbatim}
sub está-ordenada(@array) {
    return @array eqv @array.sort;
}
say is-sorted < 2 4 5 7 7 8 9>;    # -> True
say is-sorted < 2 4 5 7 6 8 9>;    # -> False
\end{verbatim}

Mientras esto conduce a código más corto y simple,
esta no es una solución óptima, porque requiere que 
el programa ordene el array de entrada, lo cual es
significativamente más costoso que solamente recorrer
el array, por lo menos cuando el array a ser chequeado
es largo.

Una vez más, la programación funcional y especialmente 
el hiperoperador de reducción puede conducir a código
mucho más corto que la primera solución, sin incurrir 
en el costo de un ordenamiento adicional:s
\index{functional programming}
\index{reduction!metaoperator}

\begin{verbatim}
sub está-ordenada( @array ) {
    return [<=] @array;
}
say está-ordenada < 2 4 5 7 7 8 9>;    # -> True
say está-ordenada < 2 4 5 7 6 8 9>;    # -> False
\end{verbatim}

Por cierto, esta última versión de {\tt está-ordenada} 
hará ``corto circuito`` y devolver \verb|False| tan pronto
haya encontrado el valor que no se encuentra en el orden
correcto, sin iterar sobre el resto de la lista.
\index{short-circuit evaluation}

\subsection{Ejercicio~\ref{is_anagram}: Subrutina {\tt es-anagrama} (p.~\pageref{is_anagram})}
\label{sol_is_anagram}
\index{anagram}
\index{is-anagram}

Al comparar dos palabras para chequear si son anagramas, 
podemos iniciar con devolver falso si no tienen la misma
longitud, dado que los anagramas obviamente tienen 
el mismo número de letra. Esto podría agilizar el proceso 
si el proceso detallado para comparar dos cadenas de texto
requiere mucho tiempo, al evitar la parte que consume mucho
tiempo para casos que obviamente no coincidirán.


No queremos intentar cada permutación de las letras
dado que eso tomaría mucho tiempo. La forma más fácil 
de chequear por anagramas es probablemente comenzar 
con la \emph{normalización} de las cadenas de texto de
entrada, i.e., reorganizando las cadenas de texto de
tal manera que puedan ser fácilmente comparadas. La manera
más obvia es solo ordenar las letras de las dos palabras
y comparar los resultados:
\index{sort}

\begin{verbatim}
sub es-anagrama( Str $palabra1, Str $palabra2 ) {
    return False if $palabra1.chars != $palabra2.chars;
    return False if $palabra1.comb.sort ne $palabra2.comb.sort;
    True;
}
for <ban bane post stop pots stop post pots pots taps> -> $w1, $w2 {
    say "$w1 $w2:\t", es-anagrama $w1, $w2;
}
\end{verbatim}

Esto produce la siguiente salida:
\begin{verbatim}
$ perl6 anagramas.pl6
ban bane:       False
post stop:      True
pots stop:      True
post pots:      True
pots taps:      False
saco cosa: 		True
\end{verbatim}

Nota que esto funciona correctamente porque el operador
{\tt ne} coacciona su argumento en una cadena de texto antes
de realizar la comparación.
\index{ne, string inequality operator}
\index{coercion}

Este código puede reducirse aún más (pero posiblemente 
menos eficiente) al devolver directamente la compraración 
de las versiones ordenadas:

\begin{verbatim}
sub es-anagrama( Str $palabra1, Str $palabra2 ) {
    return $palabra1.comb.sort eq $palabra1.comb.sort;
}
\end{verbatim}


\subsection{Ejercicio~\ref{has_duplicates}: Subrutina {\tt tiene-duplicados} (p.~\pageref{has_duplicates})}
\label{sol_has_duplicates}
\index{duplicate}
\index{has-duplicates}

Dentro del contexto de lo que hemos visto hasta ahora, 
la forma más fácil de encontrar si una lista de cadenas
de texto tiene duplicados es probablemente ordenar la
lista, para que duplicados posibles sean adyacentes, y 
comparar cada elemento del array ordenado con el
elemento previo (o siguiente):

\index{sort}

\begin{verbatim}
say tiene-duplicados(< a b c df g xy z r e >); # -> False
say tiene-duplicados( < a b c df g xy z c e >); # -> True

sub tiene-duplicados( @array ) {
    my @ordenado = sort @array;
    for 1..@ordenado.end -> $i {
        return True if @ordenado[$i] eq @ordenado[$i - 1];
    }
    False;
}
\end{verbatim}
%

En este ejemplo, el bucle comienza con el índice 1 (y no 0)
por cada artículo es comparado con el artículo previo.

Otra forma es iterar sobre los elementos de una array ordenado
y mantener un registro de los artículos previos para habilitar
la  comparación:

\begin{verbatim}
say tiene-duplicados( < a b c d f y z r e >); # -> False
say tiene-duplicados( < a b c d f y z c e >); # -> True

sub tiene-duplicados( @array ) {
    my @ordenado = sort @array;
    my $previo   = shift @ordenado;
    for @ordenado -> $artic {
        return True if $artic eq $previo;
        $previo = $artic;
    }
    False;
}
\end{verbatim}
%

Otra posibilidad es usa la función {\tt unique} de Perl~6,
la cual devuelve una secuencia de valores únicos desde la
lista o array de entrada. Comparar el número de elementos de
la salida de {\tt output} con el número de elementos de la
lista original nos dirá si algunos duplicados fueron 
removidos por {\tt unique}:
\index{unique function}
\index{elems function or method}

\begin{verbatim}
sub tiene-duplicados( @array ) {
    my @artic-unicos = unique @array;
    return False if @artic-unicos.elems == @array.elems;
    True;
}
\end{verbatim}

Esto podría escribirse más concisamente al encadenar
las invocaciones de método:
\index{invocation!method}
\index{method invocation}

\begin{verbatim}
sub tiene-duplicados( @array ) {
    @array.unique.elems != @array.elems;
}
\end{verbatim}

Nota que Perl también tiene una función integrada {\tt repeated},
la cual es la contraparte de {\t unique} y devuelve los elementos
duplicados de una lista: 
\index{repeated method}

\begin{verbatim}
say <a b c d b f d>.repeated;  # -> (b d)
\end{verbatim}

La subrutina {\tt tiene-duplicados} puede también coaccionar
la salida de {\tt repeated} en un Booleano:
\index{coerce}
\begin{verbatim}
sub tiene-duplicados( @array ) {
    ?@array.repeated 	# -> ? coacciona su argumento a un Booleano
}
\end{verbatim}

Otra forma eficiente de encontrar o remover los duplicados
de una lista o un array es usar \emph{hashes}, una 
estructura de datos integrada que discutimos en el Capítulo~\ref{hashes} 
(ver Ejercicio~\ref{has_duplicates_hash}).
\index{hash}

\subsection{Ejercicio~\ref{birthdays}: Simulando la Paradoja del Cumpleaños (p.~\pageref{birthdays})}
\label{sol_birthdays}
\index{birthday paradox}
\index{duplicate}

Para simular la paradoja del cumpleaños, necesitamos
generar enteros aleatorios entre 1 y 365 (cada entero
representa una fecha en el año). Por razones de
simplicidad, generaremos enteros aleatorios entre 
0 y 364, lo cual es equivalente para nuestro propósito.

Ejecutaremos la simulación 1,000 veces:

\begin{verbatim}

sub tiene-duplicados( @array ) {
    return ?@array.repeated
}

sub tiene-cumpleaños-duplicados( Int $num-estudiantes ) {
    my @blist;
    for 1..$num-estudiantes {
        push @blist, 365.rand.Int; # números entre 0 y 364
    }
    return tiene-duplicados(@blist);
}

my $cuenta-dupl = 0;
my $num-pruebas = 1000;
for 1..$num-pruebas{
    $dupl-count++ if tiene-cumpleaños-duplicados 23; # 23 estudiantes
}
say "En $num-pruebas pruebas, $cuenta-dupl tenían "~
	"por lo menos un cumpleaño duplicado";
\end{verbatim}

Nota que hemos reutilizado la subrutina {\tt tiene-duplicados}
del ejercicio anterior. Es tan corta que su código podría
haberse utilizado en línea en la subrutina \verb|tiene-cumpleaños-duplicados|,
pero es considerado buena práctica utilizar componentes
de software que han sido desarrollados y probados.

Ejecutamos el programa cuatro veces y esto resulta:

\begin{verbatim}
$ perl6 birthdays.pl6
En 1000 pruebas, 498 tenían por lo menos un cumpleaño duplicado

$ perl6 birthdays.pl6
En 1000 pruebas, 505 tenían por lo menos un cumpleaño duplicado

$ perl6 birthdays.pl6
En 1000 pruebas, 527 tenían por lo menos un cumpleaño duplicado

$ perl6 birthdays.pl6
En 1000 pruebas, 491 tenían por lo menos un cumpleaño duplicado
\end{verbatim}

\index{birthday paradox}
Esta simulación confirma que con una muestra de 23 personas,
hay una posibilidad aproximada de 50\% que al menos 
dos personas tendrán el mismo cumpleaño.

Nota que Perl tiene una función integrada {\tt roll}
que devuelve elementos seleccionados aleatoriamente desde
una lista. Esto puede hacer la subrutina {\tt tiene-cumpleaños-duplicados}
significativamente más concisa:
\index{roll method}

\begin{verbatim}
sub tiene-cumpleaños-duplicados( Int $num-estudiantes ) {
    tiene-duplicados((^365).roll($num-estudiantes) )
}
\end{verbatim}

\subsection{Ejercicio~\ref{push_unshift}: Comparando a {\tt push} y {\tt unshift} (p.~\pageref{push_unshift})}
\label{sol_push_unshift}
\index{push function}
\index{unshift function}
\index{now}

Popular una array con {\tt push} o {\tt unshift}
es algo que has visto anteriormente. La única cosa nueva 
aquí es comparar el tiempo de ejecución de varias soluciones.
La función {\tt now} devuelve el número de segundos que 
ha transcurrido desde un punto de partida teórico llamado
``the Epoch`, usualmente 1 de Enero, 1970. Llamar a {\tt now}
una vez antes de ejecutar el script y otra vez después 
nos dirá el tiempo transcurrido a través de una sustracción simple.

\begin{verbatim}
my $inicio_push = now;
my @push_array;
for 'words.txt'.IO.lines -> $linea {
    push @push_array, $linea;
}
say "push tomó " ~ now - $inicio_push ~ " segundos.";
@push_array = ();

my $inicio_unsh = now;
my @unsh_array;
for 'words.txt'.IO.lines -> $linea {
    unshift @unsh_array, $linea;
}
say "unshift tomó " ~ now - $inicio_unsh ~ " segundos.";
@unsh_array = ();
\end{verbatim}

Esta es una muestra de ejecución del programa:
\begin{verbatim}
push tomó 1.870107 segundos.
unshift tomó 2.2291266 segundos.
\end{verbatim}

Inténtalo tu mismo y ejecútalo varias veces. Deberías
notar que {\tt push} es consistentemente más rápido
que {\tt unshift}, aunque la diferencia no es tan abismal.

Presumiblemente, esto se debe a que {\tt unshift} 
cuando está insertando elementos al comienzo del array, 
Perl tiene que mover los datos muchas veces para 
reorganizar el array completo. Por lo contrario, 
usar {\tt push} para insertar elementos al final 
del array implica menos mantenimiento interno de los
datos.

Como un ejercicio adicional, puedes tratar de explorar
otras maneras de poblar un array, tal como {\tt append} o 
{\tt splice}.
\index{splice function}
\index{append function}

Si vas a insertar cada línea del archivo de entrada
en un array sin hacer ningún cambio a esas líneas, 
sorber (\emph{slurp}) todos los datos en el array sin un bucle será
más simple y mucho más rápido:
\index{slurp}

\begin{verbatim}
my $sorbido_inicio = now;
my @array_sorbido = 'words.txt'.IO.lines;
say "slurp tomó " ~ now - $sorbido_inicio ~ " segundos.";
\end{verbatim}

Esto es de cuatro a cinco veces más rápido:
\begin{verbatim}
slurp took 0.42602506 seconds.
\end{verbatim}

Nota que realmente no necesitas llamar la función \verb|now| al
inicio del programa: puedes usar \verb'INIT now' para 
extraer el tiempo cuando el programa comenzó a ejecutarse:

\begin{verbatim}
my @array_sorbido = 'words.txt'.IO.lines;
say "slurp tomó " ~ (now - INIT now) ~ " segundos.";
\end{verbatim}
\index{now}
\index{INIT now}

\subsection{Ejercicio~\ref{bisection}: Búsqueda Binaria en una Lista (p.~\pageref{bisection})}
\label{sol_bisection}
\index{bisect}
\index{membership!bisection search}
\index{bisection search}
\index{search!bisection}
\index{membership!binary search}
\index{binary search}
\index{search!binary}
\index{half-interval search}

Podemos comenzar con un algoritmo de bisección recursiva:
\index{recursion}


\begin{verbatim}
sub bisectar( @lista_palabras, Str $palabra ) {
    my $indice = (@lista_palabras.elems / 2).Int;
    return False if $indice == 0 and @lista_palabras[$indice] ne $palabra;
    my $encontrada = @lista_palabras[$indice];
    if $palabra lt $encontrada {
        # realiza la búsqueda en la primera mitad del array
        return bisectar @lista_palabras[0..$indice-1], $palabra;
    } elsif $palabra gt $encontrada {
        # realiza la búsqueda en la segunda mitad del array
        return bisectar @lista_palabras[$indice+1..*-1], $palabra;
    }
    True;     # si llegamos aquí, hemos encontrado la palabra
}

for <a f w e q ab ce> -> $búsqueda { 
    if bisectar [<a b d c e f g>], $búsqueda {
        say "'$búsqueda' encontrada";
    } else {
        say "'$búsqueda' no encontrada";
    }
}
\end{verbatim}

Esto mostrará la salida siguiente:
\begin{verbatim}
'a' encontrada
'f' encontrada
'w' no encontrada 
'e' encontrada
'q' no encontrada 
'ab' no encontrada 
'ce' no encontrada 
\end{verbatim}

Existen varias debilidades en esta implementación.
Primero, en cada llamada recursiva, {\tt bisectar}
pasa como un argumento un array que puede ser bien grande,
y esto no es eficiente en términos de uso de memoria
(para almacenar los subconjuntos sucesivos del array original)
y términos de los ciclos de CPU (el tiempo tomado e 
copiar estos arrays).


Además, podemos saber si la palabra a buscarse puede 
encontrarse en la lista (y existen muchos casos donde
no necesitamos más información que esa), pero no sabemos 
donde se encontró (i.e., el índice original en el array original),
que es lo que realmente necesitábamos.

Una opción involucra tener solamente una copia del
array original, digamos una variable global, y 
pasar rangos de índices. Pero variables globales
son usualmente desaprobadas porque tienden a ir
en contra de los postulados de la programación estructurada
y pueden ser peligrosa (aunque este sería un caso
donde el uso de variables globales hace sentido).
Podemos actualmente trabajar mejor sin el uso de variables
globales y aún tener el beneficio de no pasar el array 
completo una y otra vez gracias al hecho que, en Perl~6,
las subrutinas son \emph{clausuras}, lo cual significa que 
pueden acceder variables que existen en el entorno donde
fueron creadas.
\index{closure}

En el código siguiente, {\tt bisectar} no es un subrutina
recursiva; ahora, es una subrutina muy simple que solo 
configura el entorno para {\tt bisectar2}, la cual es 
la subrutina recursiva y está definida dentro del cuerpo de
{\tt bisectar}. Dado que el array y la palabra a ser buscada
existen dentro de {\tt bisectar}, {\tt bisectar2} será capaz
de tener acceso a ellos. Los parámetros de {\tt bisectar2} 
son solamente dos subíndices que representan el rango en 
el cual tendrá que buscar la palabra:
\index{recursion}

\begin{verbatim}
sub bisectar( Str $palabra, @lista_palabras ) {
    sub bisectar2( $idx_inferior, $idx_superior ) {
        my $idx_medio = (($idx_inferior + $idx_superior) /2).Int;
        my $encontrada = @lista_palabras[$idx_medio ];
        return $idx_medio if $palabra eq $encontrada;
        return -1 if $idx_inferior >= $$idx_superior;
        if $palabra lt $encontrada {
             # realiza la búsqueda en la primera mitad del array
            return bisectar2 $idx_inferior, $idx_medio - 1;
        } else {
             # realiza la búsqueda en la segunda mitad del array
            return bisectar2 $idx_medio+1, $idx_superior;
        }
    }
    my $indice_max = @lista_palabras.end;
    return bisectar2 0, $indice_max;
}

for <a f w e q ab ce g> -> $búsqueda { 
    my $result = bisectar $búsqueda, [<a b d c e f g>];
    if $result == -1 {
        say "'$búsqueda' no encontrada";
    } else {
        say "'$búsqueda' encontrada en la posición $result";
    }
}
\end{verbatim}

Como un ejercicio adicional, adapta el programa anterior
para buscar palabras en inglés en \emph{words.txt} y
palabras en español en \emph{lemario.txt}. Nota lo rápido
que es. Por favor ten presente que esto funciona porque las
palabras en este archivo están ordenadas alfabéticamente.

Intenta cambiar el código para contar y mostrar el número
de pasos necesarios para encontrar una palabra dada. Compara
esto con el número de pasos que tomaría una búsqueda lineal
en promedio (i.e., recorrer el array linealmente hasta 
encontrar la palabra o pueda la palabra ser declarad ausente).
Puedes adivinar por qué este algoritmo es también 
llamado \emph{búsqueda logarítmica}?
\index{logarithmic search}

Podrías también escribir una solución que no es recursiva usando
un bucle.


\subsection{Ejercicio~\ref{reverse_pair}: Invirtiendo Parejas de Palabras (p.~\pageref{reverse_pair})}
\label{sol_reverse_pair}
\index{reverse word pair}

Encontrar parejas de inversa requiere leer cada palabra 
de la lista y chequear la lista para ver si las palabras
inversas existen en la lista. Esto significa que vas a buscar
alrededor de 113,000 palabras en una lista que contiene
113,000 palabras. Tu método de búsqueda necesita ser eficiente.
La solución obvia es usar la búsqueda binaria implementada en
el ejercicio anterior:
\index{bisection search}
\index{search!bisection}

\begin{verbatim}
sub bisectar( Str $palabra, @lista_palabras ) {
    # ver código en el ejercicio anterior
}

my @array = 'words.txt'.IO.lines;

for @array -> $palabra {
    my $inversa = $palabra.flip;
    my $res = bisectar $inversa, @array;
    say "$palabra y $inversa forman una pareja de inversas" if $res >= 0;
}
say now - INIT now;
\end{verbatim}

En mi computador portátil (una computadora decente pero no una máquina
poderosa), el proceso completo tomó 42~segundos, i.e.,
menos de 0.4~milisegundos por búsqueda.

Si piensa sobre ello, el bucle {\tt for} en el código más
arriba está realmente filtrando aquellas palabras que 
pertenecen a una pareja inversa de la lista de palabras. 
Esto podría implementarse con una función {\tt grep} 
usando la subrutina {\tt bisectar} para seleccionar las
coincidencias:
\index{for loop}
\index{grep}

\begin{verbatim}
say "$_ y $_.flip() forman una pareja de inversas" 
    for @array.grep( { bisect( .flip, @array ) >= 0 } );
\end{verbatim}

Con el algoritmo usado aquí, cada pareja de inversas
se encuentra dos veces (una vez por cada palabra de la
pareja). Al examinar cualquier palabra de la lista, 
realmente no necesitamos buscar hacia atrás en la parte de la
lista anterior a esa palabra dado que si la palabra 
forma una pareja con otra palabra que viene antes
en el orden alfabético, ya hemos encontrado la pareja
cuando procesamos esa otra palabra. Por lo tanto sería
más eficiente y más rápido si hacemos la búsqueda solamente hacia
adelante, i.e., buscar la palabra en la parte de la lista
que viene después de la palabra que está siendo examinada.
Como un ejercicio adicional, modifica el bucle {\tt for} 
para buscar palabras hacia adelante.

\subsubsection{Comparando la búsqueda binaria con la búsqueda en un hash}

La búsqueda binaria es bastante rápida, pero la búsqueda en 
una hash es mucho más rápida. Aunque aún no hemos discutido los
hashes, intenta el código siguiente:
\index{hash}
\index{bisection search}
\index{search!bisection}

\begin{verbatim}
my %hash = map { $_ => 1}, 'words.txt'.IO.lines;
for %hash.keys -> $palabra {
    my $inversa = $palabra.flip;
    say "$palabra y $inversa forman una pareja de inversas" 
        if %hash{$reverse}:exists;
}
say now - INIT now;
\end{verbatim}

No te preocupes en entender el código por el tiempo presente,
pero nota lo corto que es. Y lo rápido que se ejecute:
en la misma computadora portátil, el tiempo de ejecución
es alrededor de 16~segundos (menos de 0.15 milisegundos por búsqueda).
Espero que esto estimulará tu apetito para el Capítulo~\ref{hashes}.

Nota que la salida de este ejemplo no está ordenada porque
un hash no mantiene el orden de los datos de entrada, como veremos
en el Capítulo~\ref{hashes}. Sería bien fácil mantener el ordenamiento,
por ejemplo al usar un array en adición al hash, pero ese no es realmente
el tema aquí.

\subsubsection{Creando y usando un módulo}

\index{module}
\label{bisect_module}
Regresando a la subrutina {\tt bisectar}, copiar y 
pegar esta subrutina desde el programa del ejercicio anterior
en el código de este ejercicio no es la mejor manera 
de reutilizar código. Supón que un error es encontrado 
en esa subrutina; ahora necesita ser arreglado en dos programas
diferentes; la probabilidad que ese error sea corregido en
un programa y olvidado en el otro es bien significante.
Aún si no se olvida, esto doblemente arduo, y esto es 
incrementa la probabilidad de cometer otro error en el
proceso. Aún si no hay ningún error, podríamos necesitar
un mejora y otra vez esto debe hacerse dos veces.
\index{code reuse}

Una buena manera de reutilizar software mientras 
se mantiene una sola copia de la subrutina reutilizada
es insertarla en un módulo de Perl, i.e, en un archivo separado
que será cargado en nuestros programas para usarlo.

El módulo podría nombrarse \emph{BusquedaBinaria.pm} y contener
el código siguiente:
\index{BisectSearch module}
\index{module!BisectSearch}
\index{module!creating a module}
\index{is export!trait}
\index{trait!is export}

\begin{verbatim}
unit module BusquedaBinaria;

sub bisectar( Str $palabra, @lista_palabras ) is export {
    sub bisectar2( $idx_inferior, $idx_superior ) {
        my $idx_medio = (($idx_inferior + $idx_superior) /2).Int;
        my $encontrada = @lista_palabras[$idx_medio ];
        return $idx_medio if $palabra eq $encontrada;
        return -1 if $idx_inferior >= $$idx_superior;
        if $palabra lt $encontrada {
            # realiza la búsqueda en la primera mitad del array
            return bisectar2 $idx_inferior, $idx_medio - 1;
        } 
        else {
            # realiza la búsqueda en la segunda mitad del array
            return bisectar2 $idx_medio+1, $idx_superior;
        }
    }
    my $indice_max = @lista_palabras.end;
    return bisectar2 0, $indice_max;
}

sub mostrar-resultado( Int $result, Str $busqueda ) is export {
    if $result == -1 {
        say "'$busqueda' no encontrada";
    }
    else {
        say "'$busqueda' encontrada: artículo # $result";
    }
}
\end{verbatim}

Nota que el nombre del módulo dado en la parte superior del
código y el nombre del archivo tienen que corresponder:
\begin{itemize}
	\item unit module {\bf BusquedaBinaria};
	\item {\bf BusquedaBinaria}.pm
\end{itemize}

El otro cambio que se hizo al código de la subrutina fue agregar el
rasgo {\tt is export} a la signatura de la subrutina.
\index{signature}
\index{trait}

\index{module!using a module}
Ahora un programa de Perl será capaz de cargar este módulo
y usar las subrutinas {\tt bisectar} y {\tt mostrar-resultado}.
Por ejemplo:
\index{use lib}
\index{module!use}
\index{use module}
\begin{verbatim}
use lib ".";  # le dice a Perl que busque módulos en el directorio actual
use BusquedaBinaria;

my @array = 'a'..'m';
for < a f w e q ab ce g > -> $busqueda { 
    my $result = bisectar $busqueda, @array;
    mostrar-resultado $result, $busqueda;
}
\end{verbatim}
%

Perl tiene una lista de directorios que busca por módulos,
los cuales pueden variar de una instalación de Perl a otra.
La primera línea {\tt use lib ".";} le dice a Perl que también
busque por módulos en el directorio actual (i.e., el directorio
donde se ejecuta el programa que utiliza el módulo). Esto es
solo un ejemplo; podrías preferir usar un directorio para tus
módulos. La segunda línea {\tt use BusquedaBinaria;} le dice a
Perl que cargue el módulo e importe las subrutinas marcadas
para exportación (por ejemplo, con {\tt is export}) en el módulo.
Ahora, el programa puede usar las subrutinas {\tt bisectar}
y {\tt mostrar-resultado} como si hubiesen sido definidas dentro
del programa.

¡Eso es todo, amigos! ¿Bien simple, cierto? ¡Solo inténtalo!
Aunque existen otras cosas más que saber sobre módulos, ya sabes lo suficiente
para crear y usar módulos.

Podrías revisar algunas de las otras subrutinas que hemos
creado hasta ahora y poner aquellas que podrían ser útiles
en un módulo. Pista: algunas de las subrutinas relacionadas
con cadenas de texto y arrays que hemos visto hasta ahora
son buenas candidatas.
\index{module}

\subsection{Ejercicio~\ref{interlock}: Entrelazando Palabras (p.~\pageref{interlock})}


\label{sol_interlock}

Primero, al parecer fue una buena idea crear el módulo
\verb|BusquedaBinaria|. Los reutilizaremos inmediatamente.

Segundo, necesitamos pensar. La primera idea para solucionar
el problema podría ser el uso de un bucle anidado en la lista
de palabras en orden para encontrar todas las parejas de 
las dos palabras, entrelazarlas, y chequear si la cadena
resultante existe en la lista. Pero esto es bien ineficiente
debido a que significa que debemos crear 113,000 parejas 
al cuadrado, i.e., más de 12.5 billones de parejas.

Aún si una parte relativamente grande de estas parejas
puede eliminarse antes de hacer la búsqueda en la lista de
palabras dado que una pareja puede ser entrelazada solo si
la diferencia entre el número de letras de las dos palabras
es 0 o 1, chequear todas estas parejas tomará eones.


Veamos que pasa si trabajamos en la otra dirección: por cada
palabra en la lista de palabras, nosotros ``entrelazamos``
la palabra en una cadena de texto con las letras pares y las
letras impares, y después chequeamos si estas sub-cadenas pertenecen
a la lista. Como máximo, necesitamos 226,000~búsquedas--de hecho 
mucho menos porque no necesitamos buscar la segunda cadena de 
texto si la primera cadena de texto no coincidió con nada.

Esta es la solución que sugerimos:
\begin{verbatim}
use lib ".";
use BusquedaBinaria;

my @array = 'words.txt'.IO.lines;
for @array -> $palabra {
    my ($palabra1, $palabra2) = entrelazar($palabra);
    say "$palabra: $palabra1, $palabra2" if 
        bisectar($palabra1, @array) >= 0 and 
        bisectar($palabra2, @array) >= 0;
}

sub entrelazar( Str $palabra ) {
    my @letras  = $palabra.comb;
    my $pares   = join '', map {@letras[$_] if $_ %% 2}, @letras.keys;
    my $impares = join '', map {@letras[$_] if $_ %  2}, @letras.keys;
    return ($pares, $impares);
}
\end{verbatim}

La subrutina {\tt entrelazar} no es óptima en el 
sentido que recorre las letras del array \verb|@letras| 
dos veces cada vez que es llamada. Podemos mejorarla
usando un bloque puntiagudo que toma dos parámetros (
una letra impar y otra par):

\begin{verbatim}
sub entrelazar( Str $palabra ) {
    my (@pares, @impares);
    for $palabra.comb -> $par, $impar {
        push @pares, $par;
        push @impares, $impar;
    }
    @pares.join, @impares.join;
}
\end{verbatim}

Como un ejercicio adicional, puedes encontrar palabras
que están entrelazadas en tres formas, es decir, cada tercer letra forma
una palabra, comenzando con la primera, segunda o tercera?
Pista: será probablemente más fácil si comienzas con la
versión revisada de {\tt entrelazar}  más arriba.


%\section{Exercises of Chapter~10: Hashes}
\section{Ejercicios del Capítulo~\ref{hashes}: Hashes}

\subsection{Ejercicio al Final de la Sección~\ref{hash_descr}: Un hash es un mapeo (p.~\pageref{ex_employees})}
\label{sol_ex_employees}
\index{hash}

Esta es la manera en la cual se puebla un par a la vez:

\begin{verbatim}
my %salarios;
%salarios{"Liz"} = 3000;
%salarios{"Bob"} = 2500;
%salarios{"Jack"} = 2000;
%salarios{"Betty"} = 1800;
say "El salario de Bob es %salarios{'Bob'}";
for <Liz Jack> -> $empleados {
    say "El salario de $empleado es %salarios{$empleado};
}
\end{verbatim}

Puedes evitar las comillas alrededor de las claves al 
usar el operador de comillas angulares \verb|<...>|:

\begin{verbatim}
my %salarios;
%salarios<Liz> = 3000;
%salarios<Bob> = 2500;
# ...
say "El salario de Bob es %salarios<Bob>";
\end{verbatim}

Y esto es cómo se asigna al hash completo en 
una sola vez:

\begin{verbatim}
my %salarios = Liz => 3000, Bob => 2500, Jack => 2000, Betty => 1800;
say %salarios; # -> Betty => 1800, Bob => 2500, Jack => 2000, Liz => 3000
\end{verbatim}

\subsection{Ejercicio~\ref{wordlist2}: Almacenar la Lista de Palabras en un Hash (p.~\pageref{wordlist2})}
\label{sol_wordlist2}

La forma estándar de almacenar la lista de palabras en un
hash sería leer cada línea de un archivo en un bucle {\tt for}
y almacenar cada palabra como la clave del hash. El contenido
del valor no es importante; almacenaremos 1 (haría también
sentido si almacenamos el valor Booleano \verb|True|):
\index{for loop}

\begin{verbatim}
my %palabras;
for 'lemario.txt'.IO.lines -> $linea {
    %palabras{$linea} = 1
}
\end{verbatim}

Una técnica alternativa es asignar al hash la salida de una 
expresión {\tt map} que devuelve una par por cada línea del
archivo:
\index{map}

\begin{verbatim}
my %palabras = map { $_ => 1 }, 'lemario.txt'.IO.lines;
\end{verbatim}
%

\subsection{Ejercicio~\ref{mem_ackerman}: Memoizando la Función Ackermann (p.~\pageref{mem_ackerman})}
\label{sol_mem_ackerman}
\index{memoize}

La implementación original de la función Ackermann
lucía así:

\begin{verbatim}
sub ack( $m, $n ) {
    return $n + 1 if $m == 0;
    return ack($m - 1, 1) if $n == 0;
    return ack($m - 1, ack($m, $n-1));
}
\end{verbatim}

No es posible memoizar los casos donde \verb|$m| o \verb|$n|
es cero, porque los otros valores son desconocidos. Solo
el código correspondiente a la última línea de código 
puede ser memoizado, pero eso está bien porque hace
casi todo el trabajo de cualquier manera.

El problema siguiente es que los hashes vistos hasta ahora 
tenían solamente una clave, pero la función Ackermann toma
dos parámetros. La solución simple es crear un clave compuesta,
i.e., concatenar los dos parámetros con un separador para crear
las claves del hash. Esto conduce a esta posible solución:

\begin{verbatim}
my %ack-memo;
sub mem-ack( Int $m, Int $n ) {
    return $n + 1 if $m == 0;
    return mem-ack($m - 1, 1) if $n == 0;
    %ack-memo{"$m;$n"} = mem-ack($m - 1, mem-ack($m, $n-1))
        unless %ack-memo{"$m;$n"}:exists;
    return %ack-memo{"$m;$n"};
}
say mem-ack 3, 4;
\end{verbatim} 

Para hacer un benchmark de las soluciones, puedes usar 
el código siguiente:

\begin{verbatim}
my %ack-memo;
sub mem-ack (Int $m, Int $n) {
    return $n + 1 if $m == 0;
    return mem-ack($m - 1, 1) if $n == 0;
    %ack-memo{"$m;$n"} = mem-ack($m - 1, mem-ack($m, $n-1)) 
        unless %ack-memo{"$m;$n"}:exists;
    return %ack-memo{"$m;$n"};
}
my $inicio = now;
say mem-ack 3, 4;
say "mem-ack runtime: ", now - $inicio;
dd %ack-memo;

sub ack ($m, $n) {
    return $n + 1 if $m == 0;
    return ack($m - 1, 1) if $n == 0;
    return ack($m - 1, ack($m, $n-1));
}
$inicio = now;
say ack 3, 4;
say "tiempo de ejecución de ack: ", now - $inicio;
\end{verbatim}

Pero no intentes ejecutarla con valores de \verb|$m|
mayores que 3; no es útil. Si fuéramos a encontrar 
un valor Ackermann para un par de números que ya hemos
visto, eso significaría que hemos entrado en un bucle 
infinito. Así que no hace sentido tratar de memoizar 
la función Ackermann.
\index{infinite loop}
\index{loop!infinite}

\index{multidimensional array}
\index{array!multidimensional}
Hemos usado claves compuestas para \verb|%ack-memo|, 
pero podemos tener hashes multidimensionales al igual 
que tenemos arrays multidimensionales (ver Sección~\ref{multidimensional_array}.
Solo necesitamos tener dos claves, cada una de dentro de
un par de llaves:
\index{multidimensional hash}
\index{hash!multidimensional}
\index{bracket!curly}
\index{curly bracket}
\begin{verbatim}
my %h;
%h{'a'}{'b'}= 'ab';
%h{'a'}{'c'}= 'ac';
%h{'a'}{'d'}= 'ad';
%h{'b'}{'c'}= 'bc';
dd %h; 
# -> Hash %h = {:a(${:b("ab"), :c("ac"), :d("ad")}), :b(${:c("bc")})}
\end{verbatim}
%

o usar un punto y medio para separar las llaves:
\index{semi-colon}

\begin{verbatim}
my %i;
%i{'a';'b'} = 'ab';
%i{'a';'c'} = 'ac';
%i{'b';'c'} = 'bc';
dd %i; # -> Hash %i = {:a(${:b("ab"), :c("ac")}), :b(${:c("bc")})}
\end{verbatim}
%

\subsection{Ejercicio~\ref{has_duplicates_hash}: Encontrando Duplicados con un Hash (p.~\pageref{has_duplicates_hash})}
\label{sol_has_duplicates_hash}
\index{duplicate}

Necesitamos un bucle sobre el array, almacenar los elementos
del array en un hash y detectar si un elemento se encuentra en 
el hash. Esta es una manera de lograr eso:

\begin{verbatim}
sub tiene-duplicados( @array ) {
    my %vistos;
    for @array -> $elmt {
        return True if %vistos{$elmt}:exists;
        %vistos{$elmt} = 1;
    }
    return False;
}
\end{verbatim}

Como un ejercicio adicional, genera una lista de 50,000~
enteros aleatorios entre 0 y 1,000,000,000, y después, usando
los varios métodos que hemos demostrado, chequea si esta
lista contiene elementos duplicados y mide el tiempo de ejecución
de estos varios métodos. Si encuentras dificultades haciendo esto,
estudia las soluciones a los ejercicios ``tiene duplicados`` 
(ver Subsección~\ref{sol_has_duplicates}) y la
``paradoja del cumpleaños`` (ver Subsección~\ref{sol_birthdays}))
para obtener algunas pistas. Un ejemplo de un benchmarking simple
es presentado en el ejercicio más arriba.
% ¿Una traducción para benchmarking?

Una vez que tus subrutinas funcionan apropiadamente, ejecuta el proceso
por lo menos 10 veces para ver si las diferencias son significantes.

\subsection{Ejercicio~\ref{exrotatepairs}: Rotar Pares (p.~\pageref{exrotatepairs})}
\label{sol_exrotatepairs}

Considera la palabra ``iron'' y haz una rotación de tres letras.
Esto resulta en la palabra ``folk`. Esto también significa 
que si rotamos a ``folk`` por 23 letras, obtendremos ``iron``
de vuelta. Dado que vamos a escanear todas las palabras de una 
lista de palabras, encontraremos este ``rotar par`` cuando 
intentamos un desplazamiento (\emph{shift}) de tres letras
con ``iron``, así que no hay necesidad de intentar un rotación
de 23 letras con ``folk``. Generalmente, solo necesitamos 
hacer rotaciones entre 1 y 13 letras.

El código siguiente itera a través de las palabras de la lista,
rota cada una de ellas por un desplazamiento 1 y 13, y busca el
resultado en el hash:

\begin{verbatim}
sub rotar-una-letra( Str $letra, Int $despl ) {
    my $última     = 'z'.ord;       # última letra minúscula
    my $ord-rotada = $letra.ord + $despl;
    if $letra ~~ /<[a..z]>/ { 
        $ord-rotada -= 26 if $ord-rotada > $última;
    } else {
        return $letra;
    }
    return $ord-rotada.chr;
}

sub rotar-una-palabra( Str $palabra, Int $despl ) {
    my $palabra-rotada = "";
    for 0..$palabra.chars - 1 {
        $palabra-rotada ~=  rotar-una-letra substr($palabra, $_, 1), $despl;
    }
    return $palabra-rotada;
}

my %palabras = map { $_ => 1}, 'lemario.txt'.IO.lines;

for %palabras.keys -> $cadena {
    for 1..13 -> $despl {
        my $rotada = rotar-una-palabra $cadena, $despl;
        say " $cadena y $rotada están desplazadas por $despl"
            if %palabras{$rotada}:exists;
    }
}
\end{verbatim}

Rotar cada palabra de una lista con alrededor de 88,000 palabras
por cada desplazamiento entre 1 y 13 es algo bien largo. 
Ejecutar el programa tomará algún tiempo, probablemente de 10 
a 15 minutos. Usar la función integrada \verb|.trans|
(see documentation in 
\url{https://docs.perl6.org/routine/trans}) podría acelerar
el proceso. Inténtalo y juzga por ti mismo.

\subsection{Exercise~\ref{homophones}: Homófonas (p.~\pageref{homophones})}
\label{sol_homophones}
\index{homophone}

Estamos buscando por palabras que \emph{suenan}
igual cuando removemos la primera o la segunda letra.

Esta es una solución que usa la lista de palabras \emph{words.txt}
usada anteriormente y el diccionario fonético CMU\footnote{Puedes
descargar el archivo aquí: \url{http://www.speech.cs.cmu.edu/cgi-bin/cmudict}}:
\index{CMU Pronouncing Dictionary}

\begin{verbatim}
my %fonético;

sub cargar-fonético( $nombre-archivo ) {
    for $nombre-archivo.IO.lines -> $linea {
        next if $linea !~~ /^\w/; 
        my ($clave, $val) = $linea.split("  ", 2);
        $clave = lc $clave;
        %fonético{$clave} = $val;
    }
}

cargar-fonético('cmu_dict.txt');
my %palabras = map { $_ => 1}, 'words.txt'.IO.lines;

say "Iniciando la búsqueda";

for %palabras.keys -> $palabra {
    next unless %fonético{$palabra}:exists;
    my $más-corta = $palabra.substr(1);
    next unless %palabras{$más-corta}:exists;
    next unless %fonético{$más-corta}:exists;
    next unless %fonético{$palabra} eq %fonético{$más-corta};
    my $otra-más-corta = $palabra.substr(0, 1) ~ $palabra.substr(2);
    next unless %palabras{$otra-más-corta}:exists;
    next unless %fonético{$otra-más-corta}:exists;
    next unless %fonético{$otra-más-corta} eq %fonético{$más-corta};
    say "$palabra $más-corta $otra-más-corta %fonético{$más-corta}"
}
\end{verbatim}

Pero esto es algo ineficiente porque actualmente no
necesitamos la lista de palabras, dado que el 
diccionario CMU es otra lista de palabras que podemos
usar (y no podemos usar palabras que aparecería en la
lista de palabras y no en el diccionario CMU, porque el
programa no sería capaz de averiguar cómo suenan). El
programa siguiente usa solo el diccionario CMU
y ahorra el tiempo de cargar la lista de palabras y
hacer chequeos en la misma:

\begin{verbatim}
my %fonético;

sub cargar-fonético( $nombre-archivo ) {
     $nombre-archivo.IO.lines -> $linea {
        next if $linea !~~ /^\w/; 
        my ($clave, $val) = $linea.split("  ", 2);
        $clave = lc $clave;
        %fonético{$clave} = $val;
    }
}

cargar-fonético('cmu_dict.txt');

for %fonético.keys -> $palabra {
    my $shorter = $palabra.substr(1);
    next unless %fonético{$más-corta}:exists;
    next unless %fonético{$palabra} eq %fonético{$más-corta};
    my $otra-más-corta = $palabra.substr(0, 1) ~ $palabra.substr(2);
    next unless %fonético{$otra-más-corta}:exists;
    next unless %fonético{$otra-más-corta} eq %fonético{$más-corta};
    say "$palabra $más-corta $otra-más-corta %fonético{$más-corta}"
}
\end{verbatim}



\section{Ejercicio del Capítulo~\ref{data_struct_sel}}

\subsection{Ejercicio de la Sección~\ref{given_when}: La Sentencia Switch {\tt given ... when}  (p.~\pageref{proceed_ex})}
\label{sol_proceed_ex}
\index{given statement}
\index{when statement}
\index{proceed clause}

Para usar la sentencia switch con varios valores, podrías
escribir algo como esto:

\begin{verbatim}
for <5 42 43 101 666 1024 2048> -> $valor {
    given $valor {
        when 0..9      { say "$_: Un dígito"}
        when 10..99    { say "$_: Dos dígitos" ; proceed; }
        when 42        { say "$_: Respuesta a la pregunta" }
        when /^\d**3$/ { say "$_: Tres dígitos" }
        default        { say "$_: Más de tres dígitos" }
    }
    say '';
}
\end{verbatim}

Esto mostrará el resultado siguiente:

\begin{verbatim}
5: Un dígito

42: Dos dígitos
42: Respuesta a la pregunta

43: Dos dígitos
43: Más de tres dígitos

101: Tres dígitos
(...)
\end{verbatim}

Puedes ver el error cuando el valor de entrada es 43.

Como una solución, es posible cambiar el orden de las cláusulas
{\tt when}:

\begin{verbatim}
for <5 42 43 101 666 1024 2048> -> $valor {
    given $valor {
        when 0..9      { say "$_: Un dígito"}
        when 42        { say "$_: Respuesta a la pregunta" }
        when 10..99    { say "$_: Dos dígitos" ; proceed; }
        when /^\d**3$/ { say "$_: Tres dígitos" }
        default        { say "$_: Más de tres dígitos" }
    }
    say '';
}
\end{verbatim}

Esto funciona perfectamente ahora, pero la salida para 42 
no está ya en el mismo orden. Si queremos mantener el orden 
original, necesitamos agregar una sentencia {\tt when} con
un bloque vacío:
\index{when statement}

\begin{verbatim}
for <5 42 43 101 666 1024 2048> -> $valor {
    given $valor {
        when 0..9      { say "$_: Un dígito"}
        when 10..99    { say "$_: Dos dígitos"; proceed; }
        when 42        { say "$_: Respuesta a la pregunta" }
        when 10..99    { }
        when /^\d**3$/ { say "$_: Tres dígitos" }
        default        { say "$_: Más de tres dígitos" }
    }
    say '';
}
\end{verbatim}

O podríamos remover la necesidad de {\tt proceed} al insertar
el código para el caso 42 en el bloque de dos dígitos;

\begin{verbatim}
for <5 42 43 101 666 1024 2048> -> $valor {
    given $valor {
        when 0..9      { say "$_: Un dígito"}
        when 10..99    { say "$_: Dos dígitos";
                         say "$_: Respuesta a la pregunta" if $_ == 42;
                       }
        when /^\d**3$/ { say "$_: Tres dígitos" }
        default        { say "$_: Más de tres dígitos" }
    }
    say '';
}
\end{verbatim}

Sería igualmente posible anidar la sub-expresión \verb|when|
dentro de la expresión \verb|when 10..99|:
\index{proceed clause}

\begin{verbatim}
for <5 42 43 101 666 1024 2048> -> $valor {
    given $valor {
        when 0..9      { say "$_: Un dígito"}
        when 10..99    { say "$_: Dos dígitos";
        when 42        { say "Respuesta a la pregunta"; }
        when /^\d**3$/ { say "$_: Tres dígitos" }
        default        { say "$_: Más de tres dígitos" }
    }
    say '';
}
\end{verbatim}

\subsection{Ejercicio de la Sección~\ref{operator_construction}: Creando Nuevo Operadores (p.~\pageref{fact_operator})}
\label{sol_fact_operator}
\index{factorial}
\index{factorial!operator}
\index{creating new operators}

El operador de negación \verb|"!"| es un operador prefijo (i.e., colocado
antes del término que niega). Para el operador factorial, necesitamos
un operador sufijo (colocado después del término sobre el cual actúa),
así que esta diferencia será suficiente para que el compilador 
de Perl pueda distinguir entre los dos operadores.

Usamos el metaoperador de reducción para computar el resultado:

\begin{verbatim}
sub postfix:<!> (Int $n) {
    [*] 2..$n;
}
say 5!; # -> 120
\end{verbatim}


\index{signature}
La signatura asegura que el operando es un entero (lo cual levanta
un error cuando falla). Podemos protegernos de un número negativo,
lo cual podemos hacer al levantar un error si un \verb|$n| es
negativo. Además, podemos usar el módulo estándar {\tt Test} 
para automatizar nuestras pruebas:
\index{test module}
\index{testing}

\begin{verbatim}
sub postfix:<!> (Int $n) {
    fail "El operando no es un número entero positivo" if $n < 0;
    [*] 2..$n
}
use Test;
plan 5;
dies-ok {(-1)!}, "Factorial falla para -1";
eval-dies-ok "(2.5)!", "Factorial falla para 2.5";
ok 0! == 1, "Factorial 0";
ok 1! == 1, "Factorial 1";
ok 5! == 120, "Factorial de un entero grande";
done-testing;
\end{verbatim}

\index{test plan}
La línea {\tt plan 5;} dice que el plan de prueba contiene 
cinco pruebas individuales. Después las dos primeras pruebas
chequean el operador factorial falla para valores de entrada
inválidos. Y chequea la salida por algunos valores de entrada.

La línea {\tt done-testing} especifica que la prueba ha finalizado.
Esta función es realmente útil cuando no tienes un plan, por ejemplo
cuando no sabes todavía cuantas pruebas ejecutarás. Aquí, tenemos un
plan, y el uso de {\tt done-testing}  no es necesario.
\index{done-testing}

La siguiente es la salida de las pruebas:

\begin{verbatim}
1..5
ok 1 - Factorial falla para -1
ok 2 - Factorial falla para 2.5
ok 3 - Factorial 0
ok 4 - Factorial 1
ok 5 - Factorial de un entero grande
\end{verbatim}

Si hubiésemos tenido un error de prueba en la prueba 3, 
habríamos obtenido algo como esto:

\begin{verbatim}
ok 1 - Factorial falla para -1
ok 2 - Factorial falla para 2.5
not ok 3 - Factorial 0

# Failed test 'Factorial 0'
# at test_fact.pl6 line 8
ok 4 - Factorial 1
ok 5 - Factorial de un entero grande
1..5
# Looks like you failed 1 test of 5
\end{verbatim}

En este ejemplo, hemos colocado las pruebas en el mismo archivo
que la definición de la subrutina por la simplicidad del ejemplo.
Normalmente, las pruebas estarían en un archivo separado usualmente
en un directorio llamado ``t``  y con una extensión \verb|.t| en el
archivo.

Pruebas y el módulo {\tt Test} serán discutidos en la Sección~\ref{test_module} (p.~\pageref{test_module}).
Más información sobre pruebas pueden encontrarse aquí:
\url{https://doc.perl6.org/language/testing}.

\subsection{Ejercicio de la Sección~\ref{sets_and_bags}: Sets, Bags y Mixes (p.~\pageref{diff_with_set})}
\label{sol_diff_with_set}
\index{set}
\index{bag}
\index{type!bag}
\index{baghash}
\index{type!baghash}

No podemos solamente reemplazar el \verb|%histogram| con un bag,
porque los \emph{bags} son inmutables (i.e., no pueden modificarse
después de su creación) y el hash \verb|%histograma| es poblado 
progresivamente a medida que las líneas del libro son leídas desde
el archivo. Podrías usar un \emph{baghash} (la versión mutable de
un bag) y se te anima que lo intentes.

Sin embargo, el objetivo aquí es extraer las palabras del libro
que no se encuentran en la lista de palabras. En otras palabras, 
no nos importa la frecuencia de las palabras sino que solo necesitamos
una lista única de palabras que aparecen por lo menos una vez en el
libro, así que un \emph{set} sería suficiente para satisfacer nuestras
necesidades. La pregunta es cómo poblamos el set al tiempo de creación.

Podemos cambiar la subrutina {\tt procesar-línea} para que 
procese la línea al igual que antes, pero en lugar de poblar un
hash, solo devuelve una lista de las palabras. Y podemos crear el
set con una función {\tt map} al llamar esa subrutina:

\begin{verbatim}
my $saltar = True;                       # bandera para saltar la cabecera
sub procesar-línea( Str $línea is copy ) {
    $saltar = False if defined index $línea, "*** START OF THIS PROJECT";
    return if $línea ~~ / Abela || anonymous / or $saltar; 
    $línea ~~ s:g/<['-]>/ /;             # Reemplazar guiones y 
                                         # apóstrofos con espacios
    $línea ~~ s:g/<[;:,¡!¿?«».()"_`]>//; # Remover signos de puntuación
    $línea = $línea.lc;                  # Convertir cadena a minúscula
    $saltar = True if $línea ~~ /^fin$/; # Marcar el final del libro
    return $línea.words;
}

my $set-libro      = set map { procesar-línea $_}, "quijote.txt".IO.lines; 
my $lista-palabras = set "lemario.txt".IO.lines;
my $palabras-desc  = $set-libro (-) $lista-palabras;
say $palabras-desc.keys.head(20);
\end{verbatim}

Esto funciona bien, pero una vez que hemos hecho eso, podemos
también deshacernos de la estructura de datos \verb|$set-libro|
y solamente filtrar directamente las palabras extraídas desde
el libro:

\begin{verbatim}
my $saltar = True; # bandera para saltar la cabecera
sub procesar-línea( Str $línea is copy ) {
    # (igual que la anterior)
}

my $lista-palabras = set "lemario.txt".IO.lines;
my @palabras-desc  = unique grep {$_ ∉ $lista-palabras}, 
                     grep { $_ }, 
                     map  { | procesar-línea $_},  
                     "quijote.txt".IO.lines; 
say @palabras-desc.head(20);
\end{verbatim}

La prueba de tal programa puede tomar algún tiempo, porque
tiene que procesar el libro completo cada vez. Para 
el propósito inicial de prueba, un consejo es reducir el monto
de datos de entrada para acelerar las pruebas. Podrías lograe
eso al prepara un archivo pequeño con un número limitado de
líneas del archivo original \emph{quijote.txt}. Otra forma
simple de hacerlo es leer solamente algunas líneas desde el libro,
lo cual puedes hacer con una rebanada en la línea de código
que leer el archivo. Por ejemplo, para leer solo las primeras
2,000~líneas del libro:

\begin{verbatim}
my @palabras-desc  = unique grep {$_ ∉ $lista-palabras}, 
                     grep { $_ }, 
                     map  { | procesar-línea $_},  
                     ("quijote.txt".IO.lines)[0..1999];
\end{verbatim}

Esto puede también usarse para eliminar la cabecera. Dado que 
el texto actual del libro comienza en la línea 37, podemos tener
algo como esto:

\begin{verbatim}
my @palabras-desc  = unique grep {$_ ∉ $lista-palabras}, 
                     grep { $_ }, 
                     map  { | procesar-línea $_},  
                     ("quijote.txt".IO.lines)[37..1999];
\end{verbatim}
y remover de {\tt procesar-línea} el código para saltar la cabecera.
Sin embargo, aún necesitamos una bandera que indique el final del libro:

\begin{verbatim}
my $final = False;                       # Marcar el final del texto
sub procesar-línea( Str $línea is copy ) {
    return if $final;
    $línea ~~ s:g/<['-]>/ /;             # Reemplazar guiones y apóstrofos con espacios
    $línea ~~ s:g/<[;:,¡!¿?«».()"_`]>//; # Remover signos de puntuación
    $línea = $línea.lc;                  # Convertir cadena a minúscula
    $final = True if $línea ~~ /^fin$/;  # Marcar el final del libro
    return $línea.words;
}
\end{verbatim}


\subsection{Ejercicio de la Sección~\ref{randomwords}: Palabras Aleatorias (p.~\pageref{randhist})}
\label{sol_randhist}
\index{histogram!random choice}

Hemos creado un módulo {\tt BusquedaBinaria} que contiene una
subrutina {\tt bisectar}. Sería grandioso reutilizarla, pero no
podemos porque hace actualmente comparaciones de cadenas de texto
y necesitamos comparaciones numéricas.

La mejor solución ahora es probablemente hacer una copia de
las subrutina y modificarla para hacer comparaciones numéricas.
Las subrutinas pueden tener el mismo nombre provisto que sean
declaradas como subrutinas multi y tenga signatura diferente:
el primer parámetro de la nueva subrutina multi debería ser {\tt Int}
en lugar de {\tt Str}. Debido que los cambios hechos son bien 
minúsculos y fáciles, esto se deja como un ejercicio al lector.
\index{signature}

El programa usando ese módulo podría lucir así:

\begin{verbatim}
use lib ".";
use BusquedaBinaria;
my %histograma;

my $final = False;
sub procesar-línea( Str $línea is copy ) {
    return if $final;
    $línea ~~ s:g/<['-]>/ /;
    $línea ~~ s:g/<[;:,¡!¿?«».()"_`]>//;
    $línea = $línea.lc;
    $final = True if $línea ~~ /^fin$/;
    return $línea.words;
}

%histograma{$_}++ for grep {$_},
                      map { | process-line $_}, 
                      ("quijote.txt".IO.lines)[253..*]; 
my (@palabras, @frecuencias);
my $frec_total = 0;
for %histograma.kv -> $palabra, $frec {
    $frec_total += $frec;
    push @palabras, $palabra;
    push @frecuencias, $frec_total;
}
my $entero_aleat = $frec_total.rand.Int;
my $idx = bisectar ~$entero_aleat, @frecuencias;
say @palabras[$idx] if $idx >= 0;
\end{verbatim}

\subsection{Ejercicio de la Sección~\ref{markov}: Análisis de Markov (p.~\pageref{markov_analysis})}
\label{sol_markov_analysis}
\index{Markov analysis}

Antes de presentar nuestra solución al ejercicio, queremos 
hacer una introducción breve de una funcionalidad que es
útil para extraer y validar los argumentos de la línea de comando
pasados a un programa: la subrutina {\tt MAIN}.

\subsubsection{La subrutina {\tt MAIN}}
\label{MAIN_sub}
\index{MAIN}
\index{program!argument}
\index{argument!to the program}
\index{command-line argument}
\index{argument!command-line}

Los argumentos pasados a un programa son usualmente almacenados 
en el array especial \verb|@*ARGS|. Puedes navegar los artículos de este
array para extraer los argumentos. El siguiente one-liner es un 
un ejemplo de esto:
\index{one-liner mode}

\begin{verbatim}
$ perl6 -e 'say $_ for reverse @*ARGS' uno dos tres
tres
dos
uno
\end{verbatim}

No obstante, hay otra forma de hacerlo, la subrutina {\tt MAIN}
que discutimos brevemente en la Sección~\ref{MAIN}(p.~\pageref{MAIN}).
Si hay una subrutina llamada {\tt MAIN} en el programa, entonces
el programa comenzará a ejecutar esta subrutina, cuyos parámetros
serán los argumentos pasados al programa en la línea de comando. Esto 
significa que la signatura de {\tt MAIN} hará posible la extracción de
parámetros y chequear su validez.

En nuestra solución más abajo, la subrutina {\tt MAIN} está declarada
como sigue:

\begin{verbatim}
sub MAIN( Str $libro, Int $cuenta-palabras, Int $orden = 2, 
            Int $linea-inicio = 0) {
    # cuerpo de la subrutina va aquístart-line
}
\end{verbatim}

El programa chequeará que los argumentos pasados al mismo 
coincide con la signatura de la subrutina {\tt MAIN}. En el ejemplo,
el primer parámetro tiene que ser una cadena de texto y el segundo
un entero; el tercero y el cuarto son opcionales y tendrán valores
por defecto de 2 y 0 respectivamente si los argumentos correspondientes
no son proveídos.
\index{signature}

Si los argumentos pasados al programa no coinciden con la signatura
de {\tt MAIN}, el programa terminará después de imprimir un mensaje
de uso generado automáticamente:

\begin{verbatim}
$ perl6  markov.pl6 emma.txt 100 2 foo
Usage:
  markov.p6 <libro> <cuenta-palabras> [<orden>] [<linea-inicio>]
\end{verbatim}
El parámetro \verb|$linea-inicio| tiene que ser un número entero.
Dado que el argumento correspondiente (``foo``) no es un entero, 
el programa muestra un mensaje que detalla el uso del programa.

Validar los argumentos de la línea de comando pasados a un programa
puede ser algunas veces una tarea tediosa. Pero, con el mecanismo 
de signatura de la subrutina {\tt MAIN}, puede usualmente reducirse
a una sola línea de código, la signatura {\tt MAIN}.

\subsubsection{Solución al ejercicio sobre el análisis de Markov}
\index{Markov analysis}

Esta es una manera posible de realizar una análisis de Markov 
de un archivo de texto:

\begin{verbatim}
my %prefijos;

sub MAIN( Str $libro, Int $cuenta-palabras, Int $orden = 2, 
          Int $linea-inicio = 0)
{
    procesar-línea($orden, $_) for ($libro.IO.lines)[$linea-inicio..*]; 
    say crear-texto($orden, $cuenta-palabras);
}

my $final = False;
sub procesar-línea( $orden, Str $linea is copy ) {
    return if $final;
    $linea ~~ s:g/<[-']>/ /; 
    $linea ~~ s:g/<[;:,!?.()"_`]>//;  # removiendo signos de puntuación
    $linea = $linea.lc;               # convirtiendo a minúsculas
    return unless $linea ~~ /\w/;
    procesar-palabras($orden, $linea.words);
    $final = True if $linea ~~ /^fin$/;
}

sub procesar-palabras( $orden, @palabras-nuevas ) {
    state @buffer-palabras = ();
    push @buffer-palabras, |@palabras-nuevas;
    while (@buffer-palabras.elems >= $orden * 2) {
        my $clave = @buffer-palabras.shift ~ " " ~ 
             (join ' ', @buffer-palabras[0..$orden - 2]);
        my $valor = @buffer-palabras[$orden -1];
        push %prefijos{$clave}, $valor;
    }
}

sub crear-texto( Int $orden, Int $cuenta-palabra ) {
    my @prefijo = %prefijos.keys.pick.words;
    my $cuenta  = 0;
    my $texto   = join " ", @prefijo;
    while $cuenta <= $cuenta-palabra {
        my @sufijos-posibles = |%prefijos{join " ", @prefijo};
        last unless @sufijos-posibles;
        my $palabra-nueva = |@sufijos-posibles.pick;
        $texto ~= " $palabra-nueva";
        shift @prefijo;
        push @prefijo, |$palabra-nueva;
        $cuenta++
    }
    return $texto;
}     
\end{verbatim}

Este programa puede ser llamado en el archivo  \emph{quijote.txt} con la
siguiente sintaxis:

\begin{verbatim}
$ perl6  markov.pl6 quijote.txt 100 2 253
\end{verbatim}

o usando \emph{emma.txt}:
\begin{verbatim}
$ perl6  markov.pl6 emma.txt 50 3 300
\end{verbatim}

\subsection{Ejercicio sobre Código Huffman de la Sección~\ref{huffman_exercise} (p.~\pageref{huffman_exercise})}

\subsubsection{La Tabla de Frecuencia (Sección~\ref{letter_frequency})}
\label{sol_letter_frequency}
\index{frequency!table}

Hemos ya visto problemas similares a este. Esta es una solución
posible usando el modelo de programación de tuberías que describimos
en la Sección~\ref{most_common_words} (page~\pageref{most_common_words}):
\index{pipe-line programming}

\begin{verbatim}
my %frecuencias;
%frecuencias{$_}++ for grep {/<[a..z]>/}, map {.lc}, 
    "goldbug.txt".IO.lines.comb;
my $cuenta_total = [+] values %frecuencias;
say "$_ :\t%frecuencias{$_} \t", 
    sprintf "%5.2f", %frecuencias{$_}*100/$cuenta_total 
    for reverse sort {%frecuencias{$_}}, %frecuencias.keys;
\end{verbatim}   

Esto muestra:
\begin{verbatim}
e :     7625    13.10
t :     5485     9.42
a :     4477     7.69
o :     4208     7.23
i :     4183     7.18
n :     3912     6.72
s :     3516     6.04
h :     3372     5.79
r :     3278     5.63
d :     2533     4.35
l :     2324     3.99
u :     1893     3.25
c :     1523     2.62
m :     1499     2.57
f :     1392     2.39
w :     1303     2.24
p :     1169     2.01
y :     1146     1.97
g :     1143     1.96
b :     1031     1.77
v :     525      0.90
k :     351      0.60
x :     120      0.21
j :     111      0.19
q :     60       0.10
z :     44       0.08
\end{verbatim}

Recuerda que el personaje de Edgar Allan Poe declaró que la
sucesión de letras más comúnmente utilizadas en inglés es 
como sigue:
\index{Poe, Edgar Allan}

\begin{verbatim}
e a o i d h n r s t u y c f g l m w b k p q x z
\end{verbatim}

Al parecer el personaje de Poe estaba aproximadamente correcto,
pero no del todo cierto, en su estimados de las frecuencias
de las letras en un texto en inglés. Aparentemente él subestimó
la frecuencia de la letra ``t``. Si ejecutamos el mismo programa
con el texto de la novela \emph{Emma} de Jane Austen que hemos usado
previamente, obtenemos resultados muy similares:

\begin{verbatim}
e :     87029   12.57
t :     60035    8.67
a :     54884    7.93
o :     53877    7.78
n :     47773    6.90
i :     47172    6.82
s :     42920    6.20
h :     42819    6.19
r :     41453    5.99
d :     28870    4.17
l :     27971    4.04
(...)
\end{verbatim}

\subsubsection{Código Huffman de una Cadena de ADN (Sección~\ref{huffman_code_2})}
\label{sol_huffman_code_2}
\index{Huffman!code}
\index{DNA (deoxyribonucleic acid)}

En cada paso del algoritmo, necesitamos buscar las dos letras
menos frecuentes. En lugar de tener que iterar a través de todos
los artículos en el hash de frecuencia (o ordenar los valores 
cada vez), usaremos una estructura de datos que mantiene los
valores ordenados de acuerdo a nuestras necesidades.

Comenzamos con el hash \verb|%frecuencia| construido en el ejercicio
previo y lo transformamos en una colección ordenada de pares que
mapean cada letra a su frecuencia respectiva. Creamos una subrutina
{\tt insertar-par} que agrega los pares creados recientemente (las letras ficticias)
en el lugar correcto del array de pares para mantener el array ordenado
de acuerdo a nuestras necesidades:

\index{array!of pairs}
\index{pair}

\begin{verbatim}
my %código;
my @pares;
push @pares, $_ => %frecuencias{$_} for 
    sort {%frecuencias{$_}}, %frecuencias.keys;

sub insertar-par( @lista, $nuevo-elemento) {
    my $val = $nuevo-elemento.value;
    for @lista.keys -> $i {
        if @lista[$i].value >= $val {
            splice @lista, $i, 0, $nuevo-elemento;
            return;
        }
    }
    push @lista,$nuevo-elemento; # poner el elemento nuevo al final
                                 # de la lista si el lugar correcto
                                 # no se encontró anteriormente
}
\end{verbatim}

Iteramos sobre los pares, elegimos los dos con las frecuencias
más pequeñas, los unimos en un par nuevo, y agregamos dicho par
en lugar correcto con la subrutina {\tt insertar-par}. El bucle
termina cuando hay solamente dos pares restantes. Al mismo tiempo,
poblamos en cada paso del bucle el nuevo hash \verb|%código| con
los códigos parciales encontrados:

\begin{verbatim}
loop {
    my $menor1 = shift @pares;
    my $menor2 = shift @pares;
    my $par-nuevo = $menor1.key ~ $menor2.key => $menor1.value + $menor2.value;
    insertar-par @pares, $par-nuevo;
    %código{$menor1.key} =  $menor1.key ~ $menor2.key ~ "|.";
    %código{$menor2.key} =  $menor1.key ~ $menor2.key ~ "|-";
    last if @pares <= 2;
}
%código{@pares[0].key} = ".";
%código{@pares[1].key} = "-";
\end{verbatim}

Al final del bucle, el array de pares contienes dos pares:

\begin{verbatim}
[c => 10 tga => 11]
\end{verbatim}

y el hash \verb|%código| contienes los códigos parciales 
para letra o letra ficticia:

\begin{verbatim}
{a => ga|-, c => ., g => ga|., ga => tga|-, t => tga|., tga => -}
\end{verbatim}

Después usamos otro bucle para sustituir las letras falsas y deshacernos
de ellas, hasta que quedemos con las letras actuales de la cadena de
texto original:

\begin{verbatim}
loop {   
    my $hecho = True;
    for %código.keys -> $letra {
        next if $letra.chars > 1;
        my ($val, $código) = split '|', %código{$letra};
        next unless defined $val and defined $código;
        $hecho = False;
        my $result = %código{$val} ~ $código;
        %código{$letra} = $result;
    }
    last if $hecho;
}
my %codificar;
%codificar{$_} = %código{$_} for grep {$_.chars < 2 }, %código.keys;
\end{verbatim}

El hash \verb|%codificar| contiene la tabla de Huffman:
\index{Huffman!table}
\index{DNA (deoxyribonucleic acid)}

\begin{verbatim}
c => .
t => -.
g => --.
a => ---
\end{verbatim}

\subsubsection{Código Huffman para una Cadena de Texto Más Compleja (Sección~\ref{huffman_code_2})}

Para esta pregunta, necesitaremos un párrafo pequeño escrito especialmente
con un solamente algunas letras del alfabeto:

\begin{quote}
Eastern Tennessee anteaters ensnare and eat red ants, detest ant
antennae (a tart taste) and dread Antarean anteater-eaters. Rare
Andean deer eat tender sea reeds, aster seeds and rats’ ears. Dessert?
Rats’ asses.
\end{quote}

Como primer paso, simplificaremos un poco el problema al convertir
todas la letras a minúsculas y usar solo las letras, eliminando 
espacios y puntuación de la computación de la tabla de frecuencia:

\begin{verbatim}
my $cadena = "Eastern Tennessee anteaters ensnare and eat red ants, detest ant
antennae (a tart taste) and dread Antarean anteater-eaters. Rare
Andean deer eat tender sea reeds, aster seeds and rats’ ears. Dessert?
Rats’ asses."; 

my %frecuencias;
%frecuencias{$_}++ for grep { /\w/ }, $cadena.lc.comb;
\end{verbatim}

Este tratado muy elocuente sobre el hábito alimenticio de varios
animales produce la tabla de frecuencias siguiente:
\index{frequency!table}

\begin{verbatim}
e :     40      23.53
a :     32      18.82
t :     24      14.12
s :     22      12.94
n :     20      11.76
r :     19      11.18
d :     13      7.65
\end{verbatim}

Usando el mismo código al igual que en la pregunta anterior genera
la tabla de Huffman siguiente:
\index{Huffman!table}

\begin{verbatim}
a => ..
e => .-
s => -.-
n => -..
t => --.
d => ---.
r => ----
\end{verbatim}

\subsubsection{Codificando la Cadena de Texto de Entrada (Sección~\ref{huffman_code_2})}
\index{Huffman!encoding}

No solo queremos codificar una cadena de texto de entrada con el código Huffman
sino que también queremos ser capaces de decodificarla y reconocer la
entrada original. Debido a eso, ya no queremos filtrar la puntuación de la
tabla de traducción, la cual será más grande que antes. Los espacios (
espacios horizontales y retornos de línea) serán manejados diferentemente:
no los modificaremos en la cadena de texto codificada de pseudo-Morse,
dado que esto hará más fácil de chequear y mostrar el resultado. 
 
La tabla de frecuencias ahora incluye signos de puntuación que existen
en la cadena de texto de entrada:

\begin{verbatim}
%frecuencias{$_}++ for grep {/<[\w] + [.,()’?-]>/}, $cadena.lc.comb;
\end{verbatim}

La tabla de frecuencias tiene 14 entradas ahora:
\index{frequency!table}

\begin{verbatim}
e :     40      22.10
a :     32      17.68
t :     24      13.26
s :     22      12.15
n :     20      11.05
r :     19      10.50
d :     13       7.18
. :     3        1.66
, :     2        1.10
’ :     2        1.10
) :     1        0.55
- :     1        0.55
? :     1        0.55
( :     1        0.55
\end{verbatim}

Y la tabla de Huffman (hash \verb|%codificar|) luce así:
\index{Huffman!table}

\begin{verbatim}
e => .-
a => ---
s => -..
n => ..-
t => --.
r => ...
d => -.--
. => -.-.-.
( => -.-..-.
’ => -.-.--.
? => -.-..--
) => -.-...-
- => -.-....
, => -.-.---
\end{verbatim}

La subrutina de codificación es bastante simple:

\begin{verbatim}
sub codificación( Str $entrada, %codificar ) {
    my $salida;
    for $entrada.lc.comb -> $letra {
        $salida ~= %codificar{$letra} // $letter;
    }
    return $salida;
}
\end{verbatim}

Cada letra de la entrada es convertida a letras minúsculas (dado
que hemos limitado nuestra tabla a minúsculas), traducida a su 
código equivalente de pseudo-Morse , y concatenada a la cadena de 
texto de salida. Si la letra no se encuentra en el hash \verb|%codificar|,
entonces se almacena en la salida tal como es: esto posibilita la
inserción de espacios y caracteres de final de línea en la cadena
de texto de salida.
\index{pseudo-Morse}
\index{case!lower}

Aquí presentamos el resultado (formateado para adaptarlo al libro):
\begin{verbatim}
.-----..--..-.....- --..-..-..-.--..-...-.- ---..---..------..-...-..
.-..--....----....- ---..--.-- .------. ....--.-- ---..---.-..-.-.---
-.--.---..--..--. ---..---.
---..---..-..-..----.- -.-..-.--- --.---...--. --.----..--..--.-...- 
---..--.-- -.--....-----.-- ---..---.---....----..-
---..---..------..-...-.-.....------..-...-..-.-.-. ...---....-
---..--.--.----..- -.--.-.-... .------. --..-..--.--.-... -...----
 ....-.--.---..-.-.--- ----..--..-... -...-.--.---.. ---..--.-- 
 ...-----.-..-.-.--. .----...-..-.-.-. -.--.--..-...-...--.-.-..--
...-----.-..-.-.--. ----..-...--..-.-.-.
\end{verbatim}

Interesantemente, la cadena de texto de entrada tiene 213 caracteres
y la cadena de texto de salida tiene 589~bits. Si estuviéramos almacenando
14 caracteres diferentes de la cadena de entrada con códigos de igual 
longitud, necesitaríamos cuatro bits por carácter, lo cual requeriría
1052~bits. Así que el código Huffman logró esto: un razón de compresión 
1.78 mejor que los mejores códigos de igual longitud. Y la codificación 
ASCII de la cadena de texto de entrada requirió 213~bytes, i.e., 1704~bits;
la salida codificada requirió menos de tres veces menos que eso.

\subsubsection{Decodificando la Cadena de Texto Pseudo-Morse (Sección~\ref{huffman_code_2})}
\index{Huffman!decoding}

Para decodificar eficientemente la cadena de texto pseudo-Morse,
necesitamos invertir la tabla de Huffman, i.e., crear un hash en 
el cual los códigos pseudo-Morse son las claves y las letras son los
valores. Invertir el hash \verb|%codificar| es algo bien directo:
\index{reverse}

\begin{verbatim}
my %decodificar = reverse %codificar.kv;
\end{verbatim}

\index{reverse}
La expresión \verb|%codificar.kv| produce una lista de claves y valores,
y la sentencia reverse la transforma en una lista de valores y claves.
Asignar esa lista a un hash nuevo produce un hash nuevo en el cual 
las claves y los valores son intercambiados. Nota que esto funciona
porque sabemos que los valores son únicos, así que no hay ningún
problema de duplicados cuando los convertimos en claves del hash.

Decodificar la cadena de texto pseudo-Morse es un poco más complicado
que codificarla, porque no sabemos con antelación cuántos puntos y rayas
serán necesarios para obtener una letra. Así que necesitamos observar
el primer carácter (por ejemplo un punto) de la cadena de texto pseudo-Morse.
Si este carácter solo constituye un entrada en la tabla de traducción, 
entonces hemos encontrado nuestra primera letra, y podemos comenzar
de nuevo con el siguiente carácter como un punto de inicio para la
letra siguiente; por el contrario, necesitamos escoger el siguiente carácter
y ver si los dos primeros caracteres conjuntamente forman una entrada; si 
forman una entrada, hemos encontrado una letra y podemos comenzar de nuevo 
con el siguiente carácter; si no forman una entrada, necesitamos chequear si
los tres primeros caracteres forman conjuntamente una entrada en la
tabla, etc.

\index{pseudo-Morse}
Por ejemplo, con el inicio de la cadena de texto pseudo-Morse:
\begin{verbatim}
.-----..--..-.....-
\end{verbatim}
el primer punto no es una entrada pero la combinación \verb|".-"| es una \verb|"e"|.
La siguiente raya no es una entrada y tampoco lo es \verb|"--"|, pero 
\verb|"---"| es una \verb|"a"|.

La siguiente raya no es una entrada y tampoco lo es \verb|"-."|, pero \verb|"-.."|
es una \verb|"s"|. Similarmente, los tres caracteres siguientes, \verb|"--."|,
forman una \verb|"t"|, y podemos decodificar la letra \verb|"eastern"|.

Podríamos implementar esto con dos bucles anidados: uno itera a través 
de la cadena de texto y el segundo consume el número necesario de puntos
y rayas hasta el final de una letra:

\begin{verbatim}
sub decodificación( Str $entrada, %decodificar ) {
    my @códigos = $entrada.comb;
    my $salida;
    loop {
        last unless @códigos;
        my $actual = shift @códigos;
        $salida ~= $actual and next if $actual ~~ /\s/;
        $salida ~= %decodificar{$actual} and 
                   next if %decodificar{$actual}:exists;
        
        loop {           # necesitamos más caracteres para completar la letra
            $actual ~= shift @códigos;
            if %decodificar{$actual}:exists {
                $salida ~= %decodificar{$actual};
                last;    # finalizamos con una letra, 
                         # devuelta al bucle principal
            }
        } 
    }
    return $salida;
 }
\end{verbatim}

Esto funciona apropiadamente y la salida es la misma que 
la entrada original (excepto por el hecho de que todas las letras
son minúsculas):

\begin{verbatim}
eastern tennessee anteaters ensnare and eat red ants, detest ant
antennae (a tart taste) and dread antarean anteater-eaters. rare
andean deer eat tender sea reeds, aster seeds and rats’ ears. dessert?
rats’ asses.
\end{verbatim}

No obstante, si lo analizas, no necesitamos dos bucles anidados
en la subrutina {\tt decodificación}, la cual podemos hacerla
más concisa en la siguiente manera:

\begin{verbatim}
sub decodificación( Str $entrada, %decodificar ) {
    my ($salida, $actual);
    for $entrada.comb -> $cod-ent {
        $salida ~= $cod-ent and next if $cod-ent ~~ /\s/;
        $actual ~= $cod-ent;
        if %decodificar{$actual}:exists {
            $salida ~= %decodificar{$actual};
            $actual = "";
        }
    }
    return $salida;
}
\end{verbatim}

Aquí, la variable \verb|$actual| acumula los puntos y las rayas
de la cadena de entrada hasta se determina que es una entrada en la tabla
de traducción, en cuyo momento se reinicia a una cadena de texto vacía
para prepararla para la letra siguiente.

La solución presentada más arriba para encontrar el código Huffman
usa la subrutina {\tt insertar-par} para mantener el array de pares
\verb|@pares| ordenado. Esto hace fácil encontrar las letras 
restantes menos comunes o pseudo-letras. Podrías recordar de la
Sección~\ref{heap} que los montículos binarios son estructuras de 
datos grandiosas cuyo objetivo es acceder rápidamente los artículos 
más pequeños de una colección. Como un ejercicio adicional, podrías
escribir la solución nuevamente usando un montículo binario. La
solución original de David Huffman actualmente usó un árbol (llamado
el árbol de Huffman) muy similar a un montículo binario.
\index{heap} 
\index{Huffman!code}
\index{Huffman!tree}



%\section{Ejercicios del Capítulo~13: Regexes y Gramáticas}
\section{Ejercicios del Capítulo~\ref{regex_grammars}: Regexes y Gramáticas}

\subsection{Ejercicio de la Sección~\ref{february_rule}: Obteniendo las Fechas de Febrero Correctamente (p.~\pageref{february_rule})}
\label{sol_february_rule}
\index{February!number of days}
\index{grammar!date}
\index{leap year}

Queremos chequear si las fechas de febrero son válidas.

Para comenzar, excluyamos las fechas de febrero que son 
mayores que 29. Esto puede hacerse al expandir la aserción
de código mostrada en el código para reconocer las fechas:

\begin{verbatim}
my $cadena = "Día bisiesto : 2016-02-29.";                                         
my token año { \d ** 4 }                                        
my token mes {   
    1 <[0..2]>                            # 10 a 12                     
    || 0 <[1..9]>                         # 01 a 09                     
};
my token día { (\d ** 2) <?{1 <= $0 <= 31 }> }  
my token sep { '/' || '-' }                                                 
my rule fecha { [   <año> (<sep>) <mes> $0 <día> 
                 || <día> (<sep>) <mes> $0 <año> 
                 || <mes>\s<día>',' <año>
                ] <!{ ($<día> > 30 and $<mes> ==  4|6|9|11) or 
                       $<día> > 29 and $<mes> eq '02' }>
}                         

if $cadena ~~ /<fecha>/ {
    say ~$/;                              # 2016-02-29
    say "Día\t= "  , ~$/<fecha><día>;     # 29
    say "Mes\t= "  , ~$/<fecha><mes>;     # 02
    say "Year\t= " , ~$/<fecha><año>;     # 2016
}                    
\end{verbatim}

Esto funciona. Febrero tiene 29 días dado que 2016 es un
año bisiesto. Pero este código validaría Feb. 29 para 2015 o
2017, lo cual es incorrecto dado que no son años bisiestos.

\subsubsection{Reconociendo un año bisiesto}
\index{leap year}

\index{Julian calendar}
En el calendario Juliano antiguo (en honor a Julio César),
los años bisiestos son años que son divisibles por 4. Resultó que 
que el calendario Juliano tenía muchos años bisiestos para reflejar 
la realidad astronómica, así que el calendario retrocedió
alrededor de 3 días por cada período de cuatro siglos.
\index{Caesar, Julius}

\index{Gregorian calendar}
El calendario Gregoriano, introducido por el Papa Gregorio~XIII
en 1582, corrigió el calendario Juliano con la siguiente regla
adicional: años divisibles por 100 deberían considerarse años bisiestos
solo si son divisibles por 400. Así que, para el calendario Gregoriano,
1700, 1800, 1900, y 2100 no son bisiestos pero 2000 y 2400 si lo son.
\index{Gregory XIII, Pope}

Dependiendo del tipo de fechas que tu programa encontrará,
puedes simplificar las reglas. Si está escribiendo un módulo
que está supuesto a ser preciso con cualquier fecha del pasado
o futuro, probablemente quieres implementar la regla Gregoriana
exacta. Pero si sabes que vas a encontrar fechas del período 
actual, podrías elegir una regla mucho más simple.

\index{Y2K bug}
En particular, dado que 2000 es una excepción a la excepción
y es bisiesto, cualquier año entre 1901 y 2099 es bisiesto si
es divisible por 4 y no bisiesto por el contrario. Esta reglas
es probablemente suficiente para cualquier aplicación de negocios
escrita en 2017. Probablemente no hay razón para  hacerlo más
complicado de lo que necesita ser (aunque podría argumentarse
que es el tipo de razonamiento que condujo al gran terror del 
error ``Y2K``).

Con esta simplificación en mente, una subrutina para encontrar
si un año es bisiesto debería simplemente devolver verdadero
si es divisible por 4 y podría lucir así:
\index{leap year}

\begin{verbatim}
sub es-bisiesto( $año ) { # funciona para los años entre 1901 y 2099
    return True if $año %% 4; 
    return False;
}
\end{verbatim}

O más simple:
\begin{verbatim}
sub es-bisiesto( $año ) { # funciona para los años entre 1901 y 2099
	return $año %% 4; 
}
\end{verbatim}

Si quieres implementar la regla Gregoriana completa,
podría lucir así:

\begin{verbatim}
sub es-bisiesto( $año ) { # regla Gregoriana para cualquier año
    return False if $año % 4;    # no si no es divisible por 4
    return True  if $año % 100;  # sí si divisible por 4  y no por 100
    return False if $año % 400;  # no si divisible por 100 y no por 400
    True;                        # sí si divisible por 400
}
\end{verbatim}

o, si te gusta ser conciso (o la ofuscación):

\begin{verbatim}
sub es-bisiesto($a) { $a %% 400 or ($a %% 4 and not $a %% 100) }
\end{verbatim}

El código más arriba es dado como un ejemplo acerca de
cómo computar si un año es bisiesto, dado que es un problema
interesante y clásico, pero Perl actualmente provee un método
para eso en el rol {\tt Dateish}. Por ejemplo:
\index{is-leap-year function}

\begin{verbatim}
> say Dateish.is-leap-year(2016)
True
> say Dateish.is-leap-year(2015)
False
\end{verbatim}

\subsubsection{De Regreso a la validación de fechas de febrero}
\index{date!validation}

\emph{Puedes} agregar las reglas para Feb.~29 en el ejemplo 
de código más arriba, pero sugerimos que esto se está
complicando  para una aserción de código dentro de la
regla {\tt fecha}: agregar una condición Booleano en una
aserción de código dentro de una regla está bien, pero
cuando la condición se vuelve más complicada, esto causa
que la regla sea difícil de entender. Piensa sobre la persona
que tendrá que mantener tu código dentro de una año (y esa
persona podría ser tú).

Preferimos mover el código que realiza la validación 
fuera de la regla {\tt fecha} a una subrutina dedicada
a chequear todas las fechas para febrero:

\begin{verbatim}
sub feb-fecha-inválida( $año, $día ) {
    return False if $día <= 28;
    return True  if $día > 29;
    return False if Dateish.is-leap-year($año);
    True;
}
\end{verbatim}

La regla {\tt fecha} lucí ahora así:

\begin{verbatim}
my rule fecha { [   <año> (<sep>) <mes> $0 <día> 
                 || <día> (<sep>) <mes> $0 <año> 
                 || <mes>\s<día>',' <año>
               ] <!{ ($<día> > 30 and $<mes> ==  4|6|9|11) or 
                     $<mes> eq '02' and feb-fecha-inválida $<año>, $<día>}>
} 
\end{verbatim}

Originalmente llamé la subrutina nueva {\tt chequear-feb-29}
pero la cambié a {\tt feb-fecha-inválida} para mostrar mejor
que devuelve un valor verdadero si la fecha no es válida. 
Esto puede parecer secundario, pero elegir nombres buenos 
para tus identificadores es importante porque eso documenta 
tus programas y clarifica sus semánticas.

Una vez que hemos introducido esta mínima subrutina, podríamos
ir un paso más allá y mover el resto de la aserción de código
dentro de la subrutina, para que la aserción de código final
contenga solo una llamada a la nueva versión de la subrutina.
Esto se deja como un ejercicio adicional al lector.

\subsection{Ejercicio~\ref{calculator} (p.~\pageref{calculator}): 
Una Gramática para una Calculador Aritmética}
\label{sol_calculator}
\index{calculator}
\index{arithmetic calculator}
\index{grammar!arithmetic calculator}
\index{calculator!grammar}

Aquí presentamos una forma posible de implementar una calculadora
aritmética.

\subsubsection{La Gramática}

Esta es una manera de escribir la gramática:
\index{grammar}
\index{token}
\index{rule}

\begin{verbatim}
my grammar Calculadora {
    rule TOP            { <expr> }
    rule expr           { <término> + % <op-suma-sust> }
    token op-suma-sust  { [< + - >] }
    rule término        { <átomo> + % <op-mult-div> }
    token op-mult-div   { [< * / >] }
    rule átomo {
        | <número>      { make +$<número> }
        | <expr-paren>  { make $<expr-paren>.made }
    }
    rule número         { <signo> ? [\d+ | \d+\.\d+ | \.\d+ ] }
    rule expr-paren     { '(' <expr> ')' }
    token signo         { [< + - >] }
}
\end{verbatim}

Esta solución es bien simple.

Una expresión (\verb|expr|) está compuesta por uno o varios
términos separados por los operadores ``+`` o ``-''. Un término
está compuesto por uno o varios átomos separados por los
operadores ``*'' o ``/''. Un átomo puede ser un número literal
o una expresión entre paréntesis.

\index{precedence}
Esto garantiza que las reglas de precedencia sean satisfecha.
Las multiplicaciones y las divisiones serán evaluadas antes que 
las adiciones y las sustracciones, dado que, al analizar sintácticamente
una expresión, necesitas los términos individuales antes de completar 
la evaluación de la expresión. Similarmente, dado que la expresión
entre paréntesis es una átomo, tendrá que ser evaluada antes que el término
en el cual aparece sea completamente evaluado. Nota que, en el caso 
de una expresión entre paréntesis, la regla \verb|expr| es llamada
recursivamente.
\index{recursion}

\subsubsection{Las Acciones}
\index{actions!class}
\index{rule}

Nota que hemos incluido dos acciones en la gramática (en la
regla {\tt átomo}). Una razón para hacer eso es por conveniencia:
dado que la regla {\tt átomo} cubre dos sub-reglas nombradas
diferentes, es un poco más fácil incluir la acción solo en el 
contexto de las sub-reglas. Si una acción se había adjuntado a
la regla {\tt átomo}, la regla hubiese requerido encontrar cual sub-regla
había coincidido para saber cual acción debía realizar. 
Nada difícil, pero hacer esto habría hecho el código mucho más complejo.
La otra razón para hacerlo es por propósito pedagógicos: aunque algunas
veces hace sentido crear una clase de acciones, es igualmente útil 
saber que las acciones pueden insertarse en la parte de la gramática.
Para un gramática bien simple, podría ser innecesario crear una clase 
de acciones con solo una o dos acciones.
\index{grammar}

La clase de acciones podría lucir así:

\begin{verbatim}
class AccionesCalc {
    method TOP ($/) {
        make $<expr>.made
    }
    method expr ($/) {
        $.calcular($/, $<término>, $<op-suma-sust>)
    }
    method término ($/) {
        $.calcular($/, $<átomo>, $<op-mult-div>)
    }
    method expr-paren ($/) {
         make $<expr>.made;
    }
    method calcular ($/, $operandos, $operadores) {
        my $result = (shift $operandos).made;
        while my $op = shift $operadores {
            my $número = (shift $operandos).made;
            given $op {
                when '+' { $result += $número; }
                when '-' { $result -= $número; }
                when '*' { $result *= $número; }
                when '/' { $result /= $número; }
                default  { die "operador desconocido"}
            }
        }
        make $result;
    }
}
\end{verbatim}

El método {\tt calcular} computa las expresiones (términos
separados por los operadores de adición o sustracción) y
términos (átomos separados por los operadores de multiplicación
o división) desde la izquierda hacia la derecha dado que los
operadores son asociativos por la izquierda.

Esta gramática para una calculadora y su  asociada clase de acciones 
puede probarse con el código siguiente:
\index{grammar!arithmetic calculator}

\begin{verbatim}
for |< 3*4 5/6 3+5 74-32 5+7/3 5*3*2 (4*5) (3*2)+5 4+3-1/5 4+(3-1)/4 >,
    "12 + 6 * 5", " 7 + 12 + 23", " 2 + (10 * 4) ", "3 * (7 + 7)" { 
    my $result = Calculadora.parse($_, :actions(AccionesCalc));
    # say $result;
    printf "%-15s %.3f\n", $/,  $result.made if $result;
}
\end{verbatim}

lo cual mostrará los resultados siguientes:

\begin{verbatim}
3*4             12.000
5/6             0.833
3+5             8.000
74-32           42.000
5+7/3           7.333
5*3*2           30.000
(4*5)           20.000
(3*2)+5         11.000
4+3-1/5         6.800
4+(3-1)/4       4.500
12 + 6 * 5      42.000
 7 + 12 + 23    42.000
 2 + (10 * 4)   42.000
3 * (7 + 7)     42.000
\end{verbatim}

Puede preguntarte si este código funciona correctamente con
expresiones entre paréntesis anidadas. Originalmente pensé,
cuando escribí este código, que podría tener un fallo y que tal vez
necesitaba cambiar o añadir algo para conseguir que las expresiones
entre paréntesis funcionaran correctamente. Por ejemplo, considera
la siguiente prueba de código con expresiones entre paréntesis 
relativamente anidadas:
\index{nested expressions}

\begin{verbatim}
for "(((2+3)*(5-2))-1)*3", "2 * ((4-1)*((3*7) - (5+2)))"  { 
    my $result = Calculadora.parse($_, :actions(AccionesCalc));
    printf "%-30s %.3f\n", $/,  $result.made if $result;
}
\end{verbatim}

El resultado es correcto:
\begin{verbatim}
(((2+3)*(5-2))-1)*3            42.000
2 * ((4-1)*((3*7) - (5+2)))    84.000
\end{verbatim}

\index{exponentiation}
\index{precedence}
Como un ejercicio adicional, podrías añadir la potenciación a la lista 
de operadores permitidos. Recuerda que la potenciación tiene mayor precedencia
que la multiplicación y la división (así que probablemente quieres
poner dicho operador cerca del nivel del átomo). En el evento que
quieras manejar operadores de potenciación anidados, también recuerda
que usualmente son asociativos por la derecha:

\begin{verbatim}
2**3**2 = 2**(3**2) = 2 ** 9 = 512;  # No: (2**3)**2 o 64
\end{verbatim}



%\section{Ejercicios del Capítulo~14: Programación Funcional en Perl}
\section{Ejercicios del Capítulo~\ref{functional programming}: Programación
Funcional}

\subsection{Ejercicio~\ref{quicksort}: Creando una Implementación Funcional de Ordenamiento Rápido}
\label{sol_quicksort}
\index{quick sort}
\index{sort!quick sort}

Aquí presentamos una manera de implementar el algoritmo
de ordenamiento rápido en un estilo de programación funcional.
\index{ functional programming!style}

\begin{verbatim}
sub ord-rapido( @entrada ) {
    return @entrada if @entrada.elems <= 1;
    my $pivote = @entrada[@entrada.elems div 2];
    return flat ord-rapido(grep {$_ < $pivote}, @entrada), 
        (grep {$_ == $pivote}, @entrada), 
        ord-rapido(grep {$_ > $pivote}, @entrada);
}
\end{verbatim}

Esta versión funcional del programa refleja directamente 
la estrategia del algoritmo de ordenamiento rápido:

\begin{itemize}
\item Si el array tiene menos de dos artículos, ya está
ordenado, y por lo tanto devuélvelo inmediatamente (este es
el caso base que parará la recursión).
\index{base case}
\index{recursion!base case}
\item Por el contrario, elige un artículo como un pivote
(aquí, nosotros elegimos el elemento del medio o uno 
inmediatamente cerca del medio).
\item Divide el array en tres sub-listas que contienen 
artículos respectivamente más pequeños, mayores que e iguales
al pivote.
\item Ordena la dos primeras sub-listas usando una llamada recursiva
a la función \verb|ord-rapido|, pero no llame a \verb|ord-rapido| sobre
una sub-lista que contiene artículos iguales al pivote: a parte
de estar ya ordenado (todos los elementos son iguales), fallaría 
en satisfacer el caso base y entraría en una recursión infinita.
\index{recursion}
\item  Devuelve la lista obtenida al concatenar las sub-listas.5
\end{itemize}
\index{sort!quick sort}


\index{pivot!quick sort algorithm}
\index{divide and conquer algorithm}

Como se mencionó previamente, el pivote ideal sería la mediana 
de los valores, pero el costo de encontrar la mediana sería 
exorbitante.

En principio, podrías elegir cualquier artículo como el pivote,
incluyendo el primer o último elemento del array. Pero para 
entradas específicas (tales como arrays que ya están casi ordenados,
de forma ascendente o descendente), esto puede incrementar significativamente
el tiempo de ejecución por las particiones (o divisiones)
se vuelven desequilibradas, y por lo tanto perdiendo la ventaja de
la estrategia de dividir y conquistar. Elegir un elemento en el medio,
como hicimos aquí, reduce la probabilidad de tal comportamiento patológico.
Otra posible forma posible de prevenir tal riesgo es seleccionar el
pivote aleatoriamente entre los elementos del array.



