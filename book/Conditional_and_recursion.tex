\chapter{Bucles, Condicionales, y Recursión}
\label{conditionals}

El tema principal de  este capítulo es la sentencia {\tt if},
la cual ejecuta código diferente dependiendo del estado
del programa. Pero primero quiero introducir dos operadores
nuevos: división de enteros y módulo.


\section{División de Enteros y Módulo}

El operador {\bf división de enteros}, \verb"div", 
divide dos números y los redondea a un entero. Por ejemplo,
supón que una película se tarda 105 minutos. Podrías querer
saber cuántas horas hay en 105 minutos. En Perl, la división
convencional devuelve un número racional (en muchos lenguajes,
devuelve un número de coma flotante, que es otra forma
de representación interna de números que no son enteros):

\begin{verbatim}
> my $minutos = 105;
> $minutos / 60;
1.75
\end{verbatim}

Sin embargo, normalmente nosotros no escribimos las horas con
puntos decimales. La división de enteros devuelve el número
entero de horas, descartando la parte fraccional:
\index{operator!div}
\index{div operator}
\index{integer division}

\begin{verbatim}
> my $minutos = 105;
> my $horas = $minutos div 60;
1
\end{verbatim}

En aritmética, la división de enteros es algunas veces
llamada \emph{división euclidiana}, la cual calcula el
cociente y el residuo.
\index{Euclidean division}
\index{division remainder}

Para conseguir el residuo, podrías sustraer una hora en 
minutos:

\begin{verbatim}
> my $residuo = $minutos - $horas * 60;
45
\end{verbatim}

\index{integer division}
\index{floating-point division}
\index{division!integer}
\index{division!floating-point}
\index{modulo operator}
\index{operator!modulo}

Una alternativa es usar el {\bf operador de módulo}, \verb|%|,
el cual divide dos números y devuelve el residuo:
%\index{$%$ modulo operator}
%\index{operator!$%$ (modulo)}

\begin{verbatim}
> my $residuo = $minutos % 60;
45
\end{verbatim}
%
El operador de módulo es muy común en los lenguajes de programación
y es más útil de lo que parece. Por ejemplo, puedes chequear si
un número es divisible por otro---si {\tt \$dividendo \% \$divisor} es cero, entonces {\tt \$dividendo} es divisible por {\tt \$divisor}. 
Esto es usado comúnmente, por ejemplo, con un divisor igual a 2 para determinar si un número es par o impar. Veremos un ejemplo
de esto más adelante en este capítulo (ver Sección~\ref{alternative.execution}).
\index{divisibility}
\index{even number}
\index{odd number}
\index{integer!even}
\index{integer!odd}

Para ser sincero, Perl~6 también tiene un operador específico 
para la divisibilidad, \verb|%%|. La expresión
\verb|$dividendo %% $divisor| devuelve verdadero si 
\verb|$dividendo %% $divisor| es igual a 0,
es decir si {\tt \$dividendo} es divisible por {\tt \$divisor} 
(de lo contrario, es falso):
\index{divisibility!operator}
\begin{verbatim}
> 42 %% 2;
True
\end{verbatim}

De igual manera, puedes extraer el dígito más a la
derecha o dígitos de un número con el operador
de módulo. Por ejemplo, {\tt \$x \% 10}  extrae el
dígito más a la derecha de {\tt \$x} (en base 10).
Similarmente, {\tt \$x \% 100} extrae los últimos dos 
dígitos:

\begin{verbatim}
> 642 % 100;
42
\end{verbatim}
%
\index{modulo operator}
\index{operator!modulo}



\section{Expresiones Booleanas}
\index{Boolean expression}
\index{expression!Boolean}
\index{logical operator}
\index{operator!logical}

Una {\bf expresión booleana} es una expresión que es
verdadera o falsa. Los siguientes ejemplos usan el operador
{\tt ==} para comparar los operandos numéricos y producir
{\tt True} si son iguales y de lo contrario, {\tt False}:

\begin{verbatim}
> 5 == 5;
True
> 5 == 6;
False
\end{verbatim}
%
{\tt True} y {\tt False} son valores especiales
que pertenecen al tipo {\tt Bool}; ellos no son
cadenas de texto:
\index{True!special value}
\index{False!special value}
\index{special value!True}
\index{special value!False}
\index{Bool type}
\index{type!Bool}

\begin{verbatim}
> say True.WHAT
(Bool)
> say False.WHAT
(Bool)
\end{verbatim}
%
\index{operator!$==$ (numeric equality)}
\index{$==$ numeric equality operator}
El operador {\tt ==} es uno de los {\bf operadores de relación
numérica} y su función es chequear si los operandos son 
iguales; los otros son:

\begin{verbatim}
      $x != $y            # $x no es numéricamente igual a $y
      $x > $y             # $x es numéricamente mayor que $y
      $x < $y             # $x es numéricamente menor que $y
      $x >= $y            # $x es numéricamente mayor o igual a $y
      $x <= $y            # $x es numéricamente menor o igual a $y
      $x === $y           # $x y $y son verdaderamente idénticos
\end{verbatim}
% TODO: get these entries working in plastex
\ifplastex \else
\index{"!= numeric inequality operator@\texttt{"!=} numeric inequality operator}
\index{< less than numeric operator@\texttt{<} less than numeric operator}
\index{> greater than numeric operator@\texttt{>} greater than numeric operator}
\index{>= greater than or equal operator@\texttt{>=} greater than or equal operator}
\index{<= less than or equal operator@\texttt{<=} less than or equal operator}
\index{=== value identity operator@\texttt{===} value identity operator}
\index{operator!"!= (numeric inequality)@\texttt{"!=} (numeric inequality)}
\index{operator!< (numerically less than)@\texttt{<} (numerically less than)}
\index{operator!> (numerically greater than)@\texttt{>} (numerically greater than)}
\index{operator!>= (greater than or equal)@\texttt{>=} (greater than or equal)}
\index{operator!<= (less than or equal)@\texttt{<=} (less than or equal)}
\index{operator!=== (value identity)@\texttt{===} (value identity)}
\fi
Aunque estas operaciones probablemente son familiares, los
símbolos en Perl son diferentes a los símbolos matemáticos.
Un error común es usar un solo signo de igualdad ({\tt =}) en vez de 
dos signos de igualdad ({\tt ==}). Recuerda que {\tt =} es el
operador de asignación y {\tt ==} es un operador de relación.
No existe tal cosa como {\tt =<}, aunque existe el operador {\tt =>},
el cual no es un operador de relación sino algo completamente
distinto (como veremos más adelante, dicho operador es el constructor 
de pares). 
\index{relational operator}
\index{relational operator!numeric}
\index{numeric relational operator}
\index{equality operator}
\index{operator!equal}
\index{operator!relational}
\index{pair constructor}
\index{constructor!pair}
% TODO: get these entries working in plastex
\ifplastex \else
\index{=> pair constructor@\texttt{=>} pair constructor}
\index{operator!=> (pair constructor)@\texttt{=>} (pair constructor)}
\fi

La diferencia entre {\tt ==} y {\tt ==} es que el primer
operador chequea si los valores de los operandos son iguales
y el último chequea si los  operandos son verdaderamente
idénticos. Como un ejemplo, considera esto:

\begin{verbatim}
say 42 ==  42;           # True
say 42 ==  42.0;         # True
say 42 ===  42;          # True
say 42 === 42.0;         # False
\end{verbatim}
%

Estos operadores de relación pueden solo comparar 
valores numéricos (números o variables que contienen
números) o valores que se pueden coaccionar en 
valores numéricos, tal como, por ejemplo,
la cadena de texto "42" la cual, si se usa con estos
operadores (excepto {\tt ===}), serán coaccionada 
en el número 42.
\index{coercion}

Para la comparación de cadenas de texto (en un tipo de 
comparación lexicográfica o ``pseudo-alfabética``),
necesitas usar los {\bf operadores de relación de cadena
de texto}:

\begin{verbatim}
      $x eq $y            # $x es una cadena de texto igual a $y
      $x ne $y            # $x no es una cadena de texto igual a $y
      $x gt $y            # $x es mayor que $y (alfabéticamente después)
      $x lt $y            # $x es menor que $y (alfabéticamente antes)
      $x ge $y            # $x es mayor o igual a  $y
      $x le $y            # $x es menor o igual a  $y
      $x eqv $y           # $x es verdaderamente equivalente a $y
\end{verbatim}
%  
\index{relational operator}
\index{relational operator!string}
\index{string!relational operator}
\index{operator!relational}
\index{eq, string equality operator}
\index{operator!eq (string equality)}
\index{ne, string inequality operator}
\index{operator!ne (string inequality)}
\index{operator!gt (alphabetically after)}
\index{operator!lt (alphabetically before)}



Por ejemplo, puedes comparar (alfabéticamente) los nombres
de dos presidentes de los Estados Unidos:
\begin{verbatim}
> 'FDR' eq 'JFK';
False
> 'FDR' lt 'JFK';    # comparación alfabética
True
\end{verbatim}
%  

A diferencia de otros lenguajes de programación, Perl~6 te permite 
encadenar varios operadores de relación de forma transitiva,
al igual que en notación matemática:

\begin{verbatim}
say 4 < 7 < 12;      # True
say 4 < 7 < 5;       # False
\end{verbatim}
\index{chained relational operator}

Es necesario aclarar que los operadores de relación
numérica y los operadores de relación de cadena de texto no 
funciona de la misma manera (y esta es una buena razón 
para tener operadores diferentes), porque ellos no poseen
la misma idea de lo que \emph{mayor que} o \emph{menor que}.

Al comparar dos enteros positivos, un número con cuatro dígitos
es siempre mayor que un número con solo dos o tres dígitos. 
Por ejemplo, 1110 es mayor que 886. 

Por lo contrario, la comparación de cadenas de texto
sigue básicamente reglas (pseudo) alfabéticas: 
``b'' es mayor que ``aaa'', porque la regla comúnmente
aceptada para la comparación de cadenas de texto es
comenzar a comparar la primera letra de cada cadena
de texto: si las dos letras son diferentes se sabe cuál de
las dos cadenas es mayor sin importar el carácter que viene
a continuación; necesitas proceder con la comparación
de la segunda letra de cada palabra solo si la comparación
de la primera letra de cada cadena termina en un empate, etc.
Así que cualquier palabra que inicia con ``a`` es menor que 
cualquier palabra que inicie con ``b``, sin importar la longitud
de estas palabras. Esto puede parecer algo minucioso, no 
obstante esto se vuelve esencial cuando comienzas 
a ordenar elementos: realmente tienes que pensar qué tipo
de orden (numérico o alfabético) quieres usar.
\index{sorting}

También existen los operadores de relación de ``tres sentidos``,
{\tt cmp}, {\tt <=>} y {\tt leg}, pero regresaremos a ellos
cuando estudiemos cómo ordenar los elementos de una lista. 
Similarmente, necesitamos aprender otras cosas sobre Perl antes
que podamos justificar el increíblemente poderoso y expresivo
operador de \emph{coincidencia inteligente}, \verb|~~|.
\index{sorting}
\index{smart match operator}
\index{operator!smart match}
\index{three-way operator}
\index{operator!three-way}
\index{cmp operator}
\index{leg operator}
\index{operator!leg}
% TODO: get these entries working in plastex
\ifplastex \else
\index{<=> operator@\texttt{<=>} operator}
\index{operator!<=> (numeric comparison)@\texttt{<=>} (numeric comparison)}
\fi

Un punto final acerca de la comparación de cadenas
de texto es que las letras mayúsculas son siempre menores
que las letras minúsculas. Así que  "A," "B," "BB," y "C"
son \emph{todas} menores que "a," "b," "bb," y "c".
No discutiremos los detalles aquí pero esto se vuelve
complicado (y algo confuso) cuando las cadenas de texto
a ser comparadas contienen caracteres no alfabéticos (
o letras Unicode que no son ASCII).

\section{Operadores Lógicos}
\index{logical operator}
\index{operator!logical}

Hay tres pares principales de {\bf operadores lógicos}:
\begin{itemize}
\item lógico \emph{and} (y) : ``{\tt and}'' y {\tt \&\&}
\item lógico \emph{or} (o): ``{\tt or}'' y {\tt ||}
\item lógico \emph{not} (no): ``{\tt not}'' y {\tt !}
\end{itemize}

La semántica (significado) de estos operadores es similar
a sus significados en inglés (y en español). Por ejemplo,
{\tt \$x > 0 and \$x < 10} es verdadera solo si {\tt \$x}
es mayor que 0 \emph{and} menos que 10.
\index{and operator}
\index{or operator}
\index{not operator}
\index{operator!and}
\index{operator!or}
\index{operator!not}

{\tt \$n \% 2 == 0 and \$n \% 3 == 0} es verdadero si {\em ambas}
condiciones son verdaderas, es decir, si el número es divisible por
2 \emph{and} por 3, i.e., es de hecho divisible por 6 (que podría
ser mejor escrito así: {\tt \$n \% 6 == 0} or {\tt \$n \%\% 6}).

{\tt \$n \% 2 == 0 or \$n \% 3 == 0} es verdadero si \emph{una o ambas}
condiciones son verdaderas, es decir, si el número es divisible por 2
\emph{or} por 3 (or ambos).

Finalmente, el operador {\tt not} niega una expresión Booleana,
así que {\tt not (x > y)} es verdadero si {\tt x > y} es falso, es
decir, si {\tt x} es menor o igual {\tt y}.

Los operadores {\tt \&\&}, {\tt ||}, y {\tt !} tienen el mismo
significado, respectivamente, como {\tt and}, {\tt or}, y {\tt not},
pero una precedencia más estricta, lo que significa 
que cuando están en una expresión con algunos otros operadores,
ellos tienen una mayor precedencia de ejecución. Volveremos
con la precedencia más adelante, pero digamos por el tiempo
presente que, en los casos más comunes, los operadores 
{\tt and}, {\tt or}, y {\tt not} usualmente serán suficientes
para hacer lo que deseas.
\index{precedence}      
\index{operator precedence}

En sentido estricto, los operandos de los operadores lógicos
deberían ser expresiones Booleanas, pero Perl, como muchos
otros lenguajes derivados parcialmente de C, no es estricto
con respecto a eso. Los números~0 y 0.0 son falsos; y cualquier
número que no sea cero o una cadena de cuerda que no esté 
vacía es interpretado como {\tt True}:

\begin{verbatim}
> 42 and True;
True
\end{verbatim}
%
Aunque esta flexibilidad puede ser muy útil, existen 
sutilezas que pueden ser confusas. A menos que sepas
lo que estás haciendo, esto es algo que deberías evitar.

La función integrada {\tt so} devuelve una evaluación 
de sus argumentos:

\begin{verbatim}
> say so (0 and True);
False
\end{verbatim}
%
Aquí la expresión {\tt (0 and True)} es falsa porque 0 es falso
y la expresión sería verdadera solo si ambos argumentos del operador
{\tt and} son verdaderos.

Cuando varias condiciones Booleanas son enlazadas con algunos
operadores lógicos, Perl solo realizará la comparaciones que son
estrictamente necesarias para descifrar el resultado final,
comenzando con aquellas en la izquierda. Por ejemplo, si escribes:

\begin{verbatim}
> False and $número > 0;
False
\end{verbatim}
%
no hay necesidad de evaluar la segunda expresión Booleana
para saber que la expresión completa será falsa. En este caso,
Perl no trata de chequear si el número es positivo o hasta si
está definido. Se dice que estos operadores realizan una evaluación
de ``cortocircuito`` con las condiciones innecesarias.
\index{short-circuit boolean operators}
\index{short-circuit evaluation}

De la misma manera, en el siguiente código, la subrutina 
{\tt calcular-pensión} no será llamada si la edad de la persona
es menos de 65:

\begin{verbatim}
$edad >= 65 and calcular-pensión();
\end{verbatim}
%
Lo mismo ocurre con el operador {\tt or}, pero de
manera completamente distinta: si la primera expresión booleana
de una sentencia {\tt or} es verdadera, entonces la siguiente
expresión no será evaluada. El siguiente código es equivalente
al anterior:

\begin{verbatim}
$edad < 65 or calcular-pensión();
\end{verbatim}
% 
Esta \emph{puede} ser una forma de ejecutar la subrutina
{\tt calcular-pensión} condicionalmente, dependiendo del 
valor de la edad, y esto se usa usualmente en construcciones
tal como:

\begin{verbatim}
haz-algo() or die "no pude hacer algo";
\end{verbatim}
%
la cual aborta el programa si {\tt haz-algo} devuelve un 
valor falso, lo cual quiere decir que fue incapaz de hacer 
algo tan esencial que no vale la pena continuar con su
ejecución.

Más adelante examinaremos formas más claras y comunes
de ejecutar código con condicionales.

\section{Ejecuciones Condicionales}
\label{conditional.execution}

\index{conditional!statement}
\index{statement!conditional}
\index{if statement}
\index{statement!if}
\index{conditional!execution}
Para escribir programas útiles, casi siempre necesitamos la habilidad 
de evaluar condiciones y cambiar el comportamiento del programa
adecuadamente. Las {\bf sentencias condicionales} nos brindan esta
habilidad. La forma más simple es la sentencia {\tt if}:

\begin{verbatim}
if $número > 0 {
    say '$número es positivo';
}
\end{verbatim}
%
La expresión Booleana después de {\tt if} se conoce 
como la condición. Si la condición es verdadera, el
bloque de código subsecuente se ejecuta. Si es falsa, 
nada pasa. El bloque de código puede contener cualquier
cantidad de sentencias.
\index{condition}

Es una convención y muy recomendado (aunque no es mandatario
desde la perspectiva del compilador) indentar las sentencias
del bloque, para así ayudar con la visualización del 
\emph{flujo de control} del programa, i.e., su estructura
de ejecución: con tal indentación, podemos ver mucho mejor 
que las condiciones dentro del bloque serán ejecutadas solo 
si la condición es verdadera.
\index{indentation}

La condición puede ser una expresión Booleana compuesta:
\begin{verbatim}
if $n > 0 and $n < 20 and $n %% 2 {
    say '$n es un número par y positivo menor que 20'
}
\end{verbatim}
%
Nota que en la sentencia de impresión anterior, el punto y coma
final se omitió. Cuando una sentencia es la última línea de
código de un bloque, inmediatamente antes de la llave derecha
{\tt \}} que cierra el bloque, el punto y coma final es opcional
y puede ser omitido, aunque sería recomendable incluirlo.
\index{omitting the semi-colon}
\index{semi-colon, omitting}
\index{bracket!curly}
\index{curly bracket}
\index{curly brace}

En teoría, el fragmento de código anterior es por sí mismo una
sentencia y debería también terminar con un punto y coma después
de la llave derecha. Pero una llave derecha seguida por un carácter
de nueva línea implica un separador de sentencia, así que no 
necesitas un punto y coma ahí y por lo tanto, es generalmente
omitido.
\index{omitting the semi-colon}
\index{semi-colon, omitting}



\section{Ejecución Alternativa}
\label{alternative.execution}
\index{alternative execution}
\index{else keyword}
\index{keyword!else}

Una segunda forma de la sentencia {\tt if} es la
``ejecución alternativa``, en la cual existen dos 
posibilidades y la condición determina cual de ellas
ejecutar. Dada una variable \verb|$número| que 
contiene una entero, el siguiente código muestra dos
mensajes diferentes dependiendo si el valor del
entero es par o impar:

\begin{verbatim}
if $número % 2 == 0 {
    say 'La variable $número es par'
} else {
    say 'La variable $número es impar'
}
\end{verbatim}
%
\index{even number}
\index{odd number}
\index{integer!odd}
\index{integer!even}
Si el residuo del {\tt \$número} dividido por 2 es 0,
entonces sabemos que el {\tt \$número} es par, y el programa
muestra el mensaje apropiado. Si la condición es falsa,
el segundo conjunto de sentencias se ejecuta. Dado que la
condición debe ser verdadera o falsa, exactamente una de las
alternativas será ejecutada. Las alternativas son conocidas
como {\bf ramas}, por ellas son ramas en el flujo de ejecución.
\index{branch}

Nota que si \verb|$número| divide a dos exactamente, este
código imprimirá:

\begin{verbatim} 
La variable $número es par
\end{verbatim}

El valor de la  variable \verb|$número| no es interpolado,
porque hemos usado las comillas simples con el propósito
de imprimir el nombre de la variable y no su valor. Habríamos
usado las comillas inglesas si hubiésemos querido imprimir
el valor de la variable y no el nombre.
\index{single quote}
\index{double quote}
\index{quote!single}
\index{quote!double}
\index{variable!interpolation}
\index{interpolation}


\section{Condicionales Encadenadas}
\index{chained conditional}
\index{conditional!chained}

Algunas veces existen más de dos posibilidades y 
necesitamos más de dos ramas en el flujo de ejecución.
Una forma de expresar una computación como ésta es con
el uso de una {\bf condicional encadenada}:

\begin{verbatim}
if $x < $y {
    say 'La variable $x es menor que la variable $y'
} elsif $x > $y {
    say 'La variable $x es mayor que la variable $y' 
} else {
    say 'Las variables $x y $y son iguales'
}
\end{verbatim}
%
La palabra clave {\tt elsif} es una abreviación de ``else if``
que tiene la ventaja de prevenir los bloques anidados. Otra vez,
exactamente una de las ramas será ejecutada. No hay límite 
con el número de sentencias {\tt elsif}.

Si existe una claúsula {\tt else}, tiene que ir al 
final. Sin embargo, no tiene que haber una:

\index{elsif keyword}
\index{keyword!elsif}

\begin{verbatim}
if $selección eq 'a' {
    draw_a()
} elsif $selección eq 'b' {
    draw_b()
} elsif $selección eq 'c' {
    draw_c()
}
\end{verbatim}
%
Cada condición es examinada en orden. Si la primera
es falsa, la siguiente es examinada, etc. Si una de ellas
es verdadera, la rama correspondiente se ejecuta y la
sentencia finaliza. Aún si más de una condición es verdadera,
solo la primera rama se ejecuta.


\section{Condicionales Anidadas}
\index{nested conditional}
\index{conditional!nested}

Una condicional puede también ser anidada dentro de otra. Podríamos
haber escrito el ejemplo anterior de la siguiente manera:

\begin{verbatim}
if $x == $y {
    say 'Las variables $x y $y son iguales'
} else {
    if $x < $y {
        say 'La variable $x es menor que la variable $y'
    } else {
        say 'La variable $x es mayor que la variable $y'
    }
}
\end{verbatim}
%
La condicional exterior contiene dos ramas. La primera
rama contiene una sentencia simple. La segunda rama contiene
otra sentencia {\tt if}, la cual contiene dos ramas. Estas 
dos ramas son sentencias simples, aunque pudieran haber sido
sentencias condicionales. Se dice que la condición \verb|if $x < $y| 
está anidad dentro de la rama {\tt else} de la condicional
exterior.

Tales condicionales anidadas muestran lo crítico que es 
para tu propia comprensión indentar apropiadamente las
sentencias condicionales, debido a que sería difícil 
entender la estructura sin la ayuda visual
proveída por la correcta indentación.
\index{indentation}

Aunque la indentación de las sentencias ayuda
a entender la estructura, las {\bf condicionales anidadas}
se vuelven difícil de leer bien rápido. Es una buena
idea evitarlas cuando se pueda. Los operadores lógicos
usualmente proveen una manera de simplificar las
condicionales anidadas. Por ejemplo, considera
el siguiente código (el cual asume que \verb|$x| es
un entero):
\index{logical operator}

\begin{verbatim}
my Int $x;
# ... $x = ...;
if 0 < $x {
    if $x < 10 {
        say 'El valor de $x es un número positivo de un solo dígito.'
    }
}
\end{verbatim}
%
La sentencia {\tt say} se ejecuta solo si pasamos ambas condicionales,
así que podemos obtener el mismo efecto con el operador Booleano {\tt and},
y el código puede escribirse usando una sola condicional:

\begin{verbatim}
if 0 < $x and $x < 10 {
    say '$x es un número positivo de un solo dígito.'
}
\end{verbatim}

Para este tipo de condición, Perl~6 provee una opción más concisa
usando los operadores de relación encadenados discutidos 
anteriormente:

\begin{verbatim}
if 0 < $x < 10 {
    say '$x es un número positivo de un solo dígito.'
}
\end{verbatim}
\index{chained relational operator}

\section{Condicionales If como Modificadores de Sentencias}
\index{statement modifier} \index{modifier!statement}
\index{postfix conditional} \index{conditional!postfix }

También existe una forma de {\tt if} conocida como un
{\bf modificador de sentencia} (o algunas veces ``condicional sufija``)
cuando hay solo una sentencia condicional. En este caso, 
la sentencia {\tt if} y la condición vienen después del 
código que quieres ejecutar condicionalmente. Nota que la 
condición es siempre la primera en ser evaluada:

\begin{verbatim}
say '$número es negativo.' if $número < 0;
\end{verbatim}
%
Esto es equivalente a:
\begin{verbatim}
if $número < 0 {
    say '$número es negativo.' 
}
\end{verbatim}
%
Esta forma sintáctica es más concisa debido a que toma
una sola línea de código en vez de tres. La ventaja de esto
es que puedes ver más de tu código en una sola pantalla,
sin tener que desplazarte hacia arriba o hacia abajo. 
Sin embargo, este sintaxis es nítida y limpia solo cuando
la condición y la sentencia son cortas y simple. Por lo
tanto, es mejor usarlas en estos casos.

El modificador de sentencia no permite el uso de las
sentencias {\tt else} y {\tt elsif}.

\section{Sentencia Condicional Unless}
\index{unless statement}
\index{keyword!unless}

Si no te gusta escribir condiciones negativas en sentencia
condicional {\tt if} tal como:
%
\begin{verbatim}
if not $número >= 0 {
    say '$número es negativo.' 
}
\end{verbatim}
%

podrías escribirlo así:

\begin{verbatim}
unless $número >= 0 {
    say '$número es negativo.' 
}
\end{verbatim}
%
Esta palabra clave \verb|unless| tiene el mismo significado
que la palabra en inglés: mostrará la sentencia ``\$número es negativo.``
\emph{a menos que} (unless) el número sea mayor o igual a 0.

No puedes usar las sentencias {\tt else} o {\tt elsif} con 
{\tt unless}, porque eso se volvería confuso.

La condicional {\tt unless} se usa más en su forma 
de modificador de sentencia (o notación de sufijo):
\index{statement modifier} \index{modifier!statement}
\index{postfix conditional} \index{conditional!postfix }

\begin{verbatim}
say '$número es negativo.' unless $número >= 0;
\end{verbatim}
%

\section{For Loops}
\label{for_loops}
\index{for loop}
\index{loop!for}
\index{statement!for}
\index{factorial}

Supón que necesitas computar e imprimir el producto de los 
primeros cinco dígitos positivos (de 1 a 5). Este producto es
conocido en matemática como el \emph{factorial} de 5 y 
se denota por $5!$. Podrías escribir el siguiente programa:  

\begin{verbatim}
my $producto = 1 * 2 * 3 * 4 * 5;
say $producto;           # prints 120
\end{verbatim}
%

Podrías hacerlo un poco más simple:
\begin{verbatim}
say 2 * 3 * 4 * 5;      # prints 120
\end{verbatim}
%

El problema es que esta construcción sintáctica no 
escal muy bien y se vuelve tediosa para el producto 
de los primeros diez enteros (o factorial de 10). Y
se vuelve una pesadilla para el factorial de 100.
La computación del factorial de un número es algo 
común en matemáticas (especialmente en los campos de 
combinatoria y probabilidad) y la ciencia de la
computación. Necesitamos automatizarlo, y el uso del
bucle {\tt for} es una de las maneras más obvia de hacerlo:
\index{factorial!using a for loop}

\begin{verbatim}
my $producto = 1;
for 1..5 {
    $producto *= $_
}
say $producto;           # prints 120
\end{verbatim}

Ahora, si necesitas calcular el factorial de 100, solo
necesitas reemplazar el 5 en el código más arriba con el 100.
Ten presente que la función factorial es conocida por 
crecer extremadamente rápido, y obtendrás un número
realmente grande, con 158 dígitos (i.e., un número mucho
más grande que el número total estimado de átomos en el
universo conocido).
\index{factorial}

\index{range!operator}
\index{operator!range}
\index{special variable}
En este script, {\tt 1..5} es el operando de rango, el cual
es usado aquí para generar una lista de números consecutivos entre 1 y 5.
La palabra clave {\tt for} es usada para iterar sobre una lista, y 
la variable \verb|$_| es una variable especial que toma cada valor sucesivo
de esta lista: primero 1, después 2, etc. hasta 5. En el bloque
de código que forma el cuerpo del bucle, la variable {\tt \$producto}
es multiplicada sucesivamente por cada valor de \verb|$_|. El bucle
termina con 5 y el resultado, 120, se imprime en la última línea.

Esto es un uso simple de la sentencia {\tt for},
pero probablemente no la más usada en Perl~6; veremos
más formas de hacerlo adelante. También veremos otros 
tipos de bucles. Pero esto debería ser suficiente para que 
escribas algunos bucles. Los bucles se encuentran en todas
partes en la ciencia de la computación.
\index{special variable}
\index{topical variable}
\index{default method invocant}
\index{invocant}
\index{topic}

La variable especial \verb|$_| es conocida como la 
\emph{variable tópica}. No necesita ser declarada y 
muchas de las construcciones sintácticas le asignan un valor
sin mencionarla explícitamente. De igual manera,
la variable \verb|$_| es un argumento implícito de los
métodos que se llaman sin un invocante. Por ejemplo,
para imprimir los primeros cinco dígitos, podrías
escribir:

\begin{verbatim}
for 1..5 {.say};  # imprime los números del 1 al 5, cada uno en su línea
\end{verbatim} 

Aquí {\tt .say} es un atajo de sintaxis equivalente a \verb|$_.say|.
Y debido a que, como vimos, \verb|$_| toma cada valor sucesivo del 
rango introducido por la palabra clave {\tt for}, este atajo imprime
cada número entre 1 y 5, cada uno de ellos en una línea distinta.
Esto es un ejemplo típico del uso de la variable tópica \verb|$_|
sin ser explícitamente mencionada. Más adelante veremos otros
usos de la variable especial \verb|$_|. 

Algunas veces, no necesitas la variable \verb|$_| dentro de un bucle,
por ejemplo si quieres hacer algo cinco veces pero no te importa a cuál
iteración del bucle has llegado. Una subrutina que imprime un mensaje 
un numero \emph{n} de veces podría lucir de la siguiente manera:

\begin{verbatim}
sub imprime-n-veces (Int $n, Str $mensaje) {
    for 1..$n { say $mensaje }
} 
\end{verbatim} 

El bucle {\tt for} tiene una forma de modificador de sentencia (
o forma sufijo), usada aquí para calcular otra vez el factorial de 5:
\index{statement modifier}
\index{postfix notation}
\index{factorial!using a for statement modifier}

\begin{verbatim}
my $producto = 1;
$producto *= $_ for 1..5;
say $producto;           # imprime 120
\end{verbatim} 

Existe otra forma de sintaxis del bucle {\tt for}, usando una variable
de bucle explícita:
\index{factorial!using a for pointy block }

\begin{verbatim}
sub factorial (Int $num) { 
    my $producto = 1;  
    for 1..$num -> $x { 
        $producto *= $x
    }
    return $producto
}
say factorial 10;   # 3628800
\end{verbatim} 

El bucle {\tt for} en esta subrutina usa lo que se llama una
sintaxis de ``bloque puntiagudo``. Es esencialmente la misma
idea del bucle {\tt for} anterior, excepto que, en vez de usar
la variable tópica \verb|$_|, ahora declaramos una variable de
bucle explícita \verb|$x| con la sintaxis \verb|1..$num -> $x|
para iterar sobre el rango de valores. El uso de una variable de
bucle explícita puede hacer tu código más claro cuando las cosas
se complican, por ejemplo cuando necesitas anidar varios bucles
{\tt for}. Más adelante veremos más ejemplos.
\index{pointy block}
\index{for loop}
\index{loop!for}

También veremos otras formas de calcular el factorial de un
número en este libro.
\index{factorial}

\section{Recursion}
\label{recursion}
\index{recursion}

It is legal for one function or subroutine to call another;
it is also legal for a subroutine to call itself.  It may not 
be obvious why that is a good thing, but it turns out to be 
one of the most magical things a program can do. 
For example, look at the following subroutine:

\begin{verbatim}
sub countdown(Int $time-left) {
    if $time-left <= 0 {
        say 'Blastoff!';
    } else {
        say $time-left;
        countdown($time-left - 1);
    }
}
\end{verbatim}
%
If {\tt \$n} is 0 or negative, it outputs the word, 
``Blastoff!''. Otherwise, it outputs the value of 
{\tt \$time-left} and then calls a subroutine named 
{\tt countdown}---itself---passing {\tt \$n-1} as an argument.

What happens if we call the subroutine like this?

\begin{verbatim}
countdown(3);
\end{verbatim}
%
The execution of {\tt countdown} begins with {\tt \$time-left 
= 3}, and since {\tt \$time-left} is greater than 0, it 
outputs the value 3, and then calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt \$time-left = 2}, and since
{\tt \$time-left} is greater than 0, it outputs the value 2, and then calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt \$time-left = 1}, and since
{\tt \$time-left} is greater than 0, it outputs the value 1, and then calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt \$time-left = 0}, and since {\tt
\$time-left} is not greater than 0, it outputs the word, ``Blastoff!'' and then
returns.
\end{quote}

The {\tt countdown} that got {\tt \$time-left = 1} returns.
\end{quote}

The {\tt countdown} that got {\tt \$time-left = 2} returns.
\end{quote}

The {\tt countdown} that got {\tt \$time-left = 3} returns.

And then you're back in the main program.  So, the
total output looks like this:

\begin{verbatim}
3
2
1
Blastoff!
\end{verbatim}
%
A subroutine that calls itself is {\bf recursive}; the process of
executing it is called {\bf recursion}.
\index{recursion}
\index{function!recursive}

As another example, we can write a subroutine that prints a
string {\tt \$n} times:

\begin{verbatim}
sub print-n-times(Str $sentence, Int $n) {
    return if $n <= 0;
    say $sentence;
    print-n-times($sentence, $n - 1);
}
\end{verbatim}
%
If {\tt \$n <= 0}, the {\bf return statement} exits the
subroutine.  The flow of execution immediately returns to 
the caller, and the remaining lines of the subroutine don't
run. This illustrates a feature of the {\tt return} statement 
that we have not seen before: it is used here for flow 
control, i.e., to stop the execution of the subroutine and 
pass control back to the caller. Note also that, here, the 
{\tt return} statement does not return any value to the 
caller; {\tt print-n-times} is a void function.

\index{return!statement}
\index{statement!return}
\index{void function}

The rest of the subroutine is similar to {\tt countdown}: it 
displays {\tt \$sentence} and then calls itself to display 
{\tt \$sentence} $\$n - 1$ additional times.  So the number 
of lines of output is {\tt 1 + (\$n - 1)}, which
adds up to {\tt \$n}.

For simple examples like this, it may seem easier to use a {\tt
for} loop.  But we will see examples later that are hard to write
with a {\tt for} loop and easy to write with recursion, so it is
good to start early.
\index{for loop}
\index{loop!for}


\section{Stack Diagrams for Recursive Subroutines}
\label{recursive.stack}
\index{stack diagram}
\index{function frame}
\index{frame}

In Section~\ref{stackdiagram}, we used a stack diagram to represent
the state of a program during a subroutine call.  The same kind of
diagram can help interpret a recursive subroutine.

Every time a subroutine gets called, Perl creates a
frame to contain the subroutine's local variables and parameters.
For a recursive subroutine, there might be more than one frame 
on the stack at the same time.

Figure~\ref{fig.stack2} shows a stack diagram for {\tt countdown} called with
{\tt n = 3}.

\begin{figure}
\centerline
{\includegraphics[scale=0.6]{figs/stack2.png}}
\caption{Stack diagram.}
\label{fig.stack2}
\end{figure}


As usual, the top of the stack is the frame for the main 
program.
It is empty because we did not create any variables in 
it or pass any arguments to it.
\index{base case}
\index{recursion!base case}

The four {\tt countdown} frames have different values for the
parameter {\tt \$time-left}.  The bottom of the stack, where {\tt \$time-left = 0}, is
called the {\bf base case}.  It does not make a recursive call, so
there are no more frames.

As an exercise, draw a stack diagram for \verb"print-n-times" 
called with
\verb"$sentence = 'Hello'" and {\tt \$n = 2}.
Then write a function called \verb"do-n-times" that takes a function
and a number, {\tt \$num}, as arguments, and that calls
the given function {\tt \$num} times.
\label{do_n_times}

Solution: see Section~\ref{sol_do_n_times}


\section{Infinite Recursion}
\index{infinite recursion}
\index{recursion!infinite}
\index{runtime error}


If a recursion never reaches a base case, it goes on making
recursive calls forever, and the program never terminates.  This is
known as {\bf infinite recursion}, and it is generally not
a good idea. In fact, your program will not actually execute 
forever but will die at some point when the computer runs out of 
memory or some other critical resource.

You have to be careful when writing recursive subroutines. 
Make sure that you have a base case, and make sure that 
you are guaranteed to reach it. Actually, although this is not 
absolutely required by the language, I would advise you to 
take the good habit of treating the base case first.


\section{Keyboard Input}
\index{keyboard input}

The programs we have written so far accept no input from 
the user. They just do the same thing every time. Perl 
provides built-in functions that stop the program and
wait for the user to type something. 

For example, the {\tt prompt} function prompts the user with 
a question or an instruction. When the user presses 
{\sf Return} or {\sf Enter}, the program resumes and 
\verb"prompt" returns what the user typed as a string 
(without the newline character corresponding to the 
{\sf Return} key typed by the user):
\index{prompt function}
\index{function!prompt}

\begin{verbatim}
my $user = prompt "Please type in your name: ";
say "Hello $user";
\end{verbatim}
%

This is probably one of the most common ways to obtain 
interactive user input, because it is usually a good idea 
to tell the user what is expected.

Another possibility is to use the {\tt get} method (which
 reads a single line) on standard input:
\index{get function}
\index{function!get}

\begin{verbatim}
say "Please type in your name: ";
my $user = $*IN.get;
say "Hello $user";
\end{verbatim}
%
or the {\tt get} function, which reads a line from standard 
input by default:
\begin{verbatim}
say "Please type in your name: ";
my $user = get;
say "Hello $user";
\end{verbatim}
%

\section{Program Arguments and the MAIN Subroutine}
\label{MAIN}
\index{MAIN}

There is another (and often better) way to have a program 
use varying input defined by the user, which is to pass 
command-line arguments to the program, just as we have 
passed arguments to our subroutines.

The easiest way to retrieve arguments passed to a program is 
to use a special subroutine named \verb'MAIN'. A program that 
has a defined \verb'MAIN' subroutine will usually start its execution 
with that subroutine and the command-line arguments supplied 
to the program will be passed as arguments to \verb'MAIN'. 
The \verb'MAIN' signature will enable you to 
retrieve the arguments provided in the command line and 
possibly also check their validity.
\index{signature}

For example, the {\tt greet.pl6} program might look like 
this:
\begin{verbatim}
sub MAIN (Str $name) {
    say "Hello $name";
}
\end{verbatim}

You may call this program twice with different command-line 
arguments as follows:

\begin{verbatim}
$ perl6 greet.pl6 Larry
Hello Larry

$ perl6 greet.pl6 world
Hello world
\end{verbatim}

It is very easy to change the argument, since all you need 
to do at the operating system command line is use the up arrow 
and edit the end of the previous command line.

If you forget to supply the argument (or provide the wrong 
number of arguments, or arguments not matching the signature), 
the program will die and Perl~6 will nicely generate and 
display a usage method:

\begin{verbatim}
$ perl6 greet.pl6
Usage:
  greet.pl6 <name>
\end{verbatim}


\section{Debugging}
\label{whitespace}
\index{debugging}
\index{traceback}

When a syntax or runtime error occurs, the error message contains
a lot of information, but it can be overwhelming.  The most
useful parts are usually:

\begin{itemize}

\item What kind of error it was

\item Where it occurred

\end{itemize}

Syntax errors are usually easy to find, but there are a few
gotchas. In general, error messages indicate where the problem 
was discovered, but the actual error might be earlier in 
the code, sometimes on a previous line or even many lines 
before.
\index{multiplication tables}

For example, the goal of the following code was to display the 
multiplication tables:

\begin{verbatim}
# WARNING: faulty code
sub multiplication-tables {
    for 1..10 -> $x {
        for 1..10 -> $y {
            say "$x x $y\t= ", $x * $y;
        say "";
    }
}

multiplication-tables();
\end{verbatim}

It failed at compilation with the following error:

\begin{verbatim}
$ perl6 mult_table.pl6
===SORRY!=== Error while compiling /home/Laurent/mult_table.pl6
Missing block (taken by some undeclared routine?)
at /home/Laurent/mult_table.pl6:9
------> multiplication-tables();<HERE><EOL>
\end{verbatim}

The error message reports an error on line~9 of the program 
(the last line of the code), at the end of the line, but 
the actual error is a missing closing brace after line~4 
and before line~5. The reason for this is that, while the 
programmer made the mistake on line~4, the Perl interpreter 
could not detect this error before it reached the 
end of the program. The correct program for displaying 
multiplication tables might be:

\begin{verbatim}
sub multiplication-tables {
    for 1..10 -> $x {
        for 1..10 -> $y {
            say "$x x $y\t= ", $x * $y;
        }
        say "";
    }
}
multiplication-tables();
\end{verbatim}

When an error is reported on the last line of a program, 
it is quite commonly due to a missing closing parenthesis, 
bracket, brace, or quotation mark several lines earlier. 
An editor with syntax highlighting can sometimes help you.
\index{syntax!highlighting}

\index{error!runtime}
\index{runtime error}

The same is true of runtime errors. Consider this program 
aimed at computing 360 degrees divided successively by 
the integers between 2 and 5:

\begin{verbatim}
# WARNING: faulty code
my ($a, $b, $c, $d) = 2, 3, 5;
my $value = 360;
$value /= $_ for $a, $b, $c, $d;
say $value;
\end{verbatim}

This programs compiles correctly but displays a warning and 
then an exception on runtime:

\begin{verbatim}
Use of uninitialized value of type Any in numeric context 
in block  at product.pl6 line 3
Attempt to divide 12 by zero using div
  in block <unit> at product.pl6 line 4
\end{verbatim}
%

The error message indicates a ``division by zero'' exception 
on line~4, but there is nothing wrong with that line. 
The warning on line~3 might give us a clue that the 
script attempts to use an undefined value, but the real error 
is on the first line of the script, where one of the four 
necessary integers (4) was omitted by mistake from the list 
assignment.

\index{division by zero}
\index{uninitialized value}

You should take the time to read error messages carefully, 
but don't assume they point to the root cause of the 
exception; they often point to subsequent problems.


\section{Glossary}

\begin{description}

\item[Integer division] An operation, denoted {\tt div}, 
that divides two numbers and rounds down (toward zero) the 
result to an integer.
  \index{integer division} 
  \index{division!integer}

\item[Modulo operator]  An operator, denoted with a percent sign
({\tt \%}), that works on integers and returns the remainder when one
number is divided by another.
\index{modulo operator}
\index{operator!modulo}

\item[Boolean expression]  An expression whose value is either 
{\tt True} or {\tt False}.
\index{Boolean expression}
\index{expression!Boolean}

\item[Relational operator] One of the operators that compares
its operands. The most common numeric relational operators are 
{\tt ==}, {\tt !=}, {\tt >}, {\tt <}, {\tt >=}, and {\tt <=}. 
The equivalent string relational operators are {\tt eq}, {\tt ne}, 
{\tt gt}, {\tt lt}, {\tt ge}, and {\tt le}.

\item[Logical operator] One of the operators that combines Boolean
expressions: {\tt and}, {\tt or}, and {\tt not}. The equivalent 
higher-precedence operators are {\tt \&\&}, {\tt ||}, and {\tt !}

\item[Conditional statement]  A statement that controls the 
flow of execution depending on some condition.
\index{conditional!statement}
\index{statement!conditional}

\item[Condition] The boolean expression in a conditional 
statement that determines which branch runs.
\index{condition}

\item[Branch] One of the alternative sequences of statements in
a conditional statement.
\index{branch}

\item[Chained conditional]  A conditional statement with a 
series of alternative branches.
\index{chained conditional}
\index{conditional!chained}

\item[Nested conditional]  A conditional statement that appears
in one of the branches of another conditional statement.
\index{nested conditional}
\index{conditional!nested}

\item[Statement modifier] A postfix conditional expression, i.e., 
a conditional expression (using for example {\tt if}, {\tt unless} or 
{\tt for}) that is placed after the statement the executions of which 
it controls. It can also refer to a postfix looping expression.
\index{statement modifier}

\item[Return statement] A statement that causes a function to
end immediately and return to the caller.

\item[Recursion]  The process of calling the function that is
currently executing.
\index{recursion}

\item[Base case]  A conditional branch in a
recursive function that does not make a recursive call.
\index{base case}

\item[Infinite recursion]  A recursion that doesn't have a
base case, or never reaches it.  Eventually, an infinite 
recursion causes a runtime error, for which you may not want 
to wait because it may take a long time.
\index{infinite recursion}

\end{description}

\section{Exercises}
%

\begin{exercise}
%
Using the integer division and the modulo operators:
\index{modulo operator}
\index{operator!mod}
\index{mod, modulo operator}
\index{integer division}
\index{operator!div}
\index{div operator}
\label{int_div_modulo}

\begin{enumerate}

\item Write a subroutine that computes how many days, hours, minutes and seconds there are in the number of seconds passed as an argument to the subroutine.

\item Write a script that computes how many days, hours, minutes and seconds there are in 240,000 seconds.

\item Change your script to compute the number of days, hours, minutes and seconds there are in a number of seconds entered by the script user when prompted to give a number of seconds.

\end{enumerate}

Solutions: Subsection~\ref{sol_int_div_modulo}.

\end{exercise}


\begin{exercise}
\index{Fermat's Last Theorem}
\label{fermat_ex}

Fermat's Last Theorem says that there are no positive integers
$a$, $b$, and $c$ such that

\[ a^n + b^n = c^n \]
%
for any values of $n$ greater than 2.

\begin{enumerate}

\item Write a function named \verb"check-fermat" that takes four
parameters---{\tt a}, {\tt b}, {\tt c}, and {\tt n}---and
checks to see if Fermat's theorem holds.  If
$n$ is greater than 2 and 

\[a^n + b^n = c^n \]
%
the program should print, ``Holy smokes, Fermat was wrong!''
Otherwise the program should print, ``No, that doesn't work.''

\item Write a function that prompts the user to input values
for {\tt a}, {\tt b}, {\tt c}, and {\tt n}, converts them to
integers, and uses \verb"check-fermat" to check whether they
violate Fermat's theorem.
\end{enumerate}

Solution: \ref{sol_fermat_ex}


\end{exercise}


\begin{exercise}
\index{triangle}
\label{triangle}

If you are given three sticks, you may or may not be able to arrange
them in a triangle.  For example, if one of the sticks is 12 inches
long and the other two are one inch long, you will
not be able to get the short sticks to meet in the middle.  For any
three lengths, there is a simple test to see if it is possible 
to form a triangle:

\begin{quotation}
If any of the three lengths is greater than the sum of the other
  two, then you cannot form a triangle.  Otherwise, you
  can.  (If the sum of two lengths equals the third, they form
    what is called a ``degenerate'' triangle.)
\end{quotation}

\begin{enumerate}

\item Write a function named \verb"is-triangle" that takes three
positive numbers as arguments, and that prints either 
``Yes'' or ``No,'' depending on whether you can 
form a triangle from sticks with the given lengths.

\item Write a function that prompts the user to input 
three stick lengths and uses \verb"is-triangle" to check 
whether sticks with the given lengths can form a triangle.

\end{enumerate}

Solution: \ref{sol_triangle}


\end{exercise}

\begin{exercise} 
\index{Fibonacci!numbers}
\label{fibonacci}
The Fibonacci numbers were invented by Leonardo Fibonacci 
(a.k.a. Leonardo of Pisa or simply Fibonacci), an Italian 
mathematician of the thirteenth century.
\index{Fibonacci, Leonardo}

The Fibonacci numbers are a sequence of numbers such as:

\[1, \;1, \;2, \;3, \;5, \;8, \;13, \;21, \;34, \ldots\]
%
in which the first two numbers are equal to 1 and each 
subsequent number of the sequence is defined as the sum of 
the previous two (for example, $5 = 2 + 3$, $8 = 3 + 5$, etc.).

In mathematical notation, the Fibonacci numbers could be defined by recurrence as follows:

\[F_1 = 1, \;F_2 = 1, \;\;and\;\;  F_n = F_{n-1} + F_{n-2} \]
%
\begin{enumerate}

\item Write a program using a {\tt for} loop that prints on screen the first 20 Fibonacci numbers.

\item Write a program which prompts the user to enter a number 
$n$ and, using a {\tt for} loop, computes and displays the 
$n^{th}$ Fibonacci number.

\end{enumerate}

Solution: \ref{sol_fibonacci}


\end{exercise}

\begin{exercise}
\label{sub_recurse}
\index{recursion}

What is the output of the following program?
Draw a stack diagram that shows the state of the program
when it prints the result.

\begin{verbatim}[fontshape=up]
sub recurse($n, $s) {
    if ($n == 0) {
        say $s;
    } else {
        recurse $n - 1, $n + $s;
    }
}
recurse 3, 0;
\end{verbatim}

\begin{enumerate}

\item What would happen if you called the function like 
this: {\tt recurse(-1, 0)}?

\item Write a documentation comment (maybe in the form of a multiline comment) that explains everything someone would need to know in order to use this function (and nothing else).

\end{enumerate}

Solution: \ref{sol_sub_recurse}

\end{exercise}


