\chapter{Bucles, Condicionales, y Recursión}
\label{conditionals}

El tema principal de  este capítulo es la sentencia {\tt if},
la cual ejecuta código diferente dependiendo del estado
del programa. Pero primero quiero introducir dos operadores
nuevos: división de enteros y módulo.


\section{División de Enteros y Módulo}

El operador {\bf división de enteros}, \verb"div", 
divide dos números y los redondea a un entero. Por ejemplo,
supón que una película se tarda 105 minutos. Podrías querer
saber cuántas horas hay en 105 minutos. En Perl, la división
convencional devuelve un número racional (en muchos lenguajes,
devuelve un número de coma flotante, que es otra forma
de representación interna de números que no son enteros):

\begin{verbatim}
> my $minutos = 105;
> $minutos / 60;
1.75
\end{verbatim}

Sin embargo, normalmente nosotros no escribimos las horas con
puntos decimales. La división de enteros devuelve el número
entero de horas, descartando la parte fraccional:
\index{operator!div}
\index{div operator}
\index{integer division}

\begin{verbatim}
> my $minutos = 105;
> my $horas = $minutos div 60;
1
\end{verbatim}

En aritmética, la división de enteros es algunas veces
llamada \emph{división euclidiana}, la cual calcula el
cociente y el residuo.
\index{Euclidean division}
\index{division remainder}

Para conseguir el residuo, podrías sustraer una hora en 
minutos:

\begin{verbatim}
> my $residuo = $minutos - $horas * 60;
45
\end{verbatim}

\index{integer division}
\index{floating-point division}
\index{division!integer}
\index{division!floating-point}
\index{modulo operator}
\index{operator!modulo}

Una alternativa es usar el {\bf operador de módulo}, \verb|%|,
el cual divide dos números y devuelve el residuo:
%\index{$%$ modulo operator}
%\index{operator!$%$ (modulo)}

\begin{verbatim}
> my $residuo = $minutos % 60;
45
\end{verbatim}
%
El operador de módulo es muy común en los lenguajes de programación
y es más útil de lo que parece. Por ejemplo, puedes chequear si
un número es divisible por otro---si {\tt \$dividendo \% \$divisor} es cero, entonces {\tt \$dividendo} es divisible por {\tt \$divisor}. 
Esto es usado comúnmente, por ejemplo, con un divisor igual a 2 para determinar si un número es par o impar. Veremos un ejemplo
de esto más adelante en este capítulo (ver Sección~\ref{alternative.execution}).
\index{divisibility}
\index{even number}
\index{odd number}
\index{integer!even}
\index{integer!odd}

Para ser sincero, Perl~6 también tiene un operador específico 
para la divisibilidad, \verb|%%|. La expresión
\verb|$dividendo %% $divisor| devuelve verdadero si 
\verb|$dividendo %% $divisor| es igual a 0,
es decir si {\tt \$dividendo} es divisible por {\tt \$divisor} 
(de lo contrario, es falso):
\index{divisibility!operator}
\begin{verbatim}
> 42 %% 2;
True
\end{verbatim}

De igual manera, puedes extraer el dígito más a la
derecha o dígitos de un número con el operador
de módulo. Por ejemplo, {\tt \$x \% 10}  extrae el
dígito más a la derecha de {\tt \$x} (en base 10).
Similarmente, {\tt \$x \% 100} extrae los últimos dos 
dígitos:

\begin{verbatim}
> 642 % 100;
42
\end{verbatim}
%
\index{modulo operator}
\index{operator!modulo}



\section{Expresiones Booleanas}
\index{Boolean expression}
\index{expression!Boolean}
\index{logical operator}
\index{operator!logical}

Una {\bf expresión booleana} es una expresión que es
verdadera o falsa. Los siguientes ejemplos usan el operador
{\tt ==} para comparar los operandos numéricos y producir
{\tt True} si son iguales y de lo contrario, {\tt False}:

\begin{verbatim}
> 5 == 5;
True
> 5 == 6;
False
\end{verbatim}
%
{\tt True} y {\tt False} son valores especiales
que pertenecen al tipo {\tt Bool}; ellos no son
cadenas de texto:
\index{True!special value}
\index{False!special value}
\index{special value!True}
\index{special value!False}
\index{Bool type}
\index{type!Bool}

\begin{verbatim}
> say True.WHAT
(Bool)
> say False.WHAT
(Bool)
\end{verbatim}
%
\index{operator!$==$ (numeric equality)}
\index{$==$ numeric equality operator}
El operador {\tt ==} es uno de los {\bf operadores de relación
numérica} y su función es chequear si los operandos son 
iguales; los otros son:

\begin{verbatim}
      $x != $y            # $x no es numéricamente igual a $y
      $x > $y             # $x es numéricamente mayor que $y
      $x < $y             # $x es numéricamente menor que $y
      $x >= $y            # $x es numéricamente mayor o igual a $y
      $x <= $y            # $x es numéricamente menor o igual a $y
      $x === $y           # $x y $y son verdaderamente idénticos
\end{verbatim}
% TODO: get these entries working in plastex
\ifplastex \else
\index{"!= numeric inequality operator@\texttt{"!=} numeric inequality operator}
\index{< less than numeric operator@\texttt{<} less than numeric operator}
\index{> greater than numeric operator@\texttt{>} greater than numeric operator}
\index{>= greater than or equal operator@\texttt{>=} greater than or equal operator}
\index{<= less than or equal operator@\texttt{<=} less than or equal operator}
\index{=== value identity operator@\texttt{===} value identity operator}
\index{operator!"!= (numeric inequality)@\texttt{"!=} (numeric inequality)}
\index{operator!< (numerically less than)@\texttt{<} (numerically less than)}
\index{operator!> (numerically greater than)@\texttt{>} (numerically greater than)}
\index{operator!>= (greater than or equal)@\texttt{>=} (greater than or equal)}
\index{operator!<= (less than or equal)@\texttt{<=} (less than or equal)}
\index{operator!=== (value identity)@\texttt{===} (value identity)}
\fi
Aunque estas operaciones probablemente son familiares, los
símbolos en Perl son diferentes a los símbolos matemáticos.
Un error común es usar un solo signo de igualdad ({\tt =}) en vez de 
dos signos de igualdad ({\tt ==}). Recuerda que {\tt =} es el
operador de asignación y {\tt ==} es un operador de relación.
No existe tal cosa como {\tt =<}, aunque existe el operador {\tt =>},
el cual no es un operador de relación sino algo completamente
distinto (como veremos más adelante, dicho operador es el constructor 
de pares). 
\index{relational operator}
\index{relational operator!numeric}
\index{numeric relational operator}
\index{equality operator}
\index{operator!equal}
\index{operator!relational}
\index{pair constructor}
\index{constructor!pair}
% TODO: get these entries working in plastex
\ifplastex \else
\index{=> pair constructor@\texttt{=>} pair constructor}
\index{operator!=> (pair constructor)@\texttt{=>} (pair constructor)}
\fi

La diferencia entre {\tt ==} y {\tt ==} es que el primer
operador chequea si los valores de los operandos son iguales
y el último chequea si los  operandos son verdaderamente
idénticos. Como un ejemplo, considera esto:

\begin{verbatim}
say 42 ==  42;           # True
say 42 ==  42.0;         # True
say 42 ===  42;          # True
say 42 === 42.0;         # False
\end{verbatim}
%

Estos operadores de relación pueden solo comparar 
valores numéricos (números o variables que contienen
números) o valores que se pueden coaccionar en 
valores numéricos, tal como, por ejemplo,
la cadena de texto "42" la cual, si se usa con estos
operadores (excepto {\tt ===}), serán coaccionada 
en el número 42.
\index{coercion}

Para la comparación de cadenas de texto (en un tipo de 
comparación lexicográfica o ``pseudo-alfabética``),
necesitas usar los {\bf operadores de relación de cadena
de texto}:

\begin{verbatim}
      $x eq $y            # $x es una cadena de texto igual a $y
      $x ne $y            # $x no es una cadena de texto igual a $y
      $x gt $y            # $x es mayor que $y (alfabéticamente después)
      $x lt $y            # $x es menor que $y (alfabéticamente antes)
      $x ge $y            # $x es mayor o igual a  $y
      $x le $y            # $x es menor o igual a  $y
      $x eqv $y           # $x es verdaderamente equivalente a $y
\end{verbatim}
%  
\index{relational operator}
\index{relational operator!string}
\index{string!relational operator}
\index{operator!relational}
\index{eq, string equality operator}
\index{operator!eq (string equality)}
\index{ne, string inequality operator}
\index{operator!ne (string inequality)}
\index{operator!gt (alphabetically after)}
\index{operator!lt (alphabetically before)}



Por ejemplo, puedes comparar (alfabéticamente) los nombres
de dos presidentes de los Estados Unidos:
\begin{verbatim}
> 'FDR' eq 'JFK';
False
> 'FDR' lt 'JFK';    # comparación alfabética
True
\end{verbatim}
%  

A diferencia de otros lenguajes de programación, Perl~6 te permite 
encadenar varios operadores de relación de forma transitiva,
al igual que en notación matemática:

\begin{verbatim}
say 4 < 7 < 12;      # True
say 4 < 7 < 5;       # False
\end{verbatim}
\index{chained relational operator}

Es necesario aclarar que los operadores de relación
numérica y los operadores de relación de cadena de texto no 
funciona de la misma manera (y esta es una buena razón 
para tener operadores diferentes), porque ellos no poseen
la misma idea de lo que \emph{mayor que} o \emph{menor que}.

Al comparar dos enteros positivos, un número con cuatro dígitos
es siempre mayor que un número con solo dos o tres dígitos. 
Por ejemplo, 1110 es mayor que 886. 

Por lo contrario, la comparación de cadenas de texto
sigue básicamente reglas (pseudo) alfabéticas: 
``b'' es mayor que ``aaa'', porque la regla comúnmente
aceptada para la comparación de cadenas de texto es
comenzar a comparar la primera letra de cada cadena
de texto: si las dos letras son diferentes se sabe cuál de
las dos cadenas es mayor sin importar el carácter que viene
a continuación; necesitas proceder con la comparación
de la segunda letra de cada palabra solo si la comparación
de la primera letra de cada cadena termina en un empate, etc.
Así que cualquier palabra que inicia con ``a`` es menor que 
cualquier palabra que inicie con ``b``, sin importar la longitud
de estas palabras. Esto puede parecer algo minucioso, no 
obstante esto se vuelve esencial cuando comienzas 
a ordenar elementos: realmente tienes que pensar qué tipo
de orden (numérico o alfabético) quieres usar.
\index{sorting}

También existen los operadores de relación de ``tres bandas``,
{\tt cmp}, {\tt <=>} y {\tt leg}, pero regresaremos a ellos
cuando estudiemos cómo ordenar los elementos de una lista. 
Similarmente, necesitamos aprender otras cosas sobre Perl antes
que podamos justificar el increíblemente poderoso y expresivo
operador de \emph{coincidencia inteligente}, \verb|~~|.
\index{sorting}
\index{smart match operator}
\index{operator!smart match}
\index{three-way operator}
\index{operator!three-way}
\index{cmp operator}
\index{leg operator}
\index{operator!leg}
% TODO: get these entries working in plastex
\ifplastex \else
\index{<=> operator@\texttt{<=>} operator}
\index{operator!<=> (numeric comparison)@\texttt{<=>} (numeric comparison)}
\fi

Un punto final acerca de la comparación de cadenas
de texto es que las letras mayúsculas son siempre menores
que las letras minúsculas. Así que  "A," "B," "BB," y "C"
son \emph{todas} menores que "a," "b," "bb," y "c".
No discutiremos los detalles aquí pero esto se vuelve
complicado (y algo confuso) cuando las cadenas de texto
a ser comparadas contienen caracteres no alfabéticos (
o letras Unicode que no son ASCII).

\section{Operadores Lógicos}
\index{logical operator}
\index{operator!logical}

Hay tres pares principales de {\bf operadores lógicos}:
\begin{itemize}
\item lógico \emph{and} (y) : ``{\tt and}'' y {\tt \&\&}
\item lógico \emph{or} (o): ``{\tt or}'' y {\tt ||}
\item lógico \emph{not} (no): ``{\tt not}'' y {\tt !}
\end{itemize}

La semántica (significado) de estos operadores es similar
a sus significados en inglés (y en español). Por ejemplo,
{\tt \$x > 0 and \$x < 10} es verdadera solo si {\tt \$x}
es mayor que 0 \emph{and} menos que 10.
\index{and operator}
\index{or operator}
\index{not operator}
\index{operator!and}
\index{operator!or}
\index{operator!not}

{\tt \$n \% 2 == 0 and \$n \% 3 == 0} es verdadero si {\em ambas}
condiciones son verdaderas, es decir, si el número es divisible por
2 \emph{and} por 3, i.e., es de hecho divisible por 6 (que podría
ser mejor escrito así: {\tt \$n \% 6 == 0} or {\tt \$n \%\% 6}).

{\tt \$n \% 2 == 0 or \$n \% 3 == 0} es verdadero si \emph{una o ambas}
condiciones son verdaderas, es decir, si el número es divisible por 2
\emph{or} por 3 (or ambos).

Finalmente, el operador {\tt not} niega una expresión Booleana,
así que {\tt not (x > y)} es verdadero si {\tt x > y} es falso, es
decir, si {\tt x} es menor o igual {\tt y}.

Los operadores {\tt \&\&}, {\tt ||}, y {\tt !} tienen el mismo
significado, respectivamente, como {\tt and}, {\tt or}, y {\tt not},
pero una precedencia más estricta, lo que significa 
que cuando están en una expresión con algunos otros operadores,
ellos tienen una mayor precedencia de ejecución. Volveremos
con la precedencia más adelante, pero digamos por el tiempo
presente que, en los casos más comunes, los operadores 
{\tt and}, {\tt or}, y {\tt not} usualmente serán suficientes
para hacer lo que deseas.
\index{precedence}      
\index{operator precedence}

En sentido estricto, los operandos de los operadores lógicos
deberían ser expresiones Booleanas, pero Perl, como muchos
otros lenguajes derivados parcialmente de C, no es estricto
con respecto a eso. Los números~0 y 0.0 son falsos; y cualquier
número que no sea cero o una cadena de cuerda que no esté 
vacía es interpretado como {\tt True}:

\begin{verbatim}
> 42 and True;
True
\end{verbatim}
%
Aunque esta flexibilidad puede ser muy útil, existen 
sutilezas que pueden ser confusas. A menos que sepas
lo que estás haciendo, esto es algo que deberías evitar.

La función integrada {\tt so} devuelve una evaluación 
de sus argumentos:

\begin{verbatim}
> say so (0 and True);
False
\end{verbatim}
%
Aquí la expresión {\tt (0 and True)} es falsa porque 0 es falso
y la expresión sería verdadera solo si ambos argumentos del operador
{\tt and} son verdaderos.

Cuando varias condiciones Booleanas son enlazadas con algunos
operadores lógicos, Perl solo realizará la comparaciones que son
estrictamente necesarias para descifrar el resultado final,
comenzando con aquellas en la izquierda. Por ejemplo, si escribes:

\begin{verbatim}
> False and $número > 0;
False
\end{verbatim}
%
no hay necesidad de evaluar la segunda expresión Booleana
para saber que la expresión completa será falsa. En este caso,
Perl no trata de chequear si el número es positivo o hasta si
está definido. Se dice que estos operadores realizan una evaluación
de ``cortocircuito`` con las condiciones innecesarias.
\index{short-circuit boolean operators}
\index{short-circuit evaluation}

De la misma manera, en el siguiente código, la subrutina 
{\tt calcular-pensión} no será llamada si la edad de la persona
es menos de 65:

\begin{verbatim}
$edad >= 65 and calcular-pensión();
\end{verbatim}
%
Lo mismo ocurre con el operador {\tt or}, pero de
manera completamente distinta: si la primera expresión booleana
de una sentencia {\tt or} es verdadera, entonces la siguiente
expresión no será evaluada. El siguiente código es equivalente
al anterior:

\begin{verbatim}
$edad < 65 or calcular-pensión();
\end{verbatim}
% 
Esta \emph{puede} ser una forma de ejecutar la subrutina
{\tt calcular-pensión} condicionalmente, dependiendo del 
valor de la edad, y esto se usa usualmente en construcciones
tal como:

\begin{verbatim}
haz-algo() or die "no pude hacer algo";
\end{verbatim}
%
la cual aborta el programa si {\tt haz-algo} devuelve un 
valor falso, lo cual quiere decir que fue incapaz de hacer 
algo tan esencial que no vale la pena continuar con su
ejecución.

Más adelante examinaremos formas más claras y comunes
de ejecutar código con condicionales.

\section{Ejecuciones Condicionales}
\label{conditional.execution}

\index{conditional!statement}
\index{statement!conditional}
\index{if statement}
\index{statement!if}
\index{conditional!execution}
Para escribir programas útiles, casi siempre necesitamos la habilidad 
de evaluar condiciones y cambiar el comportamiento del programa
adecuadamente. Las {\bf sentencias condicionales} nos brindan esta
habilidad. La forma más simple es la sentencia {\tt if}:

\begin{verbatim}
if $número > 0 {
    say '$número es positivo';
}
\end{verbatim}
%
La expresión Booleana después de {\tt if} se conoce 
como la condición. Si la condición es verdadera, el
bloque de código subsecuente se ejecuta. Si es falsa, 
nada pasa. El bloque de código puede contener cualquier
cantidad de sentencias.
\index{condition}

Es una convención y muy recomendado (aunque no es mandatario
desde la perspectiva del compilador) indentar las sentencias
del bloque, para así ayudar con la visualización del 
\emph{flujo de control} del programa, i.e., su estructura
de ejecución: con tal indentación, podemos ver mucho mejor 
que las condiciones dentro del bloque serán ejecutadas solo 
si la condición es verdadera.
\index{indentation}

La condición puede ser una expresión Booleana compuesta:
\begin{verbatim}
if $n > 0 and $n < 20 and $n %% 2 {
    say '$n es un número par y positivo menor que 20'
}
\end{verbatim}
%
Nota que en la sentencia de impresión anterior, el punto y coma
final se omitió. Cuando una sentencia es la última línea de
código de un bloque, inmediatamente antes de la llave derecha
{\tt \}} que cierra el bloque, el punto y coma final es opcional
y puede ser omitido, aunque sería recomendable incluirlo.
\index{omitting the semi-colon}
\index{semi-colon, omitting}
\index{bracket!curly}
\index{curly bracket}
\index{curly brace}

En teoría, el fragmento de código anterior es por sí mismo una
sentencia y debería también terminar con un punto y coma después
de la llave derecha. Pero una llave derecha seguida por un carácter
de nueva línea implica un separador de sentencia, así que no 
necesitas un punto y coma ahí y por lo tanto, es generalmente
omitido.
\index{omitting the semi-colon}
\index{semi-colon, omitting}



\section{Alternative Execution}
\label{alternative.execution}
\index{alternative execution}
\index{else keyword}
\index{keyword!else}

A second form of the {\tt if} statement is ``alternative execution,'' 
in which there are two possibilities and the condition determines
which one runs.  Given a \verb'$number' variable containing an 
integer, the following code displays two different messages 
depending on whether the value of the integer is even or odd:

\begin{verbatim}
if $number % 2 == 0 {
    say 'Variable $number is even'
} else {
    say 'Variable $number is odd'
}
\end{verbatim}
%
\index{even number}
\index{odd number}
\index{integer!odd}
\index{integer!even}
If the remainder when {\tt \$number} is divided by 2 is 0, 
then we know that {\tt \$number} is even, and the program 
displays an appropriate message.  If
the condition is false, the second set of statements runs.
Since the condition must be true or false, exactly one of the
alternatives will run.  The alternatives are called 
{\bf branches}, because they are branches in the flow of 
execution.
\index{branch}

Note that if \verb'$number' is evenly divisible by two, 
this code will print:

\begin{verbatim} 
Variable $number is even
\end{verbatim}

The \verb'$number' variable value is not interpolated, 
because we used single quotes for the purpose 
of printing out the variable name rather 
than its value. We would have to use double quotes if 
we wanted to display the variable's value instead of its 
name.
\index{single quote}
\index{double quote}
\index{quote!single}
\index{quote!double}
\index{variable!interpolation}
\index{interpolation}


\section{Chained Conditionals}
\index{chained conditional}
\index{conditional!chained}

Sometimes there are more than two possibilities and we need more than
two branches.  One way to express a computation like that is a 
{\bf chained conditional}:

\begin{verbatim}
if $x < $y {
    say 'Variable $x is less than variable $y'
} elsif $x > $y {
    say 'Variable $x is greater than variable  $y' 
} else {
    say 'Variables $x and $y are equal'
}
\end{verbatim}
%
The {\tt elsif} keyword is an abbreviation of ``else if'' that 
has the advantage of avoiding nesting of blocks. Again, exactly one
branch will run.  There is no limit on the number of {\tt
elsif} statements.  

If there is an {\tt else} clause, it has to be
at the end, but there doesn't have to be one:
\index{elsif keyword}
\index{keyword!elsif}

\begin{verbatim}
if $choice eq 'a' {
    draw_a()
} elsif $choice eq 'b' {
    draw_b()
} elsif $choice eq 'c' {
    draw_c()
}
\end{verbatim}
%
Each condition is checked in order.  If the first is false,
the next is checked, and so on.  If one of them is
true, the corresponding branch runs and the statement
ends.  Even if more than one condition is true, only the
first true branch runs.


\section{Nested Conditionals}
\index{nested conditional}
\index{conditional!nested}

One conditional can also be nested within another.  We could have
written the example in the previous section like this:

\begin{verbatim}
if $x == $y {
    say 'Variables $x and $y are equal'
} else {
    if $x < $y {
        say 'Variable $x is less than variable $y'
    } else {
        say 'Variable $x is greater than variable $y'
    }
}
\end{verbatim}
%
The outer conditional contains two branches.  The
first branch contains a simple statement.  The second branch
contains another {\tt if} statement, which has two branches of its
own.  Those two branches are both simple statements,
although they could have been conditional statements as well. 
The \verb'if $x < $y' conditional is said to be nested within 
the {\tt else} branch of the outer conditional.

Such nested conditionals show how critical it is for your 
own comprehension to properly indent conditional statements, 
as it would be very difficult here to visually grasp the 
structure without the help of correct indentation.
\index{indentation}

Although the indentation of 
the statements helps make the structure apparent, 
{\bf nested conditionals} become difficult to read very 
quickly.  It is a good idea to avoid them when you can.
Logical operators often provide a way to simplify nested 
conditional statements.  For example, consider the 
following code (which assumes \verb'$x' to be an integer):
\index{logical operator}

\begin{verbatim}
my Int $x;
# ... $x = ...;
if 0 < $x {
    if $x < 10 {
        say 'Value of $x is a positive single-digit number.'
    }
}
\end{verbatim}
%
The {\tt say} statement runs only if we make it past both
conditionals, so we can get the same effect with the {\tt and} 
Boolean operator, and the code can be rewritten using a 
single conditional:

\begin{verbatim}
if 0 < $x and $x < 10 {
    say '$x is a positive single-digit number.'
}
\end{verbatim}

For this kind of condition, Perl~6 provides a more concise 
option using the chained relational operators described earlier:

\begin{verbatim}
if 0 < $x < 10 {
    say '$x is a positive single-digit number.'
}
\end{verbatim}
\index{chained relational operator}

\section{If Conditionals as Statement Modifiers}
\index{statement modifier} \index{modifier!statement}
\index{postfix conditional} \index{conditional!postfix }

There is also a form of {\tt if} called a {\bf statement 
modifier} (or sometimes  ``postfix conditional'') form when there is only 
one conditional statement. In this case, the {\tt if} and the 
condition come after the code you want to run conditionally. Note 
that the condition is still always evaluated first:

\begin{verbatim}
say '$number is negative.' if $number < 0;
\end{verbatim}
%
This is equivalent to:
\begin{verbatim}
if $number < 0 {
    say '$number is negative.' 
}
\end{verbatim}
%
This syntactic form is more concise as it takes only one code 
line instead of three. The advantage is that you can see more
of your program code on one screen, without having to scroll up 
and down. However, this syntax is neat and clean only when 
both the condition and the statement are short and simple, so it 
is probably best used only in these cases.

The statement modifier form does not allow {\tt else} and
{\tt elsif} statements.

\section{Unless Conditional Statement}
\index{unless statement}
\index{keyword!unless}

If you don't like having to write negative conditions in a conditional
{\tt if} statement such as:
%
\begin{verbatim}
if not $number >= 0 {
    say '$number is negative.' 
}
\end{verbatim}
%

you may write this instead:
\begin{verbatim}
unless $number >= 0 {
    say '$number is negative.' 
}
\end{verbatim}
%
This \verb'unless' keyword does exactly what the English says: 
it will display the sentence ``\$number is negative.'' 
\emph{unless} the number is greater than or equal to 0.

You cannot use {\tt else} or {\tt elsif} statements with 
{\tt unless}, because that would end up getting confusing.

The {\tt unless} conditional is most commonly used in its statement modifier (or postfix notation) form:

\index{statement modifier} \index{modifier!statement}
\index{postfix conditional} \index{conditional!postfix }

\begin{verbatim}
say '$number is negative.' unless $number >= 0;
\end{verbatim}
%

\section{For Loops}
\label{for_loops}
\index{for loop}
\index{loop!for}
\index{statement!for}
\index{factorial}

Suppose you need to compute and print the product of the first 
five positive digits (1 to 5). This product is known in mathematics 
as the \emph{factorial} of 5 and is sometimes written as $5!$. 
You could write this program:

\begin{verbatim}
my $product = 1 * 2 * 3 * 4 * 5;
say $product;           # prints 120
\end{verbatim}
%

You could make it slightly simpler:
\begin{verbatim}
say 2 * 3 * 4 * 5;      # prints 120
\end{verbatim}
%

The problem is that this syntactic construct does 
not scale well and becomes tedious for the product of the first 
ten integers (or factorial 10). And it becomes almost a 
nightmare for factorial 100. 
Calculating the factorial of a number is a fairly common computation 
in mathematics (especially in the fields of combinatorics 
and probability) and in computer science. We need to 
automatize it, and using a {\tt for} 
loop is one of the most obvious ways of doing that:
\index{factorial!using a for loop}

\begin{verbatim}
my $product = 1;
for 1..5 {
    $product *= $_
}
say $product;           # prints 120
\end{verbatim}

Now, if you need to compute factorial 100, you just need to 
replace the 5 in the code above with 100. Beware, though, 
the factorial function is known to grow extremely rapidly, 
and you'll get a truly huge number, with 158 digits 
(i.e., a number much larger than the estimated total 
number of atoms in the known universe).
\index{factorial}

\index{range!operator}
\index{operator!range}
\index{special variable}
In this script, {\tt 1..5} is the range operator, which is used here 
to generate a list of consecutive numbers between 1 and 5. The 
{\tt for} keyword is used to iterate over that list, and  
\verb"$_" is a special variable that takes each successive 
value of this list: first 1, then 2, etc. until 5. In the code 
block forming the body of the loop, the {\tt \$product} variable 
is multiplied successively by each value of \verb"$_". The loop 
ends with 5 and the result, 120, is printed on the last line.

This is a simple use of the {\tt for} statement, 
but probably not the most commonly used in Perl~6; 
we will see more below. We will also see other types of loops. 
But that should be enough for now to let you write some loops. Loops 
are found everywhere in computer programming.

\index{special variable}
\index{topical variable}
\index{default method invocant}
\index{invocant}
\index{topic}
The \verb"$_" special variable is known as the \emph{topical 
variable} or simply the \emph{topic}. It does not need to be declared 
and many syntactic constructs assign a value to it without 
explicitly mentioning it. Also, \verb"$_" is a implicit argument 
to methods called without an explicit invocant. For example, 
to print the first five integers, you might write:

\begin{verbatim}
for 1..5 {.say};  # prints numbers 1 to 5, each on its line
\end{verbatim} 

Here {\tt .say} is a syntax shorthand equivalent to \verb"$_.say". 
And since, as we saw, \verb"$_" takes each successive value of 
the range introduced by the {\tt for} keyword, this very short code 
line prints each number between 1 and 5, each on a different line. 
This is a typical example of the \verb"$_" topical variable being used 
without even being explicitly mentioned. We will see many other 
uses of the \verb"$_" special variable. 

Sometimes, you don't use the \verb"$_" loop variable within the 
loop, for example if you just want to do something five times but don't 
care each time through the loop at which iteration you 
have arrived. A subroutine that prints a message \emph{n} times 
might look like this:

\begin{verbatim}
sub print-n-times (Int $n, Str $message) {
    for 1..$n { say $message }
} 
\end{verbatim} 


The {\tt for} loop also has a statement modifier or postfix form, 
used here to compute again the factorial of 5:
\index{statement modifier}
\index{postfix notation}
\index{factorial!using a for statement modifier}

\begin{verbatim}
my $product = 1;
$product *= $_ for 1..5;
say $product;           # prints 120
\end{verbatim} 

There is another syntax for the {\tt for} loop, using an explicit loop variable:
\index{factorial!using a for pointy block }

\begin{verbatim}
sub factorial (Int $num) { 
    my $product = 1;  
    for 1..$num -> $x { 
        $product *= $x
    }
    return $product
}
say factorial 10;   # 3628800
\end{verbatim} 

The {\tt for} loop in this subroutine is using what is called 
a ``pointy block'' syntax. It is essentially the same idea 
as the previous {\tt for} loops, except that, 
instead of using the \verb"$_" topical variable, we 
now declare an explicit \verb"$x" loop variable with the 
\verb"1..$num -> $x" syntax to iterate over the range 
of values. Using an explicit loop variable can make your 
code clearer when things get more complicated, for example 
when you need to nest several {\tt for} loops. We will 
see more examples of that later.
\index{pointy block}
\index{for loop}
\index{loop!for}

We will also see several other ways of computing the factorial 
of a number in this book.
\index{factorial}

\section{Recursion}
\label{recursion}
\index{recursion}

It is legal for one function or subroutine to call another;
it is also legal for a subroutine to call itself.  It may not 
be obvious why that is a good thing, but it turns out to be 
one of the most magical things a program can do. 
For example, look at the following subroutine:

\begin{verbatim}
sub countdown(Int $time-left) {
    if $time-left <= 0 {
        say 'Blastoff!';
    } else {
        say $time-left;
        countdown($time-left - 1);
    }
}
\end{verbatim}
%
If {\tt \$n} is 0 or negative, it outputs the word, 
``Blastoff!''. Otherwise, it outputs the value of 
{\tt \$time-left} and then calls a subroutine named 
{\tt countdown}---itself---passing {\tt \$n-1} as an argument.

What happens if we call the subroutine like this?

\begin{verbatim}
countdown(3);
\end{verbatim}
%
The execution of {\tt countdown} begins with {\tt \$time-left 
= 3}, and since {\tt \$time-left} is greater than 0, it 
outputs the value 3, and then calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt \$time-left = 2}, and since
{\tt \$time-left} is greater than 0, it outputs the value 2, and then calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt \$time-left = 1}, and since
{\tt \$time-left} is greater than 0, it outputs the value 1, and then calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt \$time-left = 0}, and since {\tt
\$time-left} is not greater than 0, it outputs the word, ``Blastoff!'' and then
returns.
\end{quote}

The {\tt countdown} that got {\tt \$time-left = 1} returns.
\end{quote}

The {\tt countdown} that got {\tt \$time-left = 2} returns.
\end{quote}

The {\tt countdown} that got {\tt \$time-left = 3} returns.

And then you're back in the main program.  So, the
total output looks like this:

\begin{verbatim}
3
2
1
Blastoff!
\end{verbatim}
%
A subroutine that calls itself is {\bf recursive}; the process of
executing it is called {\bf recursion}.
\index{recursion}
\index{function!recursive}

As another example, we can write a subroutine that prints a
string {\tt \$n} times:

\begin{verbatim}
sub print-n-times(Str $sentence, Int $n) {
    return if $n <= 0;
    say $sentence;
    print-n-times($sentence, $n - 1);
}
\end{verbatim}
%
If {\tt \$n <= 0}, the {\bf return statement} exits the
subroutine.  The flow of execution immediately returns to 
the caller, and the remaining lines of the subroutine don't
run. This illustrates a feature of the {\tt return} statement 
that we have not seen before: it is used here for flow 
control, i.e., to stop the execution of the subroutine and 
pass control back to the caller. Note also that, here, the 
{\tt return} statement does not return any value to the 
caller; {\tt print-n-times} is a void function.

\index{return!statement}
\index{statement!return}
\index{void function}

The rest of the subroutine is similar to {\tt countdown}: it 
displays {\tt \$sentence} and then calls itself to display 
{\tt \$sentence} $\$n - 1$ additional times.  So the number 
of lines of output is {\tt 1 + (\$n - 1)}, which
adds up to {\tt \$n}.

For simple examples like this, it may seem easier to use a {\tt
for} loop.  But we will see examples later that are hard to write
with a {\tt for} loop and easy to write with recursion, so it is
good to start early.
\index{for loop}
\index{loop!for}


\section{Stack Diagrams for Recursive Subroutines}
\label{recursive.stack}
\index{stack diagram}
\index{function frame}
\index{frame}

In Section~\ref{stackdiagram}, we used a stack diagram to represent
the state of a program during a subroutine call.  The same kind of
diagram can help interpret a recursive subroutine.

Every time a subroutine gets called, Perl creates a
frame to contain the subroutine's local variables and parameters.
For a recursive subroutine, there might be more than one frame 
on the stack at the same time.

Figure~\ref{fig.stack2} shows a stack diagram for {\tt countdown} called with
{\tt n = 3}.

\begin{figure}
\centerline
{\includegraphics[scale=0.6]{figs/stack2.png}}
\caption{Stack diagram.}
\label{fig.stack2}
\end{figure}


As usual, the top of the stack is the frame for the main 
program.
It is empty because we did not create any variables in 
it or pass any arguments to it.
\index{base case}
\index{recursion!base case}

The four {\tt countdown} frames have different values for the
parameter {\tt \$time-left}.  The bottom of the stack, where {\tt \$time-left = 0}, is
called the {\bf base case}.  It does not make a recursive call, so
there are no more frames.

As an exercise, draw a stack diagram for \verb"print-n-times" 
called with
\verb"$sentence = 'Hello'" and {\tt \$n = 2}.
Then write a function called \verb"do-n-times" that takes a function
and a number, {\tt \$num}, as arguments, and that calls
the given function {\tt \$num} times.
\label{do_n_times}

Solution: see Section~\ref{sol_do_n_times}


\section{Infinite Recursion}
\index{infinite recursion}
\index{recursion!infinite}
\index{runtime error}


If a recursion never reaches a base case, it goes on making
recursive calls forever, and the program never terminates.  This is
known as {\bf infinite recursion}, and it is generally not
a good idea. In fact, your program will not actually execute 
forever but will die at some point when the computer runs out of 
memory or some other critical resource.

You have to be careful when writing recursive subroutines. 
Make sure that you have a base case, and make sure that 
you are guaranteed to reach it. Actually, although this is not 
absolutely required by the language, I would advise you to 
take the good habit of treating the base case first.


\section{Keyboard Input}
\index{keyboard input}

The programs we have written so far accept no input from 
the user. They just do the same thing every time. Perl 
provides built-in functions that stop the program and
wait for the user to type something. 

For example, the {\tt prompt} function prompts the user with 
a question or an instruction. When the user presses 
{\sf Return} or {\sf Enter}, the program resumes and 
\verb"prompt" returns what the user typed as a string 
(without the newline character corresponding to the 
{\sf Return} key typed by the user):
\index{prompt function}
\index{function!prompt}

\begin{verbatim}
my $user = prompt "Please type in your name: ";
say "Hello $user";
\end{verbatim}
%

This is probably one of the most common ways to obtain 
interactive user input, because it is usually a good idea 
to tell the user what is expected.

Another possibility is to use the {\tt get} method (which
 reads a single line) on standard input:
\index{get function}
\index{function!get}

\begin{verbatim}
say "Please type in your name: ";
my $user = $*IN.get;
say "Hello $user";
\end{verbatim}
%
or the {\tt get} function, which reads a line from standard 
input by default:
\begin{verbatim}
say "Please type in your name: ";
my $user = get;
say "Hello $user";
\end{verbatim}
%

\section{Program Arguments and the MAIN Subroutine}
\label{MAIN}
\index{MAIN}

There is another (and often better) way to have a program 
use varying input defined by the user, which is to pass 
command-line arguments to the program, just as we have 
passed arguments to our subroutines.

The easiest way to retrieve arguments passed to a program is 
to use a special subroutine named \verb'MAIN'. A program that 
has a defined \verb'MAIN' subroutine will usually start its execution 
with that subroutine and the command-line arguments supplied 
to the program will be passed as arguments to \verb'MAIN'. 
The \verb'MAIN' signature will enable you to 
retrieve the arguments provided in the command line and 
possibly also check their validity.
\index{signature}

For example, the {\tt greet.pl6} program might look like 
this:
\begin{verbatim}
sub MAIN (Str $name) {
    say "Hello $name";
}
\end{verbatim}

You may call this program twice with different command-line 
arguments as follows:

\begin{verbatim}
$ perl6 greet.pl6 Larry
Hello Larry

$ perl6 greet.pl6 world
Hello world
\end{verbatim}

It is very easy to change the argument, since all you need 
to do at the operating system command line is use the up arrow 
and edit the end of the previous command line.

If you forget to supply the argument (or provide the wrong 
number of arguments, or arguments not matching the signature), 
the program will die and Perl~6 will nicely generate and 
display a usage method:

\begin{verbatim}
$ perl6 greet.pl6
Usage:
  greet.pl6 <name>
\end{verbatim}


\section{Debugging}
\label{whitespace}
\index{debugging}
\index{traceback}

When a syntax or runtime error occurs, the error message contains
a lot of information, but it can be overwhelming.  The most
useful parts are usually:

\begin{itemize}

\item What kind of error it was

\item Where it occurred

\end{itemize}

Syntax errors are usually easy to find, but there are a few
gotchas. In general, error messages indicate where the problem 
was discovered, but the actual error might be earlier in 
the code, sometimes on a previous line or even many lines 
before.
\index{multiplication tables}

For example, the goal of the following code was to display the 
multiplication tables:

\begin{verbatim}
# WARNING: faulty code
sub multiplication-tables {
    for 1..10 -> $x {
        for 1..10 -> $y {
            say "$x x $y\t= ", $x * $y;
        say "";
    }
}

multiplication-tables();
\end{verbatim}

It failed at compilation with the following error:

\begin{verbatim}
$ perl6 mult_table.pl6
===SORRY!=== Error while compiling /home/Laurent/mult_table.pl6
Missing block (taken by some undeclared routine?)
at /home/Laurent/mult_table.pl6:9
------> multiplication-tables();<HERE><EOL>
\end{verbatim}

The error message reports an error on line~9 of the program 
(the last line of the code), at the end of the line, but 
the actual error is a missing closing brace after line~4 
and before line~5. The reason for this is that, while the 
programmer made the mistake on line~4, the Perl interpreter 
could not detect this error before it reached the 
end of the program. The correct program for displaying 
multiplication tables might be:

\begin{verbatim}
sub multiplication-tables {
    for 1..10 -> $x {
        for 1..10 -> $y {
            say "$x x $y\t= ", $x * $y;
        }
        say "";
    }
}
multiplication-tables();
\end{verbatim}

When an error is reported on the last line of a program, 
it is quite commonly due to a missing closing parenthesis, 
bracket, brace, or quotation mark several lines earlier. 
An editor with syntax highlighting can sometimes help you.
\index{syntax!highlighting}

\index{error!runtime}
\index{runtime error}

The same is true of runtime errors. Consider this program 
aimed at computing 360 degrees divided successively by 
the integers between 2 and 5:

\begin{verbatim}
# WARNING: faulty code
my ($a, $b, $c, $d) = 2, 3, 5;
my $value = 360;
$value /= $_ for $a, $b, $c, $d;
say $value;
\end{verbatim}

This programs compiles correctly but displays a warning and 
then an exception on runtime:

\begin{verbatim}
Use of uninitialized value of type Any in numeric context 
in block  at product.pl6 line 3
Attempt to divide 12 by zero using div
  in block <unit> at product.pl6 line 4
\end{verbatim}
%

The error message indicates a ``division by zero'' exception 
on line~4, but there is nothing wrong with that line. 
The warning on line~3 might give us a clue that the 
script attempts to use an undefined value, but the real error 
is on the first line of the script, where one of the four 
necessary integers (4) was omitted by mistake from the list 
assignment.

\index{division by zero}
\index{uninitialized value}

You should take the time to read error messages carefully, 
but don't assume they point to the root cause of the 
exception; they often point to subsequent problems.


\section{Glossary}

\begin{description}

\item[Integer division] An operation, denoted {\tt div}, 
that divides two numbers and rounds down (toward zero) the 
result to an integer.
  \index{integer division} 
  \index{division!integer}

\item[Modulo operator]  An operator, denoted with a percent sign
({\tt \%}), that works on integers and returns the remainder when one
number is divided by another.
\index{modulo operator}
\index{operator!modulo}

\item[Boolean expression]  An expression whose value is either 
{\tt True} or {\tt False}.
\index{Boolean expression}
\index{expression!Boolean}

\item[Relational operator] One of the operators that compares
its operands. The most common numeric relational operators are 
{\tt ==}, {\tt !=}, {\tt >}, {\tt <}, {\tt >=}, and {\tt <=}. 
The equivalent string relational operators are {\tt eq}, {\tt ne}, 
{\tt gt}, {\tt lt}, {\tt ge}, and {\tt le}.

\item[Logical operator] One of the operators that combines Boolean
expressions: {\tt and}, {\tt or}, and {\tt not}. The equivalent 
higher-precedence operators are {\tt \&\&}, {\tt ||}, and {\tt !}

\item[Conditional statement]  A statement that controls the 
flow of execution depending on some condition.
\index{conditional!statement}
\index{statement!conditional}

\item[Condition] The boolean expression in a conditional 
statement that determines which branch runs.
\index{condition}

\item[Branch] One of the alternative sequences of statements in
a conditional statement.
\index{branch}

\item[Chained conditional]  A conditional statement with a 
series of alternative branches.
\index{chained conditional}
\index{conditional!chained}

\item[Nested conditional]  A conditional statement that appears
in one of the branches of another conditional statement.
\index{nested conditional}
\index{conditional!nested}

\item[Statement modifier] A postfix conditional expression, i.e., 
a conditional expression (using for example {\tt if}, {\tt unless} or 
{\tt for}) that is placed after the statement the executions of which 
it controls. It can also refer to a postfix looping expression.
\index{statement modifier}

\item[Return statement] A statement that causes a function to
end immediately and return to the caller.

\item[Recursion]  The process of calling the function that is
currently executing.
\index{recursion}

\item[Base case]  A conditional branch in a
recursive function that does not make a recursive call.
\index{base case}

\item[Infinite recursion]  A recursion that doesn't have a
base case, or never reaches it.  Eventually, an infinite 
recursion causes a runtime error, for which you may not want 
to wait because it may take a long time.
\index{infinite recursion}

\end{description}

\section{Exercises}
%

\begin{exercise}
%
Using the integer division and the modulo operators:
\index{modulo operator}
\index{operator!mod}
\index{mod, modulo operator}
\index{integer division}
\index{operator!div}
\index{div operator}
\label{int_div_modulo}

\begin{enumerate}

\item Write a subroutine that computes how many days, hours, minutes and seconds there are in the number of seconds passed as an argument to the subroutine.

\item Write a script that computes how many days, hours, minutes and seconds there are in 240,000 seconds.

\item Change your script to compute the number of days, hours, minutes and seconds there are in a number of seconds entered by the script user when prompted to give a number of seconds.

\end{enumerate}

Solutions: Subsection~\ref{sol_int_div_modulo}.

\end{exercise}


\begin{exercise}
\index{Fermat's Last Theorem}
\label{fermat_ex}

Fermat's Last Theorem says that there are no positive integers
$a$, $b$, and $c$ such that

\[ a^n + b^n = c^n \]
%
for any values of $n$ greater than 2.

\begin{enumerate}

\item Write a function named \verb"check-fermat" that takes four
parameters---{\tt a}, {\tt b}, {\tt c}, and {\tt n}---and
checks to see if Fermat's theorem holds.  If
$n$ is greater than 2 and 

\[a^n + b^n = c^n \]
%
the program should print, ``Holy smokes, Fermat was wrong!''
Otherwise the program should print, ``No, that doesn't work.''

\item Write a function that prompts the user to input values
for {\tt a}, {\tt b}, {\tt c}, and {\tt n}, converts them to
integers, and uses \verb"check-fermat" to check whether they
violate Fermat's theorem.
\end{enumerate}

Solution: \ref{sol_fermat_ex}


\end{exercise}


\begin{exercise}
\index{triangle}
\label{triangle}

If you are given three sticks, you may or may not be able to arrange
them in a triangle.  For example, if one of the sticks is 12 inches
long and the other two are one inch long, you will
not be able to get the short sticks to meet in the middle.  For any
three lengths, there is a simple test to see if it is possible 
to form a triangle:

\begin{quotation}
If any of the three lengths is greater than the sum of the other
  two, then you cannot form a triangle.  Otherwise, you
  can.  (If the sum of two lengths equals the third, they form
    what is called a ``degenerate'' triangle.)
\end{quotation}

\begin{enumerate}

\item Write a function named \verb"is-triangle" that takes three
positive numbers as arguments, and that prints either 
``Yes'' or ``No,'' depending on whether you can 
form a triangle from sticks with the given lengths.

\item Write a function that prompts the user to input 
three stick lengths and uses \verb"is-triangle" to check 
whether sticks with the given lengths can form a triangle.

\end{enumerate}

Solution: \ref{sol_triangle}


\end{exercise}

\begin{exercise} 
\index{Fibonacci!numbers}
\label{fibonacci}
The Fibonacci numbers were invented by Leonardo Fibonacci 
(a.k.a. Leonardo of Pisa or simply Fibonacci), an Italian 
mathematician of the thirteenth century.
\index{Fibonacci, Leonardo}

The Fibonacci numbers are a sequence of numbers such as:

\[1, \;1, \;2, \;3, \;5, \;8, \;13, \;21, \;34, \ldots\]
%
in which the first two numbers are equal to 1 and each 
subsequent number of the sequence is defined as the sum of 
the previous two (for example, $5 = 2 + 3$, $8 = 3 + 5$, etc.).

In mathematical notation, the Fibonacci numbers could be defined by recurrence as follows:

\[F_1 = 1, \;F_2 = 1, \;\;and\;\;  F_n = F_{n-1} + F_{n-2} \]
%
\begin{enumerate}

\item Write a program using a {\tt for} loop that prints on screen the first 20 Fibonacci numbers.

\item Write a program which prompts the user to enter a number 
$n$ and, using a {\tt for} loop, computes and displays the 
$n^{th}$ Fibonacci number.

\end{enumerate}

Solution: \ref{sol_fibonacci}


\end{exercise}

\begin{exercise}
\label{sub_recurse}
\index{recursion}

What is the output of the following program?
Draw a stack diagram that shows the state of the program
when it prints the result.

\begin{verbatim}[fontshape=up]
sub recurse($n, $s) {
    if ($n == 0) {
        say $s;
    } else {
        recurse $n - 1, $n + $s;
    }
}
recurse 3, 0;
\end{verbatim}

\begin{enumerate}

\item What would happen if you called the function like 
this: {\tt recurse(-1, 0)}?

\item Write a documentation comment (maybe in the form of a multiline comment) that explains everything someone would need to know in order to use this function (and nothing else).

\end{enumerate}

Solution: \ref{sol_sub_recurse}

\end{exercise}


