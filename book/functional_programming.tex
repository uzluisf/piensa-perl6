\chapter{Programación Funcional en Perl}
\label{functional programming}
\index{functional programming}

La programación funcional es un paradigma de programación que 
trata una computación como la evaluación de funciones matemáticas
y evita el cambio de estado y datos mutables. Es un paradigma de
programación declarativo, lo cual significa que la programación
se hace con expresiones o declaraciones en lugar de sentencias.
En el código funcional, el valor de la salida de una función 
depende solamente de los argumentos que son la entrada de la
función, así que llamar una función dos veces con el mismo argumento
producirá el mismo resultado cada vez. La eliminación de los efectos 
secundarios, i.e., cambios en el estado que no dependen en las
entradas de la función, hacen que entender y predecir el comportamiento
de un programa sea más fácil, lo cual es una de las principales 
motivaciones para el desarrollo de la programación funcional.


Perl no es un lenguaje funcional dado que también usa otros
paradigmas de programación que hemos visto en abundancia en
este libro. Sin embargo, Perl ofrece características y capacidades
extensivas de la programación funcional, algunas de las cuales
han sido introducidas en varias secciones de este libro y 
que revisaremos brevemente antes de entrar en más detalles.
\index{programming paradigm}

\section{Funciones de Orden Superior}
\index{higher-order function}

Desde el capítulo~\ref{funcchap} sobre funciones y subrutinas,
en la Sección~\ref{first_class} (p.~\pageref{first_class}),
hemos observado que funciones,subrutinas, y otros objetos de
código son \emph{objetos de primera clase} o 
\emph{ciudadanos de primera clase} en Perl, lo cual significa que
pueden pasarse como valores. Una función en Perl~6 es
un valor que puedes asignar a una variable o pasar como
un argumento a otra función o un valor de retorno desde otra
función.
\index{first-class object}
\index{object, first-class}
\index{first-class citizen}
\index{citizen, first-class}

\subsection{Breve Actualización: Funciones como Objetos de Primera Clase}
\label{fco-refresher}

Nuestro ejemplo inicial muy simple de una función de orden 
superior fue algo así:

\begin{verbatim}
sub do-twice($código) {
	$código();
	$código();
}
sub saludar {
    say "¡Hola Mundo!";
}
do-twice &saludar;
\end{verbatim}

en el cual la subrutina {\tt saludar} se pasa como un 
argumento a la subrutina {\tt do-twice}, con el efecto
de imprimir el saludo dos veces. Una función que se pasa
como un argumento a otra función es llamada usualmente
una \emph{función retrollamada} (del inglés \emph{callback function}).
\index{callback function}

\index{sigil}
El sigilo \verb|&| colocado antes del nombre de la subrutina {\tt saludar}
en la lista de argumentos (como también antes del parámetro 
{\tt code} en la signatura y en el cuerpo de la subrutina {\tt do-twice})
le dice a Perl que estás pasando una subrutina u otro
objeto código que puede ser llamado.
% TODO: get these entries working in plastex
\ifplastex \else
\index{\& sigil@\texttt{\&} sigil}
\fi

En la ciencia de la computación, una subrutina que puede tomar
otra subrutina como un argumento es algunas veces llamada
una \emph{función de orden superior}.
\index{higher-order function}
\index{function!higher-order}

Más ejemplos interesantes de funciones de orden superior
pueden encontrarse con las funciones {\tt reduce}, {\tt map}, y
{\tt grep} que estudiamos en la Sección~\ref{map_filter} 
(p.~\pageref{map_filter}), al igual que la función {\tt sort}
(Section~\ref{sorting} and Section~\ref{advanced_sort}).
\index{map}
\index{reduce}
\index{grep}

Consideremos por ejemplo la tarea de ordenar registros por fechas,
los cuales consisten de un identificador seguido por una fecha
en el formato DD-MM-YYYY, tal como ``id1;13-05-2015'' o ``id2;17-04-2015''.
Los registros necesitan un poco de transformación antes
que podamos compararlos con el propósito de encontrar el orden
cronológico en el cual deberían ser ordenados, así que podríamos
una función separada para la comparación:
\index{sort}

\begin{verbatim}
sub comparar ($reg1, $reg2) {
    my $cmp1 = join ",", reverse split /<[;-]>/, $reg1;
    my $cmp2 = join ",", reverse split /<[;-]>/, $reg2;
    return $cmp1 cmp $cmp2;
}   
\end{verbatim}

Cada registro modificado se construye al encadenar tres funciones.
Estas líneas deberían leerse de derecha a izquierda: primero, 
el valor de entrada se separa en cuatro artículos; estos artículos
son después invertidos y consecuentemente unidos. Así que el resultado
para ``id1;13-05-2015'' es ``2015,05,13,id1'', el cual es adaptado
para una comparación con el operador {\tt cmp}. Más tarde regresaremos
a esta forma de programación de tubería y otras maneras de realizar 
estas operaciones. 
\index{cmp operator}
\index{operator!cmp}
\index{pipeline programming}

Ahora podemos pasar la subrutina {\tt comparar} a la función
{\tt sort}:
\begin{verbatim}
.say for sort &comparar, <id1;13-05-2015 id2;17-04-2015 
                         id3;21-02-2016 id4;12-01-2015>;
\end{verbatim}

Esto muestra:
\begin{verbatim}
id4;12-01-2015
id2;17-04-2015
id1;13-05-2015
id3;21-02-2016
\end{verbatim}

Por favor nota que esto se provee como un ejemplo de funciones 
retrollamadas usadas con la función integrada {\tt sort}.
Veremos al final de la siguiente subsección una manera más simple
de lograr el mismo tipo de ordenamiento usando una función 
anónima.

\subsection{Subrutinas Anónimas y Lambdas}
\index{lambda}
\index{anonymous subroutine}

Hemos visto que una subrutina no necesita tener un nombre
y que puede ser \emph{anónima}. Por ejemplo, puede ser almacenada
en una variable escalar directamente:
\index{anonymous function}
\index{function!anonymous}

\begin{verbatim}
my $saludar = sub {
    say "Hola Mundo!";
};
do-twice $saludar;                 # imprime "Hola Mundo!" dos veces
\end{verbatim}

Ni siquiera necesitamos almacenar el código de la función
anónima en la variable \verb|$saludar|; de hecho, podemos
pasar dicho código directamente como un argumento a la 
subrutina {\tt do-twice}:

\begin{verbatim}

do-twice( sub {say "Hola Mundo!"} );
\end{verbatim}

Dado que nuestra subrutina anónima no toma ningún argumento
y tampoco devuelve un valor útil, podemos simplificar la
sintaxis más aún y pasar un bloque de código anónimo simple
a {\tt do-twice}:

\begin{verbatim}

do-twice {say "Hola Mundo!"};   # imprime "Hola Mundo!" dos veces
\end{verbatim}

Ya has visto varios ejemplos útiles de subrutinas anónimas en este
libro (ver Sección~\ref{map_filter} para más detalles):
\begin{itemize}
\item Con la función {\tt reduce} para computar la suma de 
los primeros 20 números enteros:
\index{reduce function}
\begin{verbatim}

my $suma = reduce { $^a + $^b }, 1..20; # -> 210
\end{verbatim}
\item Con la función {\tt map} para convertir la primera
letra de una lista de ciudades en mayúscula (usando la función
integrada {\tt tc}):
\index{tc function}
\index{map function}
\begin{verbatim}
> .say for map {.tc}, <londres parís roma washington madrid>;
Londres
París
Roma
Washington
Madrid
\end{verbatim}
\item Con la función {\tt grep} para generar una lista de números 
pares al filtrar los números impares:
\index{grep function}
\begin{verbatim}

my @pares = grep { $_ %% 2 }, 1..17; # -> [2 4 6 8 10 12 14 16]
\end{verbatim}
\end{itemize} 

El ejemplo con {\tt reduce} es interesante. En principio, 
contrario a una subrutina, no puedes pasar argumentos a un
bloque de código tan fácilmente (porque no tiene una signatura).
Pero el uso de los parámetros auto-declarados de posición (
o parámetros marcadores) con el twigil \verb|$^| hace posible
usar los parámetros dentro del bloque. 
\index{placeholder}
\index{placeholder!parameter}
\index{twigil}
\index{self-declared parameter}

Debido a esta posibilidad, el bloque de código anónimo se convierte
en lo que usualmente se conoce como una \emph{lambda} en la 
ciencia de la computación (y en matemáticas), i.e., un tipo de
función sin nombre. El cálculo lambda, una teoría matemática 
inventada en la década del 1930 por Alonzo Church, es la esencia
de la mayoría de los lenguajes de programación funcionales de
hoy en día.
\index{lambda}
\index{lambda calculus}
\index{Church, Alonzo}

Actualmente, los dos otros ejemplos más arriba que usan
la variable tópico \verb|$_| son también lambdas. Aunque 
no lo mencionamos en aquellas ocasiones, otras construcciones
que vimos anteriormente son también lambdas. En particular,
considera la sintaxis del ``bloque puntiagudo`` usada dos
en el siguiente bucle {\tt for} que muestra la tabla de 
multiplicación:
\index{pointy block}
\index{for loop}
\index{multiplication tables}

\begin{verbatim}
for 1..9 -> $mult {
    say "Tabla de multiplicación del $mult";
    for 1..9 -> $val {
        say "$mult * $val = ", $mult * $val;
    }
}
\end{verbatim}

Esta es otra forma de lambda donde el parámetro de la ``función``
es definido por la variable de bucle de un bloque puntiagudo.

El ejemplo de ordenamiento presentado en la Subsección~(\ref{fco-refresher})
más arriba puede también escribirse con un bloque de código anónimo
(tomando así ventaja de la sintaxis de {\tt sort}
y usando un bloque de código con solo argumento descrito en la 
Sección~\ref{advanced_sort}):
\index{sort}
\begin{verbatim}
my @in = <id1;13-05-2015 id2;17-04-2015 id3;21-02-2016>;
.say for sort { join ",", reverse split /<[;-]>/, $_ }, @in;
\end{verbatim}

Aquí, el bloque de código algo largo pasado como un argumento
a la función {\tt sort} es una lambda.

\index{lambda}

\subsection{Clausuras}
\index{closure}

En la programación de computadoras, una \emph{clausura} 
(o \emph{clausura lexical}) es una función que puede acceder
el contenido de variables que están lexicalmente disponibles
donde la función es definida, aún si aquellas variables ya no
se encuentran en ámbito en la sección de código donde la
función es llamada.
\index{counter}

Considera el siguiente ejemplo:

\begin{verbatim}
sub crear-contador(Int $cuenta) {
    my $contador = $cuenta;
    sub incrementar-cuenta {
        return $contador++
    }
    return &incrementar-cuenta;
}
my &contar-desde-cinco = crear-contador(5);
say &contar-desde-cinco() for 1..6; # imprime números del 5 al 10
\end{verbatim}

La subrutina {\tt crear-contador} inicializa la variable
\verb|$contador| al valor del parámetro recibido, 
define la subrutina {\tt incrementar-cuenta}, y 
devuelve esta subrutina. El código principal llama a
{\tt crear-contador} para dinámicamente crear la 
referencia de código {\tt \&contar-desde-cinco} (
y podría llamarla muchas veces para crear otros 
contadores que cuentan desde 6, 7, etc.). Después,
\verb|&contar-desde-cinco| es llamada seis veces
e imprime los números entre 5 y 10, cada uno en su 
propia línea.
\index{lexical scope}
\index{scope!lexical}

Lo mágico de esto es que la variable \verb|$contador| está fuera 
de ámbito cuando la función \verb|&contar-desde-cinco| es llamada, 
pero \verb|&contar-desde-cinco| puede aún acceder a su valor,
devolver su valor, e incrementarlo porque \verb|$contador| estaba
dentro del ámbito lexical al tiempo que {\tt incrementar-cuenta}
fue definida. Se dices entonces que {\tt incrementar-cuenta} 
contiene a la variable \verb|$contador|. Por lo tanto, 
la subrutina {\tt incrementar-cuenta} es una clausura.

El ejemplo anterior es un poco artificial y su sintaxis algo rara porque
yo quería mostrar un ejemplo de una clausura nombrada ({\tt incrementar-cuenta}
es una subrutina nombrada). Es usualmente más simple e idiomático
usar clausuras anónimas y escribir nuevamente el ejemplo
de la siguiente manera:

\index{idiomatic}

\begin{verbatim}
sub crear-contador(Int $cuenta) {
    my $contador = $cuenta;
    return sub {
        return $contador++
    }
}
my &contar-desde-cinco = crear-contador(5);
say &contar-desde-cinco() for 1..6; # imprime números del 5 al 10
\end{verbatim}

Podríamos simplificar {\tt crear-contador} aún más con el uso
de sentencias {\tt return} implícitas:

\begin{verbatim}
sub crear-contador(Int $cuenta) {
	my $contador = $cuenta;
	sub { $contador++ }
}
\end{verbatim}

pero esto es menos claro porque la intención del código es meno
explícita.

El último ejemplo {\tt crear-fifo} en la solución al ejercicio sobre
la cola FIFO (Subsección~\ref{functional_queue}) es otro ejemplo
que utiliza el mismo mecanismo:

\begin{verbatim}
sub crear-fifo {
    my @cola;
    return (
        sub {return shift @cola;}, 
        sub ($elem) {push @cola, $elem;}
        ) ;
}
my ($fifo-consigue, $fifo-pone) = crear-fifo();
$fifo-pone($_) for 1..10;
print " ", $fifo-consigue() for 1..5; # ->  1 2 3 4 5
\end{verbatim}
%
\index{closure}
\index{FIFO}
\index{anonymous subroutine}

En Perl~6, todas las subrutinas son clausuras, lo cual significa que 
todas las subrutinas tienen acceso a las variables lexicales que 
existían en el entorno al momento de la definición de las subrutinas.
Sin embargo, ellas no actúan necesariamente como clausuras.

De hecho, todos los objetos de código, incluyendo simple bloques de código anónimos,
pueden actuar como clausuras, lo cual significa que pueden 
hacer referencia a variables lexicales desde el ámbito externo,
y en efecto esto es lo que pasa con la variable de bucle de un
bloque puntiagudo o en el siguiente bloque {\tt map}:

\begin{verbatim}
my $multiplicador = 7;
say  map {$multiplicador * $_}, 3..6; # -> (21 28 35 42)
\end{verbatim}
\index{map}

En este ejemplo, el bloque pasado a \verb|map| hace referencia a
la variable \verb|$multiplicador| desde el ámbito externo, convirtiendo
al bloque en una clausura.


Los lenguajes sin clausuras no pueden proveer fácilmente
funciones de orden superior que sean tan poderosas y fáciles de usar
como {\tt map}.
\index{map}
\index{function!map}

Aquí presentamos otro ejemplo de un bloque que actúa como
una clausura para la implementación de un contador:

\begin{verbatim}
my &cuenta;
{
    my $contador = 10;
    &cuenta = { say $contador++ };
}
&cuenta() for 1..5;  
\end{verbatim}

Esta clausura guarda una referencia a la variable \verb|$contador|
cuando la clausura es creada. La llamada al bloque de código 
\verb|&cuenta| muestra y actualiza a \verb|$contador| exitosamente.
Esto sucede aún cuando la variable ya no se encuentra en el ámbito lexical
al momento que el bloque es ejecutado.
\index{scope!lexical}
\index{lexical scope}
\index{closure}

\section{Procesamiento de Listas y Programación de Tuberías}
\index{pipe-line programming}


A menudo, una computación puede expresarse como una
serie de transformaciones de una lista de valores. Perl
provee funciones capaces de trabajar con los artículos de una
lista y aplicar simples acciones, funciones retrollamadas, 
o bloques de código a estos artículos. Ya hemos visto y usado
abundantemente varias funciones de este tipo:

\begin{itemize}
\item {\tt map} aplica una transformación a cada artículo de una lista.
\index{map} \index{function!map}
\item {\tt grep} es un filtro que mantiene aquellos elementos para los cuales
la función o el bloque de código asociado con {\tt grep} evalúa a verdadero.
\index{grep} \index{function!grep}
\item {\tt reduce} usa cada artículo de una lista para calcular un único 
valor escalar.
\index{reduce} \index{function!reduce}
\item {\tt sort} ordena los elementos de una lista de acuerdo a reglas
definidas en el bloque de código o la subrutina que se pasa.
\index{sort} \index{function!sort}
\end{itemize}

Hemos discutidos varios ejemplos donde estas funciones pueden
usarse conjuntamente en un tipo de tubería de datos en la cual
los datos producidos en cada paso de la tubería son suministrados
al siguiente paso. Por ejemplo, anteriormente en este capítulo 
(Subsección~\ref{fco-refresher}), usamos esto:

\begin{verbatim}
    my $cmp1 = join ",", reverse split /<[;-]>/, $reg1;
\end{verbatim}
\index{reverse} \index{function!reverse}
\index{split} \index{function!split}
\index{join} \index{function!join}

Como destacamos anteriormente, este tipo de código debería leerse
de derecha a izquierda (y de abajo hacia arriba si está escrito 
en varias líneas de código): \verb|$reg1| es suministrada a {\tt split}, 
la cual divide el dato en cuatro piezas; las piezas son después 
invertidas (por {\tt reverse}) y suministrada a {\tt join} para 
crear un solo dato donde las piezas están ahora en orden inverso.

Similarmente, podríamos producir una lista de mascotas que pertenecen
a mujeres solteras que viven en Kansas con el siguiente código que encadena
varios métodos:

\begin{verbatim}
my @mascotas-de-mujeres-solteras-de-kansas =
    map  {  .mascotas },
    grep { !.esta-casada },
    grep {  .genero eq "Femenino" },
    grep {  .estado eq "Kansas" },
         @ciudadanos;
\end{verbatim}
\index{map} \index{function!map}
\index{grep} \index{function!grep}

Esta debería debería leerse de abajo hacia arriba. Toma una
lista de todos los ciudadanos, filtra aquellos de Kansas que 
son mujeres, filtra aquellas que no están casadas, y finalmente
genera la lista de mascotas de dichas personas. Nota que \verb|.mascotas|
puede devolver un animal, una lista de animales, o una lista 
vacía. La función \verb|map| ``aplana`` las listas hasta ese entonces
producidas, así que el resultado final que termina en el array es una
lista plana de animales (y no una lista anidada de listas).

Estas tuberías son muy poderosas y expresivas, y pueden hacer muchas
cosas en pocas líneas de código.

\subsection{Los Operadores Feed y Backward Feed}

En los ejemplos anteriores, los pasos de la tubería se encontraban en 
orden inverso; puedes considerar este hecho algo inconveniente, aunque
es fácil de acostumbrarse.

Perl~6 provee el operador \emph{feed} (\emph{suministro}) \verb|==>|
(algunas veces llamado \emph{pipe} en otros lenguajes)
que hace posible escribir los múltiples pasos de la tubería en un orden
``más natural``, de izquierda a derecha y de arriba hacia abajo.
\index{feed operator}
\index{operator!feed}
% TODO: get these entries working in plastex
\ifplastex \else
\index{==> feed operator@\texttt{==>} feed operator}
\fi

Por ejemplo, al reutilizar el ejemplo sobre el ordenamiento de
los registros por fechas que vimos al inicio de este capítulo,
podrías escribirlo nuevamente así:
\index{sort}

\begin{verbatim}
"id1;13-05-2015" 
    ==> split(/<[;-]>/) 
    ==> reverse() 
    ==> join(",") 
    ==> my @out; # @out es una array que contiene una artículo: una cadena de texto.
say @out.perl;   # ["2015,05,13,id1"]
\end{verbatim}

Por cierto, si estás usando tales operaciones de tubería con una
entrada bien grande, dependiendo de la arquitectura de tu plataforma, 
Perl~6 puede ser capaz de ejecuta estas múltiples operaciones en paralelo
en diferentes CPUs o núcleos (cores), mejorando significativamente
el rendimiento del proceso en su totalidad.

Existe también un operador backward feed (\emph{suministro inverso}), \verb|<==|,
que posibilita la escritura de la tubería en orden inverso:
\index{backward feed operator}
\index{operator!backward feed}
% TODO: get these entries working in plastex
\ifplastex \else
\index{<== backward feed operator@\texttt{<==} backward feed operator}
\fi

\begin{verbatim}
my $out <== join(",") 
        <== reverse() 
        <== split(/<[;-]>/) 
        <== "id1;13-05-2015";
\end{verbatim}


\subsection{El Metaoperador de Reducción}

Ya conocimos este metaoperador en la Sección~\ref{map_filter}. Un metaoperador
actúa sobre otros operadores. Dada una lista y un operador, el {\bf operador de reducción}
[...] aplica el operador iterativamente a todos los valores de la lista
para producir un valor único.
\index{metaoperator}
\index{reduction}
\index{reduction!metaoperator}

Por ejemplo, lo siguiente imprime la suma de todos los elementos
de una lista o un rango:

\begin{verbatim}
say [+] 1..10;      # -> 55
\end{verbatim}

Similarmente, podemos escribir una función factorial así:
\index{factorial!using the reduction meta-operator}

\begin{verbatim}
sub fact (Int $n where $n >= 0) {
    return [*] 1..$n;
}
say fact 20;        # -> 2432902008176640000
say fact 0;         # -> 1
\end{verbatim}

(Nota que esto produce el resultado correcto hasta para el caso 
del factorial de 1, el cual es definido matemáticamente como 1.)

\subsection{El Hiperoperador}

\index{hyperoperator}
Un hiperoperador aplica el operador especificado a cada
artículo de una lista (o dos listas en paralelo) y devuelve
una lista modificada (similar a la función {\tt map}).
Dicho hiperoperador usa las comillas francesas o alemanas, 
\verb|« »| (Unicode codepoints U+00AB y U+00BB), pero puedes
usar las comillas angulares, \verb|<< >>|, si así lo deseas
(o si no sabes como entrar estos caracteres Unicode con tu 
editor).
\index{map}
\index{French quote marks}
\index{German quote marks}

Nuestro primer ejemplo multiplicará cada elemento de una lista
por un número dado (5):

\begin{verbatim}
my @b = 6..10;
my @c = 5 <<*>> @b;
say @c;             # imprime 30 35 ... 50 
					# resultado (5*6, 5*7, ...)
\end{verbatim}

Podemos también combinar dos listas y, por ejemplo, agregar
valores respectivos:

\begin{verbatim}
my @a = 1..5;
my @b = 6..10;
my @d = @a >>+<< @b;
say @d;             # -> [7 9 11 13 15]
\end{verbatim}

Puedes también usar hiperoperadores con un operador unario:

\begin{verbatim}
my @a = 2, 4, 6;
say -<< @a;          # imprime:  -2 -4 -6
\end{verbatim}

Los hiperoperadores con operadores unarios siempre devuelven
una lista con el mismo tamaño que la lista de entrada. 
Los hiperoperadores infijos tienen un comportamiento diferente
dependiendo del tamaño de sus operandos:

\begin{verbatim}
@a >>+<< @b;   # @a y @b deben tener el mismo tamaño
@a <<+<< @b;   # @a puede ser más pequeño
@a >>+>> @b;   # @b pueden ser más pequeño
@a <<+>> @b;   # Cualquiera puede ser más pequeño, 
               # Perl probablemente hará lo que quieres 
               # (principio DWIM)
\end{verbatim}

Los hiperoperadores también funcionan con operadores 
modificadores de asignación:

\begin{verbatim}
@x >>+=<< @y   # Lo mismo que: @x = @x >>+<< @y
\end{verbatim}
\index{hyperoperator}

\subsection{Los Operadores Cruz (X) y Zip (Z)}
\index{cross operator X}
\index{operator!cross}
\index{operator!X (cross)}
\index{zip operator}
\index{operator!zip}
\index{operator!Z (zip)}

El operador cruz usa la letra mayúscula \verb|X|. Dicho operador
toma dos o  más listas como argumentos y devuelve una lista de
todas las listas que puede construirse al combinar los elementos
de cada lista (una forma de ``producto cartesiano''):
\index{cross operator}
\index{operator!cross}
\index{X cross operator}

\begin{verbatim}
my @a = 1, 2;
my @b = 3, 4;
my @c = @a X @b;       # -> [(1,3), (1,4), (2,3), (2,4)]
\end{verbatim}

El operador cruz puede también usarse como un metaoperador y 
aplicar el operador que modifica a cada combinación de artículos
derivada de sus operandos:
\index{metaoperator}

\begin{verbatim}
my @a = 3, 4;
my @b = 6, 8;
say @a X* @b;    # -> 18 24 24 32
\end{verbatim}

Si no se provee un operador adicional (como en el primer ejemplo), 
\verb"X" actúa como si la coma es proveída como el operador adicional
por defecto.

El operador zip \verb|Z| intercala las listas como una cremallera:
\index{zip operator}
\index{operator!zip}
\index{Z zip operator}

\begin{verbatim}
say 1, 2 Z <a b c > Z 9, 8;   # -> ((1 a 9) (2 b 8))
\end{verbatim}

El operador \verb|Z| también existe como un metaoperador, y 
en este caso, en lugar de producir listas anidadas internas
como en el ejemplo más arriba, el operador zip aplicará el 
operador adicional y reemplazará estas listas anidadas con
los valores generados. En el siguiente ejemplo, el operador
de concatenación ~ es usado para fusionar las listas internas 
producidas por el operador zip y crear una cadenas de texto:
\index{metaoperator}

\begin{verbatim}
say 1, 2, 3 Z~ <a b c > Z~ 9, 8, 7; # -> (1a9 2b8 3c7)
\end{verbatim}

\subsection{Un Resumen de Los Operadores de Listas}

Los operadores de listas anteriores son poderosos y pueden 
combinarse para producir construcciones increíblemente expresivas.

Como un ejercicio, intenta resolver las siguientes pequeñas pruebas 
(por favor no prosigas con la lectura hasta que lo haya intentado):

\begin{itemize}
\item Dado que la función integrada {\tt lcm} devuelve el mínimo
común múltiplo entre dos números, escribe un programa que muestre
el número positivo más pequeño divisible por todos los números
entre 1 y 20.
\index{lcm function}

\item Escribe un programa que calcule la suma de todos los dígitos del factorial
de 100.

\item Encuentra la diferencia entre el cuadrado de la suma de los
primeros 100 números enteros y la suma de los cuadrados de los
primeros 100 números enteros.
\end{itemize}

Nuevamente, no prosigas con la lectura hasta que hayas 
tratado de resolver estos pequeños problemas (y con suerte
lo hayas logrado).

El operación de reducción facilita la aplicación de un 
operador a todos los elementos de una lista. Así que si lo
usamos con la función {\tt lcm} nos dará el mínimo común 
múltiplo (MCM) entre 1 y 20:
\index{reduction!metaoperator}

\begin{verbatim}
say [lcm] 1..20;                           # -> 232792560
\end{verbatim}

Para la suma de los dígitos del factorial de 100, usamos 
el metaoperador de reducción \verb|[]| dos veces, una con el
operador de multiplicación para calcular el factorial de 100,
y otra con el operador de adición para añadir los dígitos del 
resultado:
\index{reduction!metaoperator}

% say [+] (1..100).comb;
\begin{verbatim}
say [+] split '', [*] 2..100;              # -> 648
\end{verbatim}

Para el cuadrado de la suma menos la suma de los cuadrados, 
es fácil calcular la suma de los 100 primeros números enteros
con el operador de reducción. El hiperoperador \verb|<<...>>|
fácilmente suministra una lista de los cuadrados de estos 
enteros, y otra aplicación del operador de reducción reduce esta 
lista a una suma:
\index{hyperoperator}

\begin{verbatim}
say ([+] 1..100)**2 - [+] (1..100) «**» 2; # -> 25164150
\end{verbatim}

\subsection{Creando Nuevos Operadores}

Hemos visto brevemente (Sección~\ref{operator_construction})
que puedes construir nuevos operadores o redefinir aquellos existente
con nuevos tipos.
\index{creating new operators}
\index{new operators!creating}

El ejemplo que proveímos fue definir el signo menos
como un operador infijo entre dos hashes para realizar un tipo
de sustracción matemática de conjuntos, i.e., para encontrar las llaves
del primer hash que no se encuentran en el segundo hash.
\index{operator type!infix}

\index{operator type!prefix}
En el párrafo anterior, la palabra \emph{infijo} (\emph{infix} en inglés)
significa que este es un operador binario (dos operandos) que 
se colocará entre los colocará entre los dos operandos.

Existen otros sabores de operadores:
\begin{itemize}
\item Prefijo (\emph{prefix}): un operador unario colocado antes del
operando, por ejemplo el signo de menos en la expresión $-1$
\index{operator type!prefix}

\item Sufijo (\emph{postfix}): un operador unario colocado después del 
operando, por ejemplo el signo de exclamación usado como un símbolo
matemático para el factorial: $5!$
\index{operator type!postfix}

\item Circunfijo (\emph{circumfix}): un operador compuesto de dos símbolos
alrededor del/de los operando(s), por ejemplo los paréntesis $(...)$ o los 
paréntesis angulares $<...>$
\index{operator type!circumfix}

\item Poscircunfijo (\emph{postcircumfix}): un operador compuesto de dos símbolos
colocados después de un operando y alrededor de otro operando, por ejemplo
los corchetes en \verb'@a[1]'
\index{operator type!postcircumfix}
\end{itemize}

Para declarar un nuevo operador, usualmente necesitas especificar los siguientes
elementos en el orden especificado:
\begin{enumerate}
\item El tipo (prefijo, sufijo, etc.) del operador
\item Dos puntos (:)
\item El símbolo o nombre del operador entre paréntesis angulares 
\item La signatura y el cuerpo de la función que define el operador
\end{enumerate}

Por ejemplo, podríamos definir un operador prefijo \% de la siguiente 
manera:

\begin{verbatim}
multi sub prefix:<%> (Int $x) {   # operador doble
    2 *  $x;
}
say % 21;   # -> 42
\end{verbatim}

Esto es solamente un ejemplo para mostrar cómo la construcción de un 
operador funciona; \% no es probablemente un buen nombre para un operador
doble. Lo interesante aquí es que hemos reutilizado un operador existente
(el operador de módulo), pero el compilador no se confunde porque el 
módulo es un operador infijo y nuestro nuevo operador es definido como
un operador prefijo.
\index{modulo operator}
\index{new operators!creating}
\index{creating new operators}

Un ejemplo con un mejor nombre sería usar un signo de exclamación(!) como
un operador sufijo para el factorial de un número, al igual que en 
notación matemática:
\index{factorial!operator}

\begin{verbatim}
multi sub postfix:<!> (Int $n where $n >= 0) {
    [*] 2..$n;
}
say 5!;                     # -> 120
\end{verbatim}

Observa que el signo de exclamación usado como un operador prefijo
(i.e., colocado al frente de su operando) es el operador de negación,
pero usualmente no es posible confundir los dos operadores
porque uno es un operador prefijo y nuestro operador es un operador
sufijo (aunque debes ser cuidadoso con la posición donde pones los 
espacios en blanco si tu expresión es algo complicada). La palabra 
{\tt multi} no es estrictamente requerida en este ejemplo, pero es 
probablemente buena práctica colocarla, solo para cubrir los casos
cuando es necesaria.

Al igual que el otro ejemplo, podríamos definir el operador $\Sigma$ (suma) 
de la siguiente manera:

\begin{verbatim}
multi sub prefix:<Σ> (@*lista-num) {
    [+] @lista-num;
}
say Σ (10, 20, 12);         # -> 42
\end{verbatim}

El beneficio de usar el operador $\Sigma$ sobre \verb|+| puede no 
ser directamente obvio, pero es algunas veces útil crear un ``lenguaje
de dominio específico``(DSL), i.e., un sublenguaje específicamente adaptado
para un contexto o área de estudio específica (por ejemplo, matemáticas o química),
lo cual permite que un problema o solución en particular sea expresada más
claramente que lo que el lenguaje principal existente permitiría. En Perl~6, 
las gramáticas y la facilidad de crear nuevos operadores hace la 
creación de un DSL una tarea sencilla.
\index{domain-specific language (DSL)}
\index{DSL (domain-specific language)}
\index{new operators!creating}
\index{creating new operators}


El nuevo operador no tiene que ser declarado entre los paréntesis angulares.
Las siguientes declaraciones podrían usarse para definir un operador de
adición:

\begin{verbatim}
infix:<+>
infix:<<+>>
infix:«+»
infix:('+')
infix:("+")
\end{verbatim}

También puedes especificar la precedencia de tus nuevos operadores
(relativa a aquellos existentes). Por ejemplo:
\index{precedence}
\index{operator!precedence}

\begin{verbatim}
multi sub infix:<mult> is equiv(&infix:<*>) { ... }
multi sub infix:<plus> is equiv(&infix:<+>) { ... }
mutli sub infix:<zz> is tighter(&infix:<+>) { ... }
mutli sub infix:<yy> is  looser(&infix:<+>) { ... }
\end{verbatim}

En uno de sus artículos (``Structured Programming with 
go to statements'', Diciembre 1974), Donald Knuth, un científico
de la computación muy famoso, usa el símbolo \verb|:=:| como un 
operador de pseudocódigo para expresar el intercambio de dos valores
en una variable, i.e, la siguiente operación:
\index{Knuth, Donald}
\index{swap}
\index{variable interchange}

\begin{verbatim}
# Advertencia: esto es pseudocódigo, no código funcional, por el momento
my $a = 1; my $b = 2;
$a :=: $b; 
say "$a $b";  # -> 2 1 
\end{verbatim}
\index{pseudo-code}

En el artículo de Knuth, esto es solo un atajo falso para 
discutir más fácilmente el algoritmo de ordenamiento rápido
(\emph{quicksort} en inglés) (descrito en el ejercicio~\index{quicksort}),
pero podemos implementa fácilmente ese símbolo:
\index{swap operator}
\index{sort!quick sort}
\index{Hoare, Charles Antony Richard}

\begin{verbatim}
multi sub infix:<:=:> ($a is rw, $b is rw) {
    ($a, $b) = $b, $a;
}
\end{verbatim}

Nota que esto puede también escribirse de esta manera:

\begin{verbatim}
multi sub infix:<:=:> ($a is rw, $b is rw) {
    ($a, $b) .= reverse;   # equiavalente a: ($a, $b) = ($a, $b).reverse 
}
\end{verbatim}

Podemos ahora probarlo con los siguientes ejemplos:

\begin{verbatim}
my ($c, $d) = 2, 5;
say $c :=: $d;             # -> (5 2)
# usándolo para intercambiar dos elementos del array
my @e = 1, 2, 4, 3, 5;
@e[2] :=: @e[3];
say @e;                    # -> [1 2 3 4 5]
\end{verbatim}

Ahora, el pseudocódigo de más arriba funciona tan bien
como código real. Un algoritmo de ordenamiento como el presentado
más abajo(Sección~\ref{combsort}) puede típicamente tener líneas
como estas para intercambiar dos elementos en un array:
\index{swap}

\begin{verbatim}
if $alguna-condicion {
    my ($x, $y) = @array[$i], @array[$i + gap];
    @array[$i], @array[$i + gap] = $y, $x;
}
\end{verbatim}

Si el operador \verb|:=:| es definido, podríamos escribir
estas líneas de la siguiente manera:

\begin{verbatim}
@array[$i] :=: @array[$i + gap] if $alguna-condicion;
\end{verbatim}

Un punto final muy interesante. Supón que queremos usar
el operador $\oplus$ para la unión matemática de conjuntos
entre dos hashes. Esto podría escribirse fácilmente 
como sigue:
\index{$\oplus$ operator}
\index{operator!$\oplus$}
\index{hash merge operator}

\begin{verbatim}
multi sub infix:<⊕> (%a, %b) {
    my %c = %a;
    %c{$_} = %b{$_} for keys %b;
    return %c
}
\end{verbatim}

Esto funciona bien:

\begin{verbatim}
my %q1 = jan => 1, feb => 2, mar => 3;
my %q2 = apr => 4, may => 5, jun => 6;
my %first_half = %q1 ⊕ %q2;
say %first_half;
# {apr => 4, feb => 2, jan => 1, jun => 6, mar => 3, may => 5}
\end{verbatim}

Hasta ahora, todo bien, nada realmente nuevo. Pero el 
nuevo operador infijo $\oplus$ se ha vuelto casi similar a
un operador integrado de Perl, y por lo tanto podemos
usarlo conjuntamente con el metaoperador de reducción:
\index{reduction!metaoperator}

\begin{verbatim}
my %q1 = jan => 1, feb => 2, mar => 3;
my %q2 = apr => 4, may => 5, jun => 6;
my %q3 = jul => 7, aug => 8, sep => 9;
my %q4 = oct => 10, nov => 11, dec => 12;
my %year = [⊕] %q1, %q2, %q3, %q4;
say %year;
# {apr => 4, aug => 8, dec => 12, feb => 2, jan => 1, 
# jul => 7, jun => 6, mar => 3, may => 5, nov => 11, 
# oct => 10, sep => 9}
\end{verbatim}

Todo funciona como si este nuevo operador fuera parte
de la gramática de Perl~6. Y eso es lo que, en efecto, ha pasado
aquí: hemos extendido el lenguaje con un nuevo operador.
Esta posibilidad de extender el lenguaje es una parte clave de
la habilidad de Perl~6 para afrontar futuras necesidades que
ni siquiera pensamos en el momento presente.
\index{extending the language}
\index{new operators!creating}
\index{creating new operators}

\section{Creando Tus Funciones Similares a Map}
\index{map}

Hemos visto en este capítulo y en la Sección~\ref{map_filter} (p.~\pageref{map_filter}) 
cómo la funciones de orden superior tales como las funciones
{\tt reduce}, {\tt map}, {\tt grep}, y {\tt sort} pueden ser 
poderosos y expresivas. También existen otros tipos de funciones
integradas en Perl, pero nos gustaría también crear nuestras 
propias funciones.


\subsection{Versiones Personalizadas de map, grep, etc.}

Veamos cómo podríamos escribir nuestra propias versiones
personalizadas de tales funciones.

\subsubsection{mapa, Una Versión Pura de Perl de map}
\index{my-map}

Primeramente, intentemos escribir en puro Perl la función {\tt map}.
Necesitamos tomar una subrutina o un bloque de código
como su primer argumento, aplicarlo a un array o una lista,
y devolver la lista modificada.

\begin{verbatim}
sub mapa (&codigo, @valores) { 
    my @temp;
    push @temp, &codigo($_) for @valores;
    return @temp;
}
my @result = mapa { $_ * 2 }, 1..5; 
say @result;                   # -> [2 4 6 8 10]
\end{verbatim}

En el primer intento, esto funciona exactamente como se espera.
(He intentado el mismo experimento con otros lenguajes de 
programación en el pasado, incluyendo Perl 5; tomó
varios intentos antes de conseguir el programa correcto, 
especialmente lo concerniente a la sintaxis de la llamada.
Aquí, todo cae en su lugar naturalmente.) Para ser honesto, 
las condiciones en este ejemplo son muy limitadas y podrían
haber casos donde {\tt mapa} no funciona de la misma forma
exactamente que {\tt map}; la lección a tomar es que es bien
fácil construir una subrutina de orden superior que se comporta 
esencialmente en la misma manera que {\tt map}.
\index{higher-order function}
\index{map}

\subsubsection{mi-grep}
\index{my-grep}
\index{grep}

Escribir en puro Perl nuestra versión de {\tt grep} es igualmente
fácil:
\begin{verbatim}
sub mi-grep (&código, @values) { 
    my @temp;
    for @values -> $val {
        push @temp, $val if &código($val);
    }
    return @temp;
}
my @pares = mi-grep { $_ %% 2 }, 1..10; 
say @pares;                   # -> [2 4 6 8 10]
\end{verbatim}

\subsection{Nuestra Propia Versión de la Función Sort}
\label{combsort}
\index{sort!comb sort}
\index{comb sort}

Similarmente podemos escribir nuestra propia versión 
de la función sort.

\index{sort!merge sort}
\index{sort!quick sort}
\index{merge sort}
\index{quick sort}

La función {\tt sort} en Perl implementa un algoritmo de 
ordenamiento conocido como \emph{merge sort}
(\emph{merge sort} en inglés)
\footnote{Merge sort se presenta en más 
detalles en la sección~\ref{mergesort}.}. Algunas versiones 
previas del lenguaje Perl (versiones anteriores a~5.8) implementaban
otro algoritmo conocido como \emph{quick sort}\footnote{Quick sort 
se presenta en más detalles en \ref{quicksort}}. La razón
por este cambio fue que, aunque quick sort es en promedio un poco
más rápido que merge sort, existen casos específicos donde 
quick sort es mucho menos eficiente que merge sort (notablemente
cuando los datos están casi ordenados). Estos casos son muy raros
con datos aleatorios, pero no en situaciones reales: es muy común
que tengas que ordenar una lista previamente ordenada en la cual
solo algunos elementos han sido añadidos o modificados.
\index{quick sort}

En la teoría de la computación, se dice frecuentemente que, para
ordenar \emph{n} artículos, merge sort y quick sort tienen una \emph{complejidad
promedia} de $O(n \log n)$, lo cual significa que el número de 
operaciones a realizarse es proporcional a $n \log n$ si el número
de artículos a ser ordenados es $n$, con quick sort siendo usualmente
un poco más rápido; pero quick sort tiene una \emph{complejidad de 
peor caso} de $O(n^{2})$, mientras que merge sort tiene una \emph{complejidad de 
peor caso} de $O(n \log n)$. Cuando el número $n$ de artículos a ser ordenado
crece inmensamente, $n^{2}$ se vuelve significativamente más grande que 
$n \log n$. En otras palabras, merge sort se considera ser mejor porque
permanece eficiente en todos los casos.
\index{algorithmic complexity}
\index{sort!merge sort}
\index{sort!quick sort}

\index{sort!comb sort}
Supón ahora que queremos implementar otra algoritmo de ordenamiento
cuyo rendimiento es alegadamente mejor. Para este ejemplo, usaremos
un algoritmo algo exótico conocido  \emph{comb sort} (también conocido
como ordenamiento de Dobosiewicz), el cual se describe en esta página
de Wikipedia: \url{https://en.wikipedia.org/wiki/Comb_sort}. Este algoritmo 
se dice que está \emph{en lugar}, lo cual significa que no necesita copiar los 
artículos en una estructura de datos auxiliar, y tiene generalmente 
buen rendimiento (usualmente mejor que merge sort), pero no se
usa comúnmente porque su análisis teórico es muy difícil
(en particular, parece ser que tiene un buen rendimiento de
peor caso, pero nadie lo ha probado formalmente hasta ahora).
De hecho, realmente no nos importa el rendimiento real de este 
tipo de algoritmo; es muy improbable que una implementación 
pura de Perl del comb sort sobrepasará la función integrada
{\tt sort} la cual está implementada en C y probablemente
optimizada muy cuidadosamente por sus autores. Queremos
solamente mostrar cómo una subrutina de ordenamiento podría
ser implementada.

Para que funcione como {\tt sort}, una función de ordenamiento
puede recibir como parámetros una función de comparación 
o bloque de código y un array para ser ordenado, y la rutina
de comparación debería usar parámetros marcadores (\verb|$^a| 
y  \verb|$^b| en el código más abajo). Esta es una posible implementación
básica:
\index{placeholder!parameter}

\begin{verbatim}
sub comb_sort (&codigo, @array) {
    my $max = @array.elems;
    my $brecha = $max;
    loop {
        my $intercambio = False;
        $brecha = Int($brecha / 1.3);    # 1.3: factor óptimo de retracción
        $brecha = 1 if $brecha < 1;
        my $lmax = $max - $brecha - 1;
        for (0..$lmax) -> $i {
            my ($x, $y) = (@array[$i], @array[$i+$brecha]);
            (@array[$i], @array[$i+$brecha], $intercambio) = ($y, $x, True)
                if &codigo($x, $y) ~~ More;  # o: if &brecha($x, $y) > 0
        }
        last if $brecha == 1 and ! $intercambio;
    }
}
\end{verbatim}
\index{sort!comb sort}

Esto puede probarse con el código siguiente:

\begin{verbatim}
my @v;
my $max = 500;
@v[$_] = Int(20000.rand) for (0..$max);

comb_sort {$^a <=> $^b}, @v;
.say for @v[0..10], @v[493..499]; # imprime comienzo y final de array
# imprime (por ejemplo):
# (14 22 77 114 119 206 264 293 298 375 391)
# (19672 19733 19736 19873 19916 19947 19967)
\end{verbatim}

El loop interno compara los artículos que están distantes de cada uno
por los valores \verb|$brecha|, y los intercambia si no están en el orden
correcto. Al comienzo, \verb|$brecha| es grande, y se divide por una factor de
retracción en cada iteración del loop externo. El rendimiento depende
inmensamente en el valor del factor de retracción. Al final, la brecha
es 1 y comb sort es equivalente a un ordenamiento de burbuja (\emph{bubble sort} en inglés).
El factor óptimo de retracción se encuentra entre 1.25 y 1.33; 
he usado un factor de retracción de 1.3, el cual es el valor sugerido por 
los autores de las publicaciones originales que presentan el algoritmo. 
\index{sort!bubble sort}

\subsection{Una Versión Iterador de map}
\index{iter!map}
\index{map}

Estas funciones {\tt mapa}, {\tt mi-grep}, y {\tt comb\_sort} son
pedagógicamentes interesantes, pero no son muy útiles si hacen lo mismo
que las funciones equivalentes integradas (y son probablemente más lentas).
Sin embargo, ya que hemos visto cómo construirlas. podemos crear nuestras
propias versiones que hacen cosas diferentes.

Digamos que queremos crear una función que actúa como {\tt map} en el 
sentido que aplica una transformación a los artículos de la lista de 
entrada, pero hace eso con los artículos uno por uno, a la petición del
proceso consumidor, y pausa mientra el proceso consumidor no necesita nada.
Esto podrías describirse como un {\bf iterador} que devuelve elementos 
modificados a petición de la lista de entrada. Podrías pensar que esto 
no está íntimamente relacionado con {\tt map}, pero podría igualmente ser 
considerado como una forma de {\tt map} con evaluación retardada, la cual
procesa solo los elementos de la lista de entrada que son necesarios para el
programa, no más que eso. 
\index{iterator}
\index{delayed evaluation}

\index{laziness}
\index{lazy!list processing}
La idea de procesar solo lo que es estrictamente necesario es usualmente 
conocido como \emph{pereza} (\emph{laziness} en inglés), y esta es una idea
muy útil. El procesamiento de una lista perezosa puede ser muy útil no solo 
porque evita el procesamiento de datos innecesario, y por lo tanto puede 
contribuir a un mejor uso de recursos y mejor rendimiento, pero también hace posible
considerar listas \emph{infinitas}: mientras puedas garantizar que solo usarás 
un número limitado de elementos, no tienes ningún problema en considerar listas
que son potencialmente ilimitadas. Perl~6 provee los conceptos y las herramientas
para hacer todo esto.
\index{infinite list}

Para reflejar estas consideraciones, llamaremos nuestra subrutina {\tt iter-map}. 
Dado que podríamos también escribir una subrutina {\tt iter-grep} y posiblemente
otras, escribiremos un iterador y un transformador de datos separadamente.
\index{iterator}

Podemos usar una clausura para manufacturar un iterador:
\index{closure}

\begin{verbatim}
sub crear-iter(@array) {
    my $indice = 0;
    return sub { @array[$indice++];}
}
my $iterador = crear-iter(1..200);
say $iterador() for 1..5; # -> 1, 2, 3, 4, 5
\end{verbatim} 

Ahora que el iterador devuelve un valor a la vez, podemos escribir
la subrutina {\tt iter-map}:
\index{iter!map}

\begin{verbatim}
sub iter-map (&ref-codigo, $iter) {
    return &ref-codigo($iter);
}
my $iterador = crear-iter(1..200);
say iter-map { $_ * 2 }, $iterador() for 1..5; # -> 2, 4, 6, 8, 10
\end{verbatim}

Dado que hemos llamado la función {\tt iter-map} solo 5~veces, 
ha hecho el trabajo para multiplicar los valores por 2 solo 5~veces,
en lugar de hacerlo 200 veces, de las cuales 195 serían para nada.
Por supuesto, multiplicar un número por 2 no es una operación costosa
y el array no es tan largo, pero esto muestra como la pereza puede 
prevenir computaciones innecesarias. Regresaremos a esta idea, dado 
que Perl~6 ofrece soporte nativo de las listas perezosas y el procesamiento
perezoso.
\index{laziness}

Como ya notamos, una ventaja adicional de usar una función como {\tt iter-map}
es que es posible usar listas infinitas virtualmente. Esta implementación que 
usa lista infinita funciona como antes:

\begin{verbatim}
my $iterador = crear-iter(1..*);
say iter-map { $_ * 2 }, $iterador() for 1..5;
     # imprime 2, 4, 6, 8, 10
\end{verbatim}

\subsection{Una Versión Iterador de grep}
\index{iter!grep}

Si intentamos escribir una subrutina {\tt iter-grep} en el mismo 
modelo:

\begin{verbatim}
my $iterador = crear-iter(reverse 1..10);
sub iter-grep (&ref-codigo, $iter) {
    my $val = $iter();
    return $val if &ref-codigo($val);
}
# simulando diez llamadas
say iter-grep { $_ % 2 }, $iterador for 1..10;
\end{verbatim}

no funcionamos como lo esperamos, porque esto imprimirá valores 
impares alternativamente (9, 7, 5, etc.) y valores indefinidos
(para los valores pares del array). Aunque no lo hemos especificado 
todavía, preferiríamos que {\tt iter-grep} suministrara el siguiente
valor para el cual \verb|&ref-codigo| devuelve verdadero. Esto implica 
que {\tt iter-grep} tiene que iterar sobre los valores por el iterador 
hasta que reciba un valor apropiado.

Eso podría lucir así:
\index{iter!grep}

\begin{verbatim}
my $iterador = crear-iter(reverse 1..10);
sub iter-grep (&ref-codigo, $iter) {
    loop {
        my $val = $iter();
        return unless defined $val;  # evita bucle infinito
        return $val if &ref-codigo($val);
	}
}
# simulando 10 llamadas
for 1..10 {
    my $val = iter-grep { $_ % 2 }, $iterador;
    say "Array de entrada agotado!" and last unless defined $val;
    say $val;
}
\end{verbatim}

Esto ahora funciona como se esperaba:

\begin{verbatim}
9
7
5
3
1
Array de entrada agotado!
\end{verbatim}

Sin embargo, todavía tenemos un problema si el array
contiene algunos valores indefinidos (o ``celdas vacías``). 
Esto podría interpretarse como el final del array de entrada,
mientras que podrían haber valores adicionales en el array.
Esto es algunos veces conocido en la ciencia de la computación
como el problema del ``semi-predicado``. Aquí, {\tt iter-grep} no
tiene manera de saber la diferencia entre una celda vacía en el
array y el final del array. Un implementación más robusta necesita
una mejor versión de {\tt create-iter}  que algo diferente para un 
artículo indefinido del array y el agotamiento del array. Por ejemplo, 
el iterador podría devolver un valor falso cuando termine con el array,
y por lo contrario, un par con el artículo del array como un valor. Un 
par será considerado verdadero, aún si su valor no está definido:
\index{pair}

\begin{verbatim}
sub crear-iter(@array) {
    my $indice = 0;
    my $indice-max = @array.end;
    return sub { 
        return False if $indice >= $indice-max; 
        return ("un_par" => @array[$indice++]);
    }
}
my @array = 1..5;
@array[7] = 15;
@array[9] = 17;
push @array, $_ for 20..22;
.say for 'El @array ahora: ', @array;
my $iterador = crear-iter(@array);
sub iter-grep (&codigo_ref, $iter) {
    loop {
        my $par-devuelto = $iter();
        return unless $par-devuelto;  # evita bucle infinito
        my $val = $par-devueltor.value;
        return $val if defined $val and &codigo_ref($val);
	}
}
for 1..10 {
    my $val = iter-grep { $_ % 2 }, $iterador;
    say "Array de entrada agotado!" and last unless defined $val;
    say $val;
}
\end{verbatim}
\index{iter!grep}

Running this script displays the following:
\begin{verbatim}
El @array ahora: 
[1 2 3 4 5 (Any) (Any) 15 (Any) 17 20 21 22]
1
3
5
15
17
21
Array de entrada agotado!
\end{verbatim}

Esto ahora funciona completamente como se deseaba.

Aunque {\tt iter-map} no sufrió del mismo problema, podrías querer
modificar a {\tt iter-map} como un ejercicio para que use nuestra 
nueva versión de {\tt crear-iter}.
\index{iter-map}

La ventaja de las funciones iteradores vistas más arriba es que ellas
procesan solo los artículos que son requeridos por el código del usuario,
y por lo tanto solo realizan las computaciones estrictamente requeridas y 
no gastan ciclos de CPU y tiempo haciendo trabajo innecesario. Hemos 
estudiado las versiones iteradores de las funciones {\tt map} y {\tt grep}
como una forma práctica para propósitos pedagógicos, para explicar en
términos prácticos la idea de la pereza (\emph{laziness}).
\index{map}
\index{laziness}
\index{iterator}

Esto es lo que habría sido necesario para implementar iteradores
perezosos en las versiones anteriores de Perl (e.g., Perl~5),
pero no se requiere todo esto con Perl~6, dado que el mismo tiene soporte 
integrado para las listas perezosas y operadores perezosos, como 
veremos más adelante.

\section{Las Construcciones gather y take}
\index{gather function}
\index{gather and take construct}
\index{take function}

Una construcción útil para crear listas (posiblemente perezosas)
es \verb|gather { take }|. Un bloque \verb|gather| actúa más o menos 
un bucle y se ejecuta hasta que \verb|take| suministre un valor. Esta 
construcción es también una forma de iterador.

Por ejemplo, el código siguiente devuelve una lista de números igual 
a los números pares entre 1 y 10 multiplicados por 3:

\begin{verbatim}
my @lista = gather { 
    for 1..10 {
        take 3 * $_ if $_ %% 2
    } 
};
say @lista;                 # -> [6 12 18 24 30]
\end{verbatim}

Aquí, \verb|gather| itera sobre los valores del rango y \verb|take|
``devuelve`` los valores deseados

Si lo contempla, el código de más arriba parece ser una forma de combinación de
un {\tt map} y un {\tt grep}.
\index{map}
\index{grep}

Podemos de hecho simular un \verb|map|. Por ejemplo:

\begin{verbatim}
my @pares = map { $_ * 2 }, 1..5;
\end{verbatim}

podría escribirse con un bloque \verb|gather { take }|:

\begin{verbatim}
my @pares = gather {take $_ * 2 for 1.. 5}; # [2 4 6 8 10]
\end{verbatim}

Y podríamos simular un {\tt grep} de forma similar:

\begin{verbatim}
my @pares = gather {take $_ if $_ %% 2 for 1..10};
\end{verbatim}

Dado que {\tt take} también acepta una sintaxis de método, esto podría 
ser escrito así:

\begin{verbatim}
my @pares = gather {.take if $_ %% 2 for 1..10};
\end{verbatim}

\index{map}
Estos ejemplos de código no aportan ninguna ventaja sobre \verb|map| 
o \verb|grep|, pero ilustran cómo un bloque \verb|gather { take }| puede ser
considerado como una generalización de las funciones \verb|map| y \verb|grep|.
Y, como ya lo mencionamos, el primer ejemplo en esta sección actualmente
combina las acciones de una función {\tt map} y una función {\tt grep}.

De hecho, podemos escribir una nueva versión de {\tt mapa}:
\index{my-map}

\begin{verbatim}
sub mapa (&ref_codigo, @valores) {
   return gather {
      take &ref_codigo($_) for @valores;
   };
}
say join " ", mapa {$_ * 2}, 1..10;
# imprime: 2 4 6 8 10 12 14 16 18 20
\end{verbatim}

Escribir una nueva versión de {\tt my-grep} es bien fácil y
se deja como un ejercicio al lector.
\index{my-grep}

\index{take function}
Llamar la función {\tt take} solo hace sentido dentro del
contento de un bloque \verb|gather|, pero no tiene que
ser dentro del bloque (o dentro del ámbito léxico del bloque
\verb|gather|); puede ser dentro del \emph{ámbito dinámico} del
bloque \verb|gather|.

\index{dynamic variable}
\index{variable!dynamic}
\index{dynamic scope}
\index{lexical scope}
Aunque no hemos tratado este concepto anteriormente,
Perl tiene la noción de \emph{ámbito dinámico}: contrario
al ámbito léxico, el ámbito dinámico no solo contiene el bloque
actual, sino que también las subrutinas llamadas desde dentro 
del bloque actual. Las variables con ámbito dinámico usan
el twigil ``*``. Este es un ejemplo:
%
\begin{verbatim}
sub escribir-result () { say $*valor; }
sub caller (Int $val) { 
    my $*valor = $val * 2; 
    escribir-result();
}
caller 5;               # -> 10
\end{verbatim}
%
En el código más arriba, la variable dinámica \verb|$*valor| es
declarada y definida en la subrutina \verb|caller| y usada en la
subrutina \verb|escribir-result|. Esto no funcionaría con una variable
lexical, pero funciona con una variable dinámica como \verb|$*valor|,
porque el ámbito de \verb|$*valor| se extiende a la subrutina \verb|escribir-result|
la cual es llamada por \verb|caller|.

\index{take function}
Similarmente, la función {\tt take} puede funcionar dentro del ámbito dinámico del
\verb|gather|, lo cual esencialmente significa que la función {\tt take} 
puede ser llamada dentro de una subrutina llamada desde el bloque 
\verb|gather|. Por ejemplo:
\index{lexical scope}
\index{dynamic scope}
\index{scope!dynamic}

\begin{verbatim}
my @lista = gather {
    computar-val($_) for 1..10; 
}
sub computar-val(Numeric $x) {
    take $x * $x + 2 * $x - 6;
}
say @lista[0..5];        # -> (-3 2 9 18 29 42)
\end{verbatim}

Como puedes ver, la función {\tt take} no es llamada dentro del
bloque {\tt gather}, pero funciona bien porque está dentro 
del bloque dinámico del bloque {\tt gather}, i.e., dentro de la
subrutina {\tt computar-val}, la cual es llamada en el bloque 
{\tt gather}.

Un último ejemplo mostrará lo poderosa que la construcción 
\verb|gather { take }| puede ser.

Consideremos este problema publicado en el sitio Rosetta Code
(\url{http://rosettacode.org/wiki/Same_Fringe}): 
escribe una subrutina que comparará las hojas de dos árboles
binarios para determinar si son las mismas listas de hojas cuando
se visitan de izquierda a derecha. La estructura o balance de los 
árboles no importan; solo el número, orden, y valor de las hojas
es importante.
\index{rosettacode}
\index{binary tree}
\index{tree!binary}

La solución en Perl~6 usa un bloque \verb|gathe { take }|
y consiste de solo seis líneas de código:

\begin{verbatim}
sub margen ($arbol) {
    multi sub periferia (Pair $nodo) {periferia $_ for $nodo.kv;}
    multi sub periferia ( Any $hoja) {take $hoja;}
    gather periferia $arbol;
}
sub mismo-margen ($a, $b) { margen($a) eqv margen($b) }
\end{verbatim}


Perl~6 es el ganador indisputable en términos del código más
conciso que soluciona el problema.

Como una comparación, el ejemplo en Ada es casi 300 líneas en 
tamaño, los programas en C y Java tienen alrededor de 100 líneas. 
Por cierto, las soluciones más concisas a parte de Perl~6
(Clojure, Picolisp, Racket) tienen alrededor de 20~líneas y son
todos lenguajes de programación funcional, o (para Perl~5 por ejemplo)
están escritas usando conceptos de la programación funcional.
Aunque el número de líneas de código es solamente una de muchos
criterios para comparar programas y lenguajes, esto es mi opinión
honesta un testimonio en favor del paradigma de programación 
funcional y su expresividad intrínseca.
\index{functional programming}


\section{Listas Perezosas y el Operador de Secuencia}
\index{lazy!list}

Regresemos ahora a la idea de listas perezosas y estudiemos 
cómo Perl~6 puede manejarlas y usarlas.

\subsection{El Operador de Secuencia}
\index{sequence operator}
\index{operator!sequence}


Perl provee el operador de secuencia \verb|...| para construir
listas perezosas. Por ejemplo, esto:

\begin{verbatim}
my $lista-perezosa := (0, 1 ... 200);
say $lista-perezosa[42];                  # -> 42
\end{verbatim}

produce una lista perezosa de enteros sucesivos entre 0 y 200.
El compilador de Perl~6 puede o no puede alocar algunos de los 
números (dependiendo en la implementación), pero se requiere que 
produzca una lista completa inmediatamente. Los números que aún no han
sido generados pueden ser creados y suministrados más tarde, cuando 
el programa intenta usar dichos valores.

Como se explica más abajo, si quieres generar enteros consecutivos,
puedes actualmente simplificar la definición de la lista perezosa:

\begin{verbatim}
my $lista-perezosa:= (0 ... 200);
\end{verbatim}


\index{laziness}
Si asignas una secuencia a un array, todos los valores de la
secuencia se generarán inmediatamente, dado que la asignación
a un array es ansiosa (\emph{eager} en inglés) (no perezosa). 
No obstante, puedes forzar la pereza con la función integrada 
{\tt lazy} al asignar a un array:

\begin{verbatim}
my @array-perezoso = lazy 1 ... 200;     # -> [...]
say @array-perezoso.elems;               # -> No .elems con una lista perezosa
say @array-perezoso[199];                # -> 200
say @array-perezoso[200];                # -> (Any)
say @array-perezoso.elems;               # -> 200
\end{verbatim}

Aquí, \verb|@array-perezoso| es originalmente perezoso.  La evaluación 
de un artículo después del último elemento del array fuerza a Perl
a actualmente generar el array completo (y el array no es ya perezoso).
Después de eso, no elementos adicionales pueden ser generados, y {\tt .elems}
permanece en 200 (a menos que actualmente asignes valores a los elementos
después del elemento 200$^\circ$).

Cuando dos enteros son suministrados, uno para el primero y el otro para
el último artículo de una lista, el operador de secuencia  generará una
lista de enteros consecutivos entre los dos números suministrados. 
Si suministra dos artículos iniciales que definen un paso implícitamente,
esto generará una secuencia aritmética:
\index{arithmetic sequence}

\begin{verbatim}
my $impares = (1, 3 ... 15);        # (1 3 5 7 9 11 13 15)
my $pares = (0, 2 ... 42);          # (0 2 4 6 8 ... 40 42)
\end{verbatim}

Puede ser que recuerdes que, en la Sección~\ref{sequence} 
del capítulo sobre arrays y listas, dijimos que los paréntesis 
no son usualmente necesarios para construir una lista, a menos 
que sean necesarios por razones de precedencia. El código más
arriba es uno de tales ejemplos: intenta ejecutar ese código
sin los paréntesis y observa el contenido de las variables \verb|$impares|
y \verb|$pares|.

Cuando los tres números iniciales en una progresión geométrica son
suministrados, el operador de secuencia producirá una secuencia
geométrica, como en este ejemplo que produce las potencias de dos:
\index{geometric sequence}

\begin{verbatim}
say (1, 2, 4 ... 32);              # -> (1 2 4 8 16 32)
\end{verbatim}

El operador de secuencia puede también ser usado para producir
números que no son enteros, como mostramos en este ejemplo en la REPL:

\begin{verbatim}
> say (1, 1.1 ... 2);
(1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2)
\end{verbatim}

Contrario al operador de rango, el operador de secuencia puede también 
contar de forma inversa:
\index{range operator}

\begin{verbatim}
say (10 ... 1);                    #  (10 9 8 7 6 5 4 3 2 1)
\end{verbatim}

\subsection{Listas Infinitas}
\index{infinite list}

Una de las cosas grandiosas sobre las listas perezosas es que, 
dado que la evaluación de artículos es aplazada, ellas pueden ser
infinitas sin consumir recursos infinitos de la computadora:
\index{infinite list}

\begin{verbatim}
my $pares = (0, 2 ... Inf);        # (...)
say $pares[18..21];                # -> (36 38 40 42)
\end{verbatim}

El operando {\tt INf} se conoce como ``Texas`` o su equivalente
ASCII del símbolo de infinidad $\infty$.

El código anterior podría escribirse:
\index{infinity symbol}

\begin{verbatim}
my $pares = (0, 2 ... ∞); 
say $pares[21];                    # -> 42
\end{verbatim} 

La manera más común de indicar una lista perezosa infinita es con
el uso del argumento whatever \verb|*|:
\index{whatever!operator}
\index{operator!whatever}

\begin{verbatim}
my $pares = (0, 2 ... *); 
say $pares[21];                    # -> 42
\end{verbatim} 

\subsection{Uso de un Generador Explícito}
\index{sequence operator!generator}

El operador de secuencia \verb|...| es una herramienta muy poderosa
para generar listas perezosas. Dado un número, comienza a contar
desde ese número (a menos que el final de la secuencia sea
un número menor. En tal caso, cuenta en reversa.). Dado dos números
para comenzar una secuencia, la tratará como una secuencia aritmética
y añadirá la diferencia entre esos dos números al último número
generado para generar el siguiente número. Dado tres números,
verifica si representan el inicio de una secuencia aritmética
o una secuencia geométrica, y continúa la secuencia desde ahí.
\index{arithmetic sequence}
\index{geometric sequence}

No obstante, muchas secuencias interesantes no son ni aritméticas
ni geométricas. Ellas pueden aún generarse con el operador de
secuencia provisto que un término pueda deducirse desde el
número previo (o los números previos). Para este, necesitas 
proveer explícitamente el bloque de código para generar el número
siguiente en la secuencia. Por ejemplo, la lista de números 
enteros impares podría también generarse con un generador de
la siguiente manera:

\begin{verbatim}
say (1, { $_ + 2 } ... 11);        # -> (1 3 5 7 9 11)
\end{verbatim}

Tenemos ahora otra manera de definir la función factorial:
\index{factorial!with a lazy infinite list}

\begin{verbatim}
my $a;
my @fact = $a = 1, {$_ * $a++} ... *;
say @fact[0..8];          # -> (1 1 2 6 24 120 720 5040 40320)
\end{verbatim}

o, en otra forma más legible:

\begin{verbatim}
my @fact = 1, { state $a = 1; $_ * $a++} ... *;
say @fact[0..8];          # -> (1 1 2 6 24 120 720 5040 40320)
\end{verbatim}


Esta estrategia es mucha más eficiente que aquellas que hemos
visto antes para uso repetitivo, dado que automáticamente almacena
(caché) los valores previamente computados en una array perezoso.
Como podrás recordar de la Sección~\ref{memoize} 
(p.~\pageref{memoize}), \emph{caché} es el proceso por el cual
un valor se almacena en la memoria para evitar tener que calcularlo
nuevamente, con el objetivo de ahorrar tiempo y ciclos de CPU.
\index{cache}

Y podemos de igual forma construir una lista infinita perezosa 
de los números Fibonacci:
\index{Fibonacci!numbers}

\begin{verbatim}
my @fibo = 0, 1, -> $a, $b { $a + $b } ... *;
say @fibo[0..10];   # -> (0 1 1 2 3 5 8 13 21 34 55)
\end{verbatim}

Esto puede escribirse en una manera más concisa (
aunque posiblemente menos explícita y menos clara) usando
el parámetro marcador whatever \verb|*|:
\index{whatever!operator}
\index{whatever!placeholder parameter}

\begin{verbatim}
my @fibo = 0, 1, * + * ... *;
say @fibo[^10];      # -> (0 1 1 2 3 5 8 13 21 34)
\end{verbatim}

Al igual que el factorial, esto es más eficiente que 
las implementaciones que hemos visto previamente, porque 
los valores computados son almacenados en el array perezoso.
\index{cache}

Similarmente la secuencia de números enteros impares al principio
de esta sección podría generarse en una forma un poco más
concisa con el parámetro whatever "\verb|*|":
\index{sequence operator}

\begin{verbatim}
say (1, * + 2  ... 11);        # -> (1 3 5 7 9 11)
\end{verbatim}

Esta sintaxis con un asterisco se llama la \emph{clausura whatever};
regresaremos a ella más adelante.
\index{whatever!closure}

Sin embargo, al usar el operador de secuencia, hay algo que se
debe tener en cuenta: el valor final (cota superior) tiene que ser uno de los
números generados para que la lista pare en ese valor final. Por lo
contrario, el operador de secuencia construirá una lista infinita:

\begin{verbatim}
my $nums = (0, { $_ + 4 } ... 10);
say $nums[0..5];     # -> (0 4 8 12 16 20)
\end{verbatim}

Como podemos observar en este ejemplo, el generador ``salta sobre
el valor final`` (va más allá de 10), y la lista es de hecho 
infinita. Usualmente, esto no es un problema en términos
de los recursos de la computadora, dado que es una lista
infinita perezosa, pero es probablemente un error si esperabas
que la lista no sobrepasara el número 10. En este caso específico,
es muy fácil computar un punto final que coincidirá (e.g., 8 or 12),
pero puede ser más complicado encontrar un punto final válido.
Por ejemplo, no es algo trivial determinar el máximo número Fibonacci menor
que 10,000 sin primero calcular la serie de tales números hasta el
primer número que sea mayor que 10,000.

En tales casos donde es difícil predecir cuál debería ser el punto final,
podemos definir otro bloque de código para determinar si la 
secuencia debería terminar o continuar. La secuencia parará
si el bloque devuelve un valor verdadero. Por ejemplo, para 
computar los números Fibonacci hasta 100, podríamos usar esto
en el REPL:

\begin{verbatim}
> my @fibo = 0, 1, -> $a, $b { $a + $b } ... -> $c { $c > 100}
[0 1 1 2 3 5 8 13 21 34 55 89 144]
\end{verbatim}

Esto es mejor, dado que para la serie de números, pero no donde 
queríamos: queríamos que la serie parara en el último número
Fibonacci inmediatamente menor que 100, y estamos obteniendo
uno más. Sería bien fácil remover o filtrar el último número 
Fibonacci generado, pero es aún mejor si no lo generamos.
Un pequeño cambio en la sintaxis nos ayuda a lograr el resultado
esperado:

\begin{verbatim}
> my @fibo = 0, 1, -> $a, $b { $a + $b } ...^ -> $c { $c > 100}
[0 1 1 2 3 5 8 13 21 34 55 89]
\end{verbatim}

Hacer el cambio de \verb|...| a \verb|...^| significa que la lista
resultante no incluye el primer elemento para el cual la 
prueba de terminación devolvió un valor verdadero.

Similarmente, podemos limitar la sintaxis de la 
\emph{clausura whatever} en la siguiente forma:
\index{whatever!closure}

\begin{verbatim}
> say 0, 1, * + * ...^ * > 100;
(0 1 1 2 3 5 8 13 21 34 55 89)
\end{verbatim}

\section{Currificación y el Operador Whatever}
\index{curry}

{\bf Currying} (o aplicación parcial) es una técnica básica
de la programación funcional, especialmente en lenguajes de 
programación funcional puros como Haskell. El nombre ``curry``
viene del matemático americano Haskell Curry, uno de los fundadores
(con Alonzo Church) de las teorías de la lógica matemática, incluyendo
el cálculo lambda y otros. (Y, como pudiste adivinar, el lenguaje de
programación Haskell derivó su nombre del primer nombre de Curry).
\index{Curry, Haskell}
\index{Church, Alonzo}

El proceso de currying consiste en tomar una función con varios argumentos,
reemplazarla con una función que tiene un solo argumento y devolver otra 
función (usualmente una clausura) cuyo rol es procesar los argumentos
restantes.

En algunos lenguajes de programación puros, una función puede solo
tomar un argumento y devolver un resultado. Currying es una técnica 
creada para afrontar tal limitación. Perl no posee dicha limitación, 
pero currying puede todavía ser muy útil para reducir y simplificar 
las listas de argumentos en las llamadas de una subrutina, notablemente
en casos de llamadas recursivas repetidas.


\subsection{Creando una Subrutina Currificada}
\index{curry}

El ejemplo estándar de una subrutina currificada es una 
función de \emph{adición}. Supón que tenemos una función
matemática de adición, \verb|añadir(x, y)|, que toma dos 
argumentos y devuelve la suma de ellos. 

En Perl, la definición de la subrutina {\tt añadir} es
muy simple:
\index{add}

\begin{verbatim}
sub añadir (Numeric $x, Numeric $y) {return $x + $y}
\end{verbatim}

Una versión currificada de esto sería otra función \verb|añadir_y(x)|
que devuelve una función que añade $y$ a su argumento.

Esto podría lograrse con una clausura en la 
siguiente manera:
\index{curry}

\begin{verbatim}
sub hacer-adición (Numeric $val-añadido) {
    return sub ($param) {$param + $val-añadido;}    
    # alternativamente: return sub {$^a + $val-añadido;}
}
my &añadir_2 = hacer-adición 2;
say añadir_2(3);           # -> 5
say añadir_2(4.5);         # -> 6.5
\end{verbatim}

La referencia de código \verb|&añadir_2| es una versión currificada
de nuestra función matemática {\tt añadir}. Solo toma un
argumento y devuelve un valor equivalente al argumento más 2.

Por supuesto podemos crear otras subrutina currificadas usando
{\tt hacer-adición} con otros argumentos:

\begin{verbatim}
my &añadir_3= hacer-adición 3;
say &añadir_2(6);           # -> 9
\end{verbatim}

Esto no es nada nuevo: \verb|&añadir_2| y \verb|&añadir_3|
son solo clausuras que recuerdan el valor de incremento
pasado a la subrutina {\tt hacer-adición}. Esto puede
ser útil cuando algunas funciones se llaman muchas veces
(o recursivamente) con muchos argumentos, algunos de los
cuales son los mismos: la currificación de las mismas
permite simplificar las llamadas de las subrutinas.

\subsection{Currificar una Subrutina Existente con el Método {\tt assuming}}
\index{curry}
\index{method!assuming}

Si una subrutina ya existe, usualmente no hay necesidad de
crear una clausura nueva con la ayuda 
de una ``función factoría`` (tal como {\tt hacer-añadir}) 
como hicimos anteriormente. Es posible currificar una función
existente, usando el método {\tt assuming} sobre la misma:
\index{assuming method}
\index{function factory}

\begin{verbatim}
sub añadir (Numeric $x, Numeric $y) {return $x + $y}   
my &añadir_2 = &añadir.assuming(2);                       
añadir_2(5);              # -> 7                                     
\end{verbatim}

El método {\tt assuming} devuelve un objeto callable (es decir,
que puede llamarse) que implementa el mismo comportamiento de
la subrutina original, pero que tiene los valores pasados
a {\tt assuming} ya atados a los parámetros correspondientes.

Es también posible currificar funciones integradas. Por ejemplo,
la función integrada {\tt substr} toma normalmente tres argumentos:
la cadena de texto sobre la cual opera, la posición inicial, y la
longitud de la subcadena de texto a ser extraída. Podrías tener
que realizar un número de extracciones sobre la misma cadena de
texto. Puedes crear una versión currificada de {\tt substr} 
siempre trabajando sobre la misma cadena de texto:
\index{substr function}

\begin{verbatim}
my $cad = "Cogito, ergo sum";                     
my &cadena-inicio = &substr.assuming($cad, 0);
say &cadena-inicio($_) for 6, 13, 16; 
\end{verbatim}

Esto imprimirá:

\begin{verbatim}
Cogito
Cogito, ergo
Cogito, ergo sum
\end{verbatim}

Nota que hemos ``asumido`` dos parámetros aquí, así que la
subrutina currificada ``recuerda`` los dos primeros argumentos
y solo el tercer argumento necesita pasarse a 
\verb|&cadena-inicio|.

Hasta puedes currificar los operadores de Perl~6 (o aquellos
que creas) si así lo deseas:
\index{assuming method}

\begin{verbatim}
my &añadir_2 = &infix:<+>.assuming(2);
\end{verbatim}

\subsection{Currificando con el Parámetro Whatever Star}
\index{curry}
\index{whatever!term}
\index{whatever!star parameter}
\label{whatever star parameter}

Una manera más flexible de currificar una subrutina o una 
expresión es con el uso del argumento \emph{whatever star} (*):

\begin{verbatim}
my &tercio = * / 3; 
say tercio(126);          # -> 42
\end{verbatim}

El \emph{whatever star} (*) es un marcador para un argumento, así
que la expresión devuelve una clausura.

Puede usarse en una forma similar a la variable tópica \verb|$_| 
(excepto que no tiene que existir cuando se hace la declaración):

\begin{verbatim}
> say map 'foo' x * , (1, 3, 2);
(foo foofoofoo foofoo)
\end{verbatim}
\index{map}

Es también posible usar múltiple términos whatever en la
misma expresión. Por ejemplo, la subrutina {\tt añadir}
podría escribirse como una expresión whatever con dos 
parámetros:

\begin{verbatim}
my $añadir = * + *;
say $añadir(4, 5);          # -> 9
\end{verbatim}

o:

\begin{verbatim}
my &añadir = * + *;
say añadir(4, 5);           # -> 9
\end{verbatim}

Podrías hacer lo mismo con el operador de multiplicación:

\begin{verbatim}
my $mult = * * *;
say $mult(6, 7);         # -> 42
\end{verbatim}

El compilador no se confundirá y será capaz de determinar
correctamente que el primer y tercer asterisco son
términos whatever y que el segundo asterisco es el operador
de multiplicación; en otras palabras, esto es más o menos 
equivalente a esto:
\index{whatever!term}

\begin{verbatim}
my $mult = { $^a * $^b };
say $mult(6, 7);         # -> 42
\end{verbatim}

o a esto:

\begin{verbatim}
my $mult = -> $a, $b { $a * $b }
say $mult(6, 7);         # -> 42  
\end{verbatim}

Para ser honesto, el compilador no se confunde, pero el 
usuario podría, a menos que ella o él haya sido previamente
expuesta/o a algunos lenguajes de programación funcional que
comúnmente usan este tipo de construcción sintáctica.

Estas ideas son poderosas, pero se te aconseja que preste atención
para que no caigas en la trampa de la ofuscación de código.

Con eso dicho, el paradigma de programación funcional es extremadamente
expresivo y puede hacer tu código mucho más corto. Y, sobre todo,
código más corto, provisto que permanezca claro y fácil de 
entender, tendrá menos errores que código más largo.

\section{Usando un Estilo de Programación Funcional}
\index{functional programming!style}
\label{funcstyle}

En este capítulo, hemos visto cómo usar técnicas derivadas de
la programación funcional para hacer nuestro código más simple
y más expresivo. Aunque, de cierta manera, no hemos aplicado
la programación funcional completamente. Todas las técnicas
que hemos vistos tienen sus orígenes en la programación funcional,
pero la verdadera esencia de la programación funcional no es
acerca del uso de funciones de orden superior, procesamiento de
listas y la programación de tuberías, subrutinas anónimas y clausuras,
listas perezosas y currificación, etc. La verdadera esencia de la
programación funcional es una mentalidad que trata las computaciones
como las evaluaciones de funciones matemáticas y evita el cambio
de estado y los datos mutables.
\index{functional programming!style}
\index{pipe-line programming}

En lugar de simplemente usar las técnicas derivadas de la
programación funcional, podemos ir un paso más lejos y actualmente
escribir código en un estilo de programación funcional. 
Si vamos a evitar el cambio de estado y los datos mutables, esto
significa no usaremos variables (o por lo menos no las cambiaremos,
y las trataremos como datos inmutables) y haremos las cosas
diferentemente.

\subsection{El Algoritmo de Ordenamiento por Mezcla}
\label{mergesort}
\index{merge sort}
\index{sort!merge sort}

Considera el ejemplo de una técnica clásica y eficiente de ordenamiento
conocida como el ordenamiento por mezcla (\emph{merge sort} en inglés),
inventada por  John von Neumann en 1945. Dicha técnica está basada en el
hecho de que si tienes dos arrays ordenados, es significativamente más
rápido mezclar los dos arrays en un único array, al leer cada array en 
paralelo y escoger el artículo apropiado de cualquiera de los arrays,
que lo que sería si ordenamos los datos de los dos arrays ciegamente.
\index{von Neumann, John}
\index{merging arrays or lists}

El ordenamiento por mezcla es un algoritmo de ``divide y conquista``
que consiste de dividir el array de entrada desordenado recursivamente
en sub-listas pequeñas y más pequeñas, hasta que cada sub-lista contenga
solo un artículo (por definición, en este punto la sub-lista está ordenada)
, y después mezcla las sub-listas devuelta en un array ordenado.
\index{divide and conquer algorithm}

Para evitar agregar complejidad innecesaria, aquí discutiremos 
implementaciones que simplemente ordenan números en orden 
numérico ascendente.


\subsection{Una Implementación No Funcional de Ordenamiento por Mezcla}
\index{merge sort! non functional implementation}

Así es cómo podríamos implementar un algoritmo de ordenamiento por mezcla
usando la programación puramente imperativa/procedimental:

\begin{verbatim}
# ATENCIÓN: código defectuso
sub ord-mezcla( @salida, @a-ordenarse, $ini = 0, $fin = @a-ordenarse.end ) {
    return if $fin - $ini  < 2;
    my $medio = ($fin + $ini) div 2;
    my @primero = ord-mezcla(@a-ordenarse, @salida, $ini, $medio);
    my $segundo = ord-mezcla(@a-ordenarse, @salida, $medio, $fin);
    mezclar-listas(@salida, @a-ordenarse, $ini, $medio, $fin);
}
sub mezclar-listas( @entrada, @salida, $ini, $medio, $fin ) {
    my $i = $ini;
    my $j = $medio;
    for $ini..$fin  -> $k {
        if $i < $medio and ($j >= $fin or @entrada[$i] <= @entrada[$j]) {
            @salida[$k] = @entrada[$i];
            $i++;
        } else {
            @salida[$k] = @entrada[$j];
            $j++;
        } 
    }
}
my @array = reverse 1..10;
my @salida = @array;
ord-mezcla  @salida, @array;
say @salida;
\end{verbatim}

Este programa siempre funciona sobre el array completo (y su copia)
y las sub-listas no son extraídas; la extracción es simulada por el
uso de los subíndices de rango.

Este código no es muy largo, aunque no obstante un poco complicado.
Si intentas ejecutarlo, encontrarás que hay un error (\emph{bug}):
el último del array original no es ordenado apropiadamente. Por 
ejemplo, si intentas ejecutarlo sobre una lista de 10 números enteros
en orden inverso (e.g., ordenados del 10 al 1, {\tt @array}) 
usado en la prueba al final del código más arriba, obtendrás 
el siguiente array:

\begin{verbatim}
[2 3 4 5 6 7 8 9 10 1]
\end{verbatim}


Como un ejercicio, intenta arreglar el error antes de continuar
(el error será arreglado más adelante).

Es probable que notarás que identificar y corregir el error es difícil,
aunque el error es relativamente simple (cuando escribí este código, 
encontré errores más complicados antes de encontrar este). Es bastante
difícil de usar los subíndices de array apropiadamente e insertar
los artículos en el lugar correcto, y así evitar errores por uno 
(\emph{off-by-one errors} en inglés) y otros errores.
\index{off-by-one error}

Esta es la versión corregida:

\begin{verbatim}
sub ord-mezcla( @salida, @a-ordenarse, $ini = 0, $fin = @a-ordenarse.elems ) {
    return if $fin - $ini < 2;
    my $medio = ($fin + $ini) div 2;
    ord-mezcla(@a-ordenarse, @salida, $ini, $medio);
    ord-mezcla(@a-ordenarse, @salida, $medio, $fin);
    mezclar-listas(@salida, @a-ordenarse, $ini, $medio, $fin);
}
sub mezclar-listas( @entrada, @salida, $ini, $medio, $fin ) {
    my $i = $ini;
    my $j = $medio;
    for $ini..$fin - 1  -> $k {
        if $i < $medio and ($j >= $fin or @entrada[$i] <= @entrada[$j]) {
            @salida[$k] = @entrada[$i];
            $i++;
        } else {
            @salida[$k] = @entrada[$j];
            $j++;
        } 
    }
}
my @array = pick 20, 1..100;
my @salida = @array;
ord-mezcla  @salida, @array;
say @salida;
\end{verbatim}

El cambio principal se encuentra en la signatura de la subrutina
\verb|ord-mezcla|: el valor por defecto para el parámetro \verb|$fin|
es el tamaño (número de elementos) del array, y no el subíndice del
último elemento del array (así que el error fue un error por uno).
Hacer esta corrección causa que sea necesario el cambio del
bloque puntiagudo (\verb'for $ini..$fin - 1 -> ...') en la
subrutina \verb|mezclar-listas|.
\index{off-by-one error}

Para 20 números enteros aleatorios entre 1 y 100, esto imprime
lo siguiente:

\begin{verbatim}
[11 13 14 15 19 24 25 29 39 46 52 57 62 68 81 83 89 92 94 99]
\end{verbatim}


La lección a tomar es que es difícil entender la implementación detallada del
algoritmo, y bastante complicada de depurar, hasta usando el depurador
de Perl~6 presentado en la Sección~\ref{perl-debugger}.
\index{debugger}
\index{merge sort! non functional implementation}

\subsection{Una Implementación Funcional de Ordenamiento por Mezcla}
\index{merge sort!functional implementation}
En lugar de modificar el array completo en cada paso a través del proceso
(y confundirnos con el manejo de los subíndices), podemos dividir recursivamente
los datos en sub-listas y proseguir con estas sub-listas.

Esto nos puede conllevar a la siguiente implementación:

\begin{verbatim}
sub ord-mezcla( @a-ordenarse ) {
    return @a-ordenarse if @a-ordenarse < 2;
    my $medio = @a-ordenarse.elems div 2;
    my @primero = ord-mezcla(@a-ordenarse[0 .. $medio - 1]);
    my @segundo = ord-mezcla(@a-ordenarse[$medio .. @a-ordenarse.end]);
    return mezclar-listas(@primero, @segundo);
}
sub mezclar-listas( @uno, @dos ) {
    my @result;
    loop {
        return @result.append(@dos) unless @uno;
        return @result.append(@uno) unless @dos;
        push @result, @uno[0] < @dos[0] ?? shift @uno !! shift @dos;
    }
} 
\end{verbatim}

El código es más corto que la implementación previa, pero
ese no es el punto principal.

La subrutina {\tt ord-mezcla} es algo similar a la implementación 
previa, excepto que crea las sub-listas recursivamente y 
después mezcla dichas sub-listas.

La parte más simplificada de esta implementación ahora es la 
subrutina {\tt mezclar-listas} (la cual realiza la mayor
parte del trabajo en ambas implementaciones): 
recibe dos sub-listas y las mezcla. La mayor parte de este
trabajo se realiza en la última línea de código; las dos penúltimas
líneas solo se encargan de devolver la lista mezclada cuando una
de las sub-listas de entrada no contiene elementos.
\index{merge sort!functional implementation}

Esta versión funcional del programa captura la esencia del algoritmo
de ordenamiento por mezcla:
\begin{itemize}
\item Si el array contiene menos de dos artículos, ya se encuentra
ordenado. Por lo tanto, devuélvelo inmediatamente (este es el caso base
que detiene la recursión).
\index{base case}
\index{recursion!base case}
\item De lo contrario, escoge la posición central del array para dividirlo
en dos sub-listas, y llama a \verb|mezclar-listas| con dichas sub-listas
recursivamente;
\item Mezcla las sub-listas ordenadas que han sido generadas hasta el momento.
\item Devuelve la lista mezclada a la función que realiza la llamada.
\end{itemize}

\index{functional programming!style}
Espero que puedas ver lo limpia y clara que es la implementación al
estilo funcional. Para darte una idea, escribir y depurar este
último programa me tomó alrededor de 15~minutos, i.e., cerca
de 10~minutos menos que la versión que no es funcional. Si no lo crees,
intenta implementar estas dos versiones por ti mismo. (Es un
ejercicio excelente aún si me crees.)

La sección de ejercicios de este capítulo (Sección~\ref{quicksort}) 
proveerá otro (y probablemente más relevante) ejemplo sobre la simplicidad
de la programación funcional comparada a estrategias
más imperativas o procedimentales.

\section{Depuración de Programas}
\label{test_module}
\index{testing!automated tests}

Esta vez, no hablaremos sobre la depuración en sí misma,
sino acerca de una actividad relacionada, pruebas de software 
(\emph{testing} en inglés).

Las pruebas de software es una parte integral del desarrollo de software.
En Perl~6, el módulo estándar {\tt Test} (instalado conjuntamente con Rakudo)
provee una plataforma de pruebas la cual habilita la verificación automatizada
y repetitiva del comportamiento del código.

\index{test module}
\index{testing!module}

Las funciones de pruebas emiten salidas que se ajustan al \emph{Test 
Anything Protocol} or TAP (\url{http://testanything.org/}), un formato 
estandarizado de pruebas que tiene implementaciones en Perl, 
C, C++, C\#, Ada, Lisp, Erlang, Python, Ruby, Lua, PHP, Java, 
Go, JavaScript, y otros lenguajes.

Un archivo de pruebas típico luce así:

\begin{verbatim}
use v6;
use Test;      # un módulo estándar incluido con Rakudo
use lib 'lib';

# ...

plan $num-tests;

# .... pruebas

done-testing;  # opcional con 'plan'
\end{verbatim}

Nos aseguramos que estamos utilizando Perl~6, a través del uso
del prasma \verb|v6|, después cargamos el módulo \verb|Test|
y especificamos donde se encuentran nuestras librerías. Consiguientemente,
especificamos el número de pruebas que planeamos en ejecutar
(así la framework de pruebas nos dejará saber cuantas pruebas se
ejecutaron) y cuando finalizamos con las pruebas, usamos {\tt done-testing}
para decirle a la framework que hemos acabado.

Ya hemos visto un pequeño ejemplo sobre el uso del módulo \verb|Test| en
la Sección~\ref{sol_fact_operator} (solución al ejercicio 
de la Sección~\ref{operator_construction}).

El módulo \verb|Test| exporta varias funciones que chequean el valor devuelto
por una función dada, y produce una salida estandarizada 
de prueba.

En la práctica, la expresión usualmente será una llamada a la función 
o método al cual quieres aplicar la prueba. Podrías querer chequear:

\begin{itemize}
\item Veracidad: 
\begin{verbatim}
ok($valor, $descripción?); 
nok($condición, $descripción?);
\end{verbatim}
\index{ok function (testing)}
\index{nok function (testing)}
\index{test module!ok function}
\index{test module!nok function}

La función {\tt ok} marca una prueba como aprobada (o pasada) si el
\verb|$valor| dado evalúa a verdadero (\emph{true}) en un
contexto Booleano. Al contrario, la función {\tt nok} marca
una prueba como aprobada si el valor dado evalúa a falso (\emph{false}).
Ambas funciones aceptan una \verb|descripción| opcional de
la prueba.
Por ejemplo:

\begin{verbatim}
ok  $respuesta.success, 'La respuesta HTTP fue exitosa';
nok $búsqueda.error,      'Búsqueda completada sin error';
\end{verbatim}

\item Comparación de cadenas de texto:
\begin{verbatim}
is($valor, $esperado, $descripción?)
\end{verbatim}
\index{is function (testing)}
\index{test module!is function}

La función {\tt is} marca una prueba como aprobada si \verb|$valor|
y \verb|$esperado| comparan positivamente con el operador \verb|eq|.
La función acepta una descripción opcional de la prueba.
\index{string equality}

\item Aproximar comparación numérica:

\begin{verbatim}
is-approx($valor, $esperado, $descripción?)
\end{verbatim}
\index{is-approx function (testing)}
\index{test module!is-approx function}

La función {\tt is-approx} marca una prueba como aprobada si los
valores numéricos \verb|$valor| y \verb|$esperado| son aproximadamente
iguales. La subrutina puede llamarse en varias maneras que te permiten
hacer la prueba usando tolerancia relativa o absoluta de diferentes
valores. (Si no se especifica una tolerancia, la tolerancia por defecto
será una tolerancia absoluta de $10^{-5}$.)
\index{approximate numeric equality}

\item Regex:

\begin{verbatim}
like($valor, $regex-esperado, $descripción?)
unlike($valor, $regex-esperado, $descripción?)
\end{verbatim}
\index{like function (testing)}
\index{unlike function (testing)}
\index{test module!like function}
\index{test module!unlike function}

La función {\tt like} marca una prueba como aprobada si 
el \verb|$valor| coincide con el \verb|$regex-esperado|.
Dado que estamos hablando de regexes, ``coincide``, en la
oración anterior, realmente se refiere a ``coincidencias inteligentes``.
La función {\tt unlike} marca una prueba como aprobada si el
\verb|$valor| no coincide con \verb|$regex-esperado|.

Por ejemplo:
\begin{verbatim}
like 'foo', /fo/, 'foo se parece a fo';
unlike 'foo', /bar/, 'foo no se parace a bar';
\end{verbatim}

\item Y un sin número de otras funciones que puedes estudiar
en la siguiente documentación: \url{https://docs.perl6.org/language/testing.html}.

\end{itemize}

En principio, podrías usar a {\tt ok} para cada tipo de prueba
de comparación, al incluir la comparación en la expresión que se
pasa como un valor:
\index{factorial}

\begin{verbatim}
ok factorial(4) == 24, 'Factorial - entero pequeño';
\end{verbatim}

No obstante, es mejor (donde sea posible) usar una de las
funciones especializadas de comparaciones, porque pueden  
imprimir diagnósticos más útiles en casos en los cuales la
comparación falla.

Si una prueba falla (aunque parece ser exitosa), 
y no entiendes la razón por la cual falla,
podrías querer usar la función \verb|diag| para obtener información
adicional. Por ejemplo, asume que la prueba:


\begin{verbatim}
ok $foo, 'simple prueba';
\end{verbatim} 

está fallando y que no posees información suficiente para 
entender el por qué; podrías intentar esto:
\index{diag function (test diagnostic}

\begin{verbatim}
diag "comentario extenso" unless
    ok $foo, 'simple prueba';
\end{verbatim}

Esto te podría proveer con la información adicional que 
necesitas.

Supón que queremos probar una subrutina para determinar 
si una cadena de texto dada es palíndroma (como se 
discutió en varios capítulos de este libro, ver por ejemplo
Ejercicio~\ref{palindrome} y Subsección~\ref{palindrome_2}).
Podrías llevar la prueba a cabo al escribir algo como esto:
\index{palindrome}

\begin{verbatim}
# archivo es-palindroma.p6
use v6;

sub es-palindroma($s) { $s eq $s.flip }

multi sub MAIN( $entrada ) {
    if es-palindroma( $input ) {
        say "'$entrada' es palíndroma.";
    }
    else {
        say "'$entrada' no es palíndroma.";
    }
}

multi sub MAIN(:$test!) {
    use Test;
    plan 4;
    ok es-palindroma(''), 'cadena vacía';
    ok es-palindroma('aba'), 'ejemplo con tamaño impar';
    ok es-palindroma('abba'), 'ejemplo con tamaño par';
    nok es-palindroma('blabba'), 'contraejemplo';
}
\end{verbatim}

Usualmente, las pruebas están almacenadas en diferentes archivos
que se encuentran en un subdirectorio ``t``. En este ejemplo corto,
todo está en el mismo archivo, pero dos subrutinas multi {\tt MAIN} 
son suministradas para probar si un argumento pasado es un palíndromo
o para ejecutar el plan de prueba. Ver Sección~\ref{MAIN} (p.~\pageref{MAIN} 
y Subsección~\ref{MAIN_sub} (p.~\pageref{MAIN_sub})
si necesitas un repaso sobre la subrutina {\tt MAIN}.
\index{MAIN}
\index{multi subroutines}

Puedes ejecutar estas pruebas en la siguiente manera:

\begin{verbatim}
$ perl6 es-palindroma.p6 abba
'abba' es palíndroma.
$ perl6 es-palindroma.p66 abbaa
'abbaa' no es palíndroma.
$
$ perl6 es-palindroma.p6 --test
1..4
ok 1 - cadena vacía
ok 2 - ejemplo con tamaño impar
ok 3 - ejemplo con tamaño par
ok 4 - contraejemplo
\end{verbatim}

Prueba este ejemplo, juega con el mismo, cambia algunas
líneas, agrega nuevas pruebas, y observa lo que pasa.

Escribir tales unidades de pruebas puede ser una tarea 
tediosa. La verdad es que solo las pruebas manuales son
algo tediosas, y solo intentas, encontrarás que escribir
y usar tales pruebas hacer que la tarea de pruebas sea menos
complicada. Usualmente escribes las pruebas una sola vez,
y las ejecutas un sin número de veces. !`Y te sorprenderás 
cuantos errores encontrarás aún si estás seguro que tu código
está correcto! También, una vez que escribes un conjunto de 
pruebas para algo, podrías usarlo años más tarde, por ejemplo 
para pruebas no regresivas después de un cambio de software.
Esto no es solo ahorra tiempo sino que también garantiza que
estás suministrando software de buena calidad.
\index{non-regression test}

Muchas organizaciones actualmente escriben sus pruebas antes
de escribir los programas. Este proceso se conoce como 
\emph{desarrollo guiado por pruebas} y hay muchas áreas donde
es muy exitoso. De hecho, el compilador de Rakudo/Perl~6 
tenía un inmenso conjunto de pruebas (más de 40,000 pruebas) 
mucho antes que el compilador estuviera listo. En cierta manera,
el conjunto de pruebas hasta se convirtió en la especificación
verdadera del proyecto, para que así cualquier persona pudiera usar el mismo 
conjunto de pruebas para verificar otra implementación de Perl~6.
\index{test-driven development}

Una ventaja adicional de tal estrategia es que medir la proporción
de pruebas que pasan puede ser una mejor medida de la realización de software
que los estimados fortuitos, tales como, por ejemplo, una proporción
del número de líneas de código escrito versus el estimado del
número final de líneas de código.
\index{software metric}

\section{Glosario}

\begin{description}

\item[Objeto de primera clase] Un objeto que puede
pasarse como un argumento a una subrutina o devolverse 
como un valor de retorno de la misma. En Perl, las subrutinas
son objetos de primera clase (también llamados ciudadanos de
primera clase).. 
\index{first-class object}
\index{first-class citizen}

\item[Función retrollamada] Una función o subrutina que se pasa
como un argumento a otra función.
\index{callback function}

\item[Función de orden superior] Una función o subrutina que toma
otra subrutina (o un simple bloque de código) como un 
argumento. Las funciones integradas 
{\tt map}, {\tt grep}, {\tt reduce}, y {\tt sort}
son ejemplos de funciones de orden superior.
\index{higher-order function}
\index{function!higher-order}
\index{map}
\index{grep}
\index{reduce}

\item[Subrutina anónima] Una subrutina que carece de nombre. 
También llamada comúnmente una \emph{lambda}. Aunque no
son exactamente lo mismo, los bloques puntiagudos pueden también
ser asimilados en subrutinas anónimas.
\index{anonymous subroutine}
\index{lambda}

\item[Clausura] Una función que puede acceder variables que 
están lexicalmente disponible donde la función es definida, 
incluso aquellas variables que ya no se encuentran en el
ámbito donde la función es llamada.
\index{closure}

\item[Programación de tubería] Un modelo de programación en el
cual piezas de datos (usualmente listas) experimentan transformaciones
sucesivas como en una tubería o línea de ensamblaje.
\index{pipe-line programming}

\item[Reducción] Un proceso a través del cual una lista de valores
es reducida a un valor único. Por ejemplo, una lista de números
puede reducirse para así encontrar el promedio, un valor
máximo, o una mediana. Algunos lenguajes conocen este proceso como
\emph{folding}.
\index{reduction}

\item[Metaoperador] Un operador que actúa sobre otro operador para
proveer nuevas funcionalidades.
\index{metaoperator}

\item[Complexidad algorítmica] Una medida aproximada del número de operaciones 
(y tiempo) necesarias para realizar una computación sobre
un conjunto de datos relativamente grande, y, más precisamente, una 
medida de cómo un algoritmo escala cuando el conjunto de datos 
crece.
\index{algorithmic complexity}

\item[Evaluación peresoza] Un proceso de evaluación aplazada donde,
por ejemplo, uno puebla una lista o procesa los artículos de una 
lista solamente a petición, cuando es requerido, para evitar 
procesamiento innecesario.
\index{laziness}

\item[Iterador] Una pieza de código que devuelve valores a petición
y mantiene un récord de donde ha llegado, para de este modo ser
capaz de saber cuál valor debería ser proveído en la siguiente 
iteración.
\index{iterator}

\item[Cache] El proceso de caché se refiere al almacenamiento de un valor 
en la memoria (en una variable, un array, un hash, etc.) para de esta 
forma evitar la necesidad de calcularlo nuevamente, y como 
resultado ahorrar algún tiempo de computación.
\index{cache}

\item[Currificación] Esta técnica hace referencia al hecho de 
tomar una función que acepta varios argumentos y transformarla en 
una serie de funciones que toman un menor número de argumentos.
\index{curry}

\item[Desarrollo guiado por pruebas] Una metodología de desarrollo donde las
pruebas de software se escriben de las especificaciones antes que 
el programa actual. Esto se hace para que sea más fácil chequear que 
el programa cumple con las especificaciones.
\index{test-driven development}

\end{description}

\section{Ejercicio: Ordenamiento Rápido}
\label{quicksort}
\index{quick sort}
\index{sort!quick sort}

\begin{exercise}
El ordenamiento rápido es un algoritmo de ordenamiento ``divide y conquista``
inventado por Tony Hoare en 1959. Se basa en la división del array
a ser ordenado. Para dividir un array, un elemento conocido el pivote
es seleccionado. Todos los elementos más pequeños que el pivote son
en frente del mismo y todos aquellos que son más grandes son movidos
después del mismo. Las sublistas compuestas de los elementos más pequeños
y más grandes son entonces recursivamente ordenadas a través del mismo 
procedimiento y finalmente reagrupadas.
\index{Hoare, Charles Antony Richard}
\index{divide and conquer algorithm}

Una de las dificultades es seleccionar el pivote correcto. Idealmente
debería ser el valor mediano de los artículos del array, dado que
esto daría particiones de igual tamaño, por consiguiente haciendo el 
algoritmo óptimamente eficiente, pero encontrar el valor mediano 
para cada partición tomaría tiempo y últimamente penalizaría el
dicho rendimiento. Varias variantes de ordenamiento rápido se han 
intentado, con diferentes estrategias para seleccionar (usualmente de
forma arbitraria) un pivote. Aquí, seleccionamos un elemento en o
cerca del medio de la partición.
\index{pivot!quick sort algorithm}

La siguiente es una implementación típica del algoritmo de 
ordenamiento rápido que no usa la programación funcional.

\begin{verbatim}[fontshape=up]
sub ordrapido(@entrada) {
    sub intercambiar ($x, $y) {
        (@entrada[$x], @entrada[$y]) = @entrada[$y], @entrada[$x];
    }
    sub rap_ord ($izq, $der) {
        my $pivote = @entrada[($izq + $der) div 2];
        my $i = $izq;
        my $j = $der;
        while $i < $j {
            $i++ while @entrada[$i] < $pivote;
            $j-- while @entrada[$j] > $pivote;
            if $i <= $j {
                intercambiar $i, $j;
                $i++;
                $j--;
            }
        }
        rap_ord($izq, $j) if $izq < $j;
        rap_ord($i, $der) if $j < $der;
    }
    rap_ord(0, @entrada.end)
}
my @array = pick 20, 1..100;
ordrapido @array;
say @array;
\end{verbatim}

El array es modificado en lugar (lo cual tiene la ventaja de 
requerir memoria limitada), lo cual significa que el array 
original es modificado.

Para la programación funcional, los datos internos son inmutables, 
por lo tanto copias fragmentos de datos en nuevas listas, en lugar 
de modificarlos ``en el lugar``.

Con el mismo espíritu que lo hicimos en la sección\ref{funcstyle}
para el algoritmo de ordenamiento de mezcla, trata de escribir una
implementación del algoritmo de ordenamiento rápido. Pista: esto 
se puede hacer la mitad de una docena de líneas de código. 

Solución: \ref{sol_quicksort}.
\index{quick sort}

\end{exercise}

